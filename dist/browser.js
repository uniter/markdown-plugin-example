/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./browser/entry.php");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./browser/bootstrap.js":
/*!******************************!*\
  !*** ./browser/bootstrap.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Example of how to use Uniter's experimental inline PHP Markdown plugin
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin-example
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin-example/raw/master/MIT-LICENSE.txt
 */

module.exports = function (engine) {
    engine.defineGlobal('domDocument', document);
};


/***/ }),

/***/ "./browser/entry.php":
/*!***************************!*\
  !*** ./browser/entry.php ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("browser/entry.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var $domDocument = tools.createDebugVar(scope, "domDocument");var $markdown = tools.createDebugVar(scope, "markdown");var line;tools.instrument(function () {return line;});line = 3;namespaceScope.use("MyUniterProjects\\MarkdownPluginExample\\Markdown");line = 5;(line = 5, tools.requireOnce((line = 5, (line = 5, tools.getPathDirectory()).concat((line = 5, tools.valueFactory.createString("/../vendor/autoload.php")))).getNative(), scope));line = 7;(line = 7, (line = 7, scope.getVariable("markdown")).setValue((line = 7, tools.createInstance(namespaceScope, (line = 7, tools.valueFactory.createBarewordString("Markdown")), []))));line = 9;(line = 9, (line = 9, tools.implyObject((line = 9, (line = 9, scope.getVariable("domDocument").getValue()).callMethod((line = 9, tools.valueFactory.createBarewordString("getElementById")).getNative(), [(line = 9, tools.valueFactory.createString("main"))]))).getInstancePropertyByName((line = 9, tools.valueFactory.createBarewordString("innerHTML")))).setValue((line = 9, (line = 9, scope.getVariable("markdown").getValue()).callMethod((line = 9, tools.valueFactory.createBarewordString("getHtml")).getNative(), []))));return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./node_modules/d/auto-bind.js":
/*!*************************************!*\
  !*** ./node_modules/d/auto-bind.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue             = __webpack_require__(/*! type/value/is */ "./node_modules/type/value/is.js")
  , ensureValue         = __webpack_require__(/*! type/value/ensure */ "./node_modules/type/value/ensure.js")
  , ensurePlainFunction = __webpack_require__(/*! type/plain-function/ensure */ "./node_modules/type/plain-function/ensure.js")
  , copy                = __webpack_require__(/*! es5-ext/object/copy */ "./node_modules/es5-ext/object/copy.js")
  , normalizeOptions    = __webpack_require__(/*! es5-ext/object/normalize-options */ "./node_modules/es5-ext/object/normalize-options.js")
  , map                 = __webpack_require__(/*! es5-ext/object/map */ "./node_modules/es5-ext/object/map.js");

var bind = Function.prototype.bind
  , defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, options) {
	var value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, options*/) {
	var options = normalizeOptions(arguments[1]);
	if (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);
	return map(props, function (desc, name) { return define(name, desc, options); });
};


/***/ }),

/***/ "./node_modules/d/index.js":
/*!*********************************!*\
  !*** ./node_modules/d/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue         = __webpack_require__(/*! type/value/is */ "./node_modules/type/value/is.js")
  , isPlainFunction = __webpack_require__(/*! type/plain-function/is */ "./node_modules/type/plain-function/is.js")
  , assign          = __webpack_require__(/*! es5-ext/object/assign */ "./node_modules/es5-ext/object/assign/index.js")
  , normalizeOpts   = __webpack_require__(/*! es5-ext/object/normalize-options */ "./node_modules/es5-ext/object/normalize-options.js")
  , contains        = __webpack_require__(/*! es5-ext/string/#/contains */ "./node_modules/es5-ext/string/#/contains/index.js");

var d = (module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if (arguments.length < 2 || typeof dscr !== "string") {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
		w = contains.call(dscr, "w");
	} else {
		c = w = true;
		e = false;
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
});

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== "string") {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (!isValue(get)) {
		get = undefined;
	} else if (!isPlainFunction(get)) {
		options = get;
		get = set = undefined;
	} else if (!isValue(set)) {
		set = undefined;
	} else if (!isPlainFunction(set)) {
		options = set;
		set = undefined;
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
	} else {
		c = true;
		e = false;
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),

/***/ "./node_modules/es5-ext/array/#/clear.js":
/*!***********************************************!*\
  !*** ./node_modules/es5-ext/array/#/clear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear



var value = __webpack_require__(/*! ../../object/valid-value */ "./node_modules/es5-ext/object/valid-value.js");

module.exports = function () {
	value(this).length = 0;
	return this;
};


/***/ }),

/***/ "./node_modules/es5-ext/array/from/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es5-ext/array/from/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es5-ext/array/from/is-implemented.js")() ? Array.from : __webpack_require__(/*! ./shim */ "./node_modules/es5-ext/array/from/shim.js");


/***/ }),

/***/ "./node_modules/es5-ext/array/from/is-implemented.js":
/*!***********************************************************!*\
  !*** ./node_modules/es5-ext/array/from/is-implemented.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var from = Array.from, arr, result;
	if (typeof from !== "function") return false;
	arr = ["raz", "dwa"];
	result = from(arr);
	return Boolean(result && result !== arr && result[1] === "dwa");
};


/***/ }),

/***/ "./node_modules/es5-ext/array/from/shim.js":
/*!*************************************************!*\
  !*** ./node_modules/es5-ext/array/from/shim.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var iteratorSymbol = __webpack_require__(/*! es6-symbol */ "./node_modules/es6-symbol/index.js").iterator
  , isArguments    = __webpack_require__(/*! ../../function/is-arguments */ "./node_modules/es5-ext/function/is-arguments.js")
  , isFunction     = __webpack_require__(/*! ../../function/is-function */ "./node_modules/es5-ext/function/is-function.js")
  , toPosInt       = __webpack_require__(/*! ../../number/to-pos-integer */ "./node_modules/es5-ext/number/to-pos-integer.js")
  , callable       = __webpack_require__(/*! ../../object/valid-callable */ "./node_modules/es5-ext/object/valid-callable.js")
  , validValue     = __webpack_require__(/*! ../../object/valid-value */ "./node_modules/es5-ext/object/valid-value.js")
  , isValue        = __webpack_require__(/*! ../../object/is-value */ "./node_modules/es5-ext/object/is-value.js")
  , isString       = __webpack_require__(/*! ../../string/is-string */ "./node_modules/es5-ext/string/is-string.js")
  , isArray        = Array.isArray
  , call           = Function.prototype.call
  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
  , defineProperty = Object.defineProperty;

// eslint-disable-next-line complexity, max-lines-per-function
module.exports = function (arrayLike/*, mapFn, thisArg*/) {
	var mapFn = arguments[1]
	  , thisArg = arguments[2]
	  , Context
	  , i
	  , j
	  , arr
	  , length
	  , code
	  , iterator
	  , result
	  , getIterator
	  , value;

	arrayLike = Object(validValue(arrayLike));

	if (isValue(mapFn)) callable(mapFn);
	if (!this || this === Array || !isFunction(this)) {
		// Result: Plain array
		if (!mapFn) {
			if (isArguments(arrayLike)) {
				// Source: Arguments
				length = arrayLike.length;
				if (length !== 1) return Array.apply(null, arrayLike);
				arr = new Array(1);
				arr[0] = arrayLike[0];
				return arr;
			}
			if (isArray(arrayLike)) {
				// Source: Array
				arr = new Array((length = arrayLike.length));
				for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
				return arr;
			}
		}
		arr = [];
	} else {
		// Result: Non plain array
		Context = this;
	}

	if (!isArray(arrayLike)) {
		if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
			// Source: Iterator
			iterator = callable(getIterator).call(arrayLike);
			if (Context) arr = new Context();
			result = iterator.next();
			i = 0;
			while (!result.done) {
				value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, i, desc);
				} else {
					arr[i] = value;
				}
				result = iterator.next();
				++i;
			}
			length = i;
		} else if (isString(arrayLike)) {
			// Source: String
			length = arrayLike.length;
			if (Context) arr = new Context();
			for (i = 0, j = 0; i < length; ++i) {
				value = arrayLike[i];
				if (i + 1 < length) {
					code = value.charCodeAt(0);
					// eslint-disable-next-line max-depth
					if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
				}
				value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, j, desc);
				} else {
					arr[j] = value;
				}
				++j;
			}
			length = j;
		}
	}
	if (length === undefined) {
		// Source: array or array-like
		length = toPosInt(arrayLike.length);
		if (Context) arr = new Context(length);
		for (i = 0; i < length; ++i) {
			value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
			if (Context) {
				desc.value = value;
				defineProperty(arr, i, desc);
			} else {
				arr[i] = value;
			}
		}
	}
	if (Context) {
		desc.value = null;
		arr.length = length;
	}
	return arr;
};


/***/ }),

/***/ "./node_modules/es5-ext/function/is-arguments.js":
/*!*******************************************************!*\
  !*** ./node_modules/es5-ext/function/is-arguments.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var objToString = Object.prototype.toString
  , id = objToString.call((function () { return arguments; })());

module.exports = function (value) { return objToString.call(value) === id; };


/***/ }),

/***/ "./node_modules/es5-ext/function/is-function.js":
/*!******************************************************!*\
  !*** ./node_modules/es5-ext/function/is-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var objToString = Object.prototype.toString
  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);

module.exports = function (value) {
	return typeof value === "function" && isFunctionStringTag(objToString.call(value));
};


/***/ }),

/***/ "./node_modules/es5-ext/function/noop.js":
/*!***********************************************!*\
  !*** ./node_modules/es5-ext/function/noop.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// eslint-disable-next-line no-empty-function
module.exports = function () {};


/***/ }),

/***/ "./node_modules/es5-ext/math/sign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es5-ext/math/sign/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es5-ext/math/sign/is-implemented.js")() ? Math.sign : __webpack_require__(/*! ./shim */ "./node_modules/es5-ext/math/sign/shim.js");


/***/ }),

/***/ "./node_modules/es5-ext/math/sign/is-implemented.js":
/*!**********************************************************!*\
  !*** ./node_modules/es5-ext/math/sign/is-implemented.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== "function") return false;
	return sign(10) === 1 && sign(-20) === -1;
};


/***/ }),

/***/ "./node_modules/es5-ext/math/sign/shim.js":
/*!************************************************!*\
  !*** ./node_modules/es5-ext/math/sign/shim.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || value === 0) return value;
	return value > 0 ? 1 : -1;
};


/***/ }),

/***/ "./node_modules/es5-ext/number/to-integer.js":
/*!***************************************************!*\
  !*** ./node_modules/es5-ext/number/to-integer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var sign  = __webpack_require__(/*! ../math/sign */ "./node_modules/es5-ext/math/sign/index.js")
  , abs   = Math.abs
  , floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if (value === 0 || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};


/***/ }),

/***/ "./node_modules/es5-ext/number/to-pos-integer.js":
/*!*******************************************************!*\
  !*** ./node_modules/es5-ext/number/to-pos-integer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./to-integer */ "./node_modules/es5-ext/number/to-integer.js")
  , max       = Math.max;

module.exports = function (value) { return max(0, toInteger(value)); };


/***/ }),

/***/ "./node_modules/es5-ext/object/_iterate.js":
/*!*************************************************!*\
  !*** ./node_modules/es5-ext/object/_iterate.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order



var callable                = __webpack_require__(/*! ./valid-callable */ "./node_modules/es5-ext/object/valid-callable.js")
  , value                   = __webpack_require__(/*! ./valid-value */ "./node_modules/es5-ext/object/valid-value.js")
  , bind                    = Function.prototype.bind
  , call                    = Function.prototype.call
  , keys                    = Object.keys
  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== "function") method = list[method];
		return call.call(method, list, function (key, index) {
			if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};


/***/ }),

/***/ "./node_modules/es5-ext/object/assign/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/es5-ext/object/assign/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es5-ext/object/assign/is-implemented.js")() ? Object.assign : __webpack_require__(/*! ./shim */ "./node_modules/es5-ext/object/assign/shim.js");


/***/ }),

/***/ "./node_modules/es5-ext/object/assign/is-implemented.js":
/*!**************************************************************!*\
  !*** ./node_modules/es5-ext/object/assign/is-implemented.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== "function") return false;
	obj = { foo: "raz" };
	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
	return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
};


/***/ }),

/***/ "./node_modules/es5-ext/object/assign/shim.js":
/*!****************************************************!*\
  !*** ./node_modules/es5-ext/object/assign/shim.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys  = __webpack_require__(/*! ../keys */ "./node_modules/es5-ext/object/keys/index.js")
  , value = __webpack_require__(/*! ../valid-value */ "./node_modules/es5-ext/object/valid-value.js")
  , max   = Math.max;

module.exports = function (dest, src/*, …srcn*/) {
	var error, i, length = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try {
			dest[key] = src[key];
		} catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < length; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};


/***/ }),

/***/ "./node_modules/es5-ext/object/copy.js":
/*!*********************************************!*\
  !*** ./node_modules/es5-ext/object/copy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFrom  = __webpack_require__(/*! ../array/from */ "./node_modules/es5-ext/array/from/index.js")
  , assign = __webpack_require__(/*! ./assign */ "./node_modules/es5-ext/object/assign/index.js")
  , value  = __webpack_require__(/*! ./valid-value */ "./node_modules/es5-ext/object/valid-value.js");

module.exports = function (obj/*, propertyNames, options*/) {
	var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
	if (copy !== obj && !propertyNames) return copy;
	var result = {};
	if (propertyNames) {
		aFrom(propertyNames, function (propertyName) {
			if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
		});
	} else {
		assign(result, obj);
	}
	return result;
};


/***/ }),

/***/ "./node_modules/es5-ext/object/create.js":
/*!***********************************************!*\
  !*** ./node_modules/es5-ext/object/create.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804



var create = Object.create, shim;

if (!__webpack_require__(/*! ./set-prototype-of/is-implemented */ "./node_modules/es5-ext/object/set-prototype-of/is-implemented.js")()) {
	shim = __webpack_require__(/*! ./set-prototype-of/shim */ "./node_modules/es5-ext/object/set-prototype-of/shim.js");
}

module.exports = (function () {
	var nullObject, polyProps, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	polyProps = {};
	desc = { configurable: false, enumerable: false, writable: true, value: undefined };
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === "__proto__") {
			polyProps[name] = {
				configurable: true,
				enumerable: false,
				writable: true,
				value: undefined
			};
			return;
		}
		polyProps[name] = desc;
	});
	Object.defineProperties(nullObject, polyProps);

	Object.defineProperty(shim, "nullPolyfill", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: nullObject
	});

	return function (prototype, props) {
		return create(prototype === null ? nullObject : prototype, props);
	};
})();


/***/ }),

/***/ "./node_modules/es5-ext/object/for-each.js":
/*!*************************************************!*\
  !*** ./node_modules/es5-ext/object/for-each.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./_iterate */ "./node_modules/es5-ext/object/_iterate.js")("forEach");


/***/ }),

/***/ "./node_modules/es5-ext/object/is-object.js":
/*!**************************************************!*\
  !*** ./node_modules/es5-ext/object/is-object.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(/*! ./is-value */ "./node_modules/es5-ext/object/is-value.js");

var map = { function: true, object: true };

module.exports = function (value) { return (isValue(value) && map[typeof value]) || false; };


/***/ }),

/***/ "./node_modules/es5-ext/object/is-value.js":
/*!*************************************************!*\
  !*** ./node_modules/es5-ext/object/is-value.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _undefined = __webpack_require__(/*! ../function/noop */ "./node_modules/es5-ext/function/noop.js")(); // Support ES3 engines

module.exports = function (val) { return val !== _undefined && val !== null; };


/***/ }),

/***/ "./node_modules/es5-ext/object/keys/index.js":
/*!***************************************************!*\
  !*** ./node_modules/es5-ext/object/keys/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es5-ext/object/keys/is-implemented.js")() ? Object.keys : __webpack_require__(/*! ./shim */ "./node_modules/es5-ext/object/keys/shim.js");


/***/ }),

/***/ "./node_modules/es5-ext/object/keys/is-implemented.js":
/*!************************************************************!*\
  !*** ./node_modules/es5-ext/object/keys/is-implemented.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	try {
		Object.keys("primitive");
		return true;
	} catch (e) {
		return false;
	}
};


/***/ }),

/***/ "./node_modules/es5-ext/object/keys/shim.js":
/*!**************************************************!*\
  !*** ./node_modules/es5-ext/object/keys/shim.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(/*! ../is-value */ "./node_modules/es5-ext/object/is-value.js");

var keys = Object.keys;

module.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };


/***/ }),

/***/ "./node_modules/es5-ext/object/map.js":
/*!********************************************!*\
  !*** ./node_modules/es5-ext/object/map.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var callable = __webpack_require__(/*! ./valid-callable */ "./node_modules/es5-ext/object/valid-callable.js")
  , forEach  = __webpack_require__(/*! ./for-each */ "./node_modules/es5-ext/object/for-each.js")
  , call     = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var result = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, targetObj, index) {
		result[key] = call.call(cb, thisArg, value, key, targetObj, index);
	});
	return result;
};


/***/ }),

/***/ "./node_modules/es5-ext/object/normalize-options.js":
/*!**********************************************************!*\
  !*** ./node_modules/es5-ext/object/normalize-options.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(/*! ./is-value */ "./node_modules/es5-ext/object/is-value.js");

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

// eslint-disable-next-line no-unused-vars
module.exports = function (opts1/*, …options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (!isValue(options)) return;
		process(Object(options), result);
	});
	return result;
};


/***/ }),

/***/ "./node_modules/es5-ext/object/set-prototype-of/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/es5-ext/object/set-prototype-of/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es5-ext/object/set-prototype-of/is-implemented.js")() ? Object.setPrototypeOf : __webpack_require__(/*! ./shim */ "./node_modules/es5-ext/object/set-prototype-of/shim.js");


/***/ }),

/***/ "./node_modules/es5-ext/object/set-prototype-of/is-implemented.js":
/*!************************************************************************!*\
  !*** ./node_modules/es5-ext/object/set-prototype-of/is-implemented.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};

module.exports = function (/* CustomCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== "function") return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
};


/***/ }),

/***/ "./node_modules/es5-ext/object/set-prototype-of/shim.js":
/*!**************************************************************!*\
  !*** ./node_modules/es5-ext/object/set-prototype-of/shim.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint no-proto: "off" */

// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554



var isObject         = __webpack_require__(/*! ../is-object */ "./node_modules/es5-ext/object/is-object.js")
  , value            = __webpack_require__(/*! ../valid-value */ "./node_modules/es5-ext/object/valid-value.js")
  , objIsPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty   = Object.defineProperty
  , nullDesc         = { configurable: true, enumerable: false, writable: true, value: undefined }
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if (prototype === null || isObject(prototype)) return obj;
	throw new TypeError("Prototype must be null or an object");
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, "__proto__", nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, "level", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: status.level
	});
})(
	(function () {
		var tmpObj1 = Object.create(null)
		  , tmpObj2 = {}
		  , set
		  , desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");

		if (desc) {
			try {
				set = desc.set; // Opera crashes at this point
				set.call(tmpObj1, tmpObj2);
			} catch (ignore) {}
			if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };
		}

		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };

		tmpObj1 = {};
		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };

		return false;
	})()
);

__webpack_require__(/*! ../create */ "./node_modules/es5-ext/object/create.js");


/***/ }),

/***/ "./node_modules/es5-ext/object/valid-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/es5-ext/object/valid-callable.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
	return fn;
};


/***/ }),

/***/ "./node_modules/es5-ext/object/valid-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/es5-ext/object/valid-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./is-object */ "./node_modules/es5-ext/object/is-object.js");

module.exports = function (value) {
	if (!isObject(value)) throw new TypeError(value + " is not an Object");
	return value;
};


/***/ }),

/***/ "./node_modules/es5-ext/object/valid-value.js":
/*!****************************************************!*\
  !*** ./node_modules/es5-ext/object/valid-value.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(/*! ./is-value */ "./node_modules/es5-ext/object/is-value.js");

module.exports = function (value) {
	if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
	return value;
};


/***/ }),

/***/ "./node_modules/es5-ext/string/#/contains/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/es5-ext/string/#/contains/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es5-ext/string/#/contains/is-implemented.js")() ? String.prototype.contains : __webpack_require__(/*! ./shim */ "./node_modules/es5-ext/string/#/contains/shim.js");


/***/ }),

/***/ "./node_modules/es5-ext/string/#/contains/is-implemented.js":
/*!******************************************************************!*\
  !*** ./node_modules/es5-ext/string/#/contains/is-implemented.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var str = "razdwatrzy";

module.exports = function () {
	if (typeof str.contains !== "function") return false;
	return str.contains("dwa") === true && str.contains("foo") === false;
};


/***/ }),

/***/ "./node_modules/es5-ext/string/#/contains/shim.js":
/*!********************************************************!*\
  !*** ./node_modules/es5-ext/string/#/contains/shim.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};


/***/ }),

/***/ "./node_modules/es5-ext/string/is-string.js":
/*!**************************************************!*\
  !*** ./node_modules/es5-ext/string/is-string.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var objToString = Object.prototype.toString, id = objToString.call("");

module.exports = function (value) {
	return (
		typeof value === "string" ||
		(value &&
			typeof value === "object" &&
			(value instanceof String || objToString.call(value) === id)) ||
		false
	);
};


/***/ }),

/***/ "./node_modules/es5-ext/string/random-uniq.js":
/*!****************************************************!*\
  !*** ./node_modules/es5-ext/string/random-uniq.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generated = Object.create(null), random = Math.random;

module.exports = function () {
	var str;
	do {
		str = random().toString(36).slice(2);
	} while (generated[str]);
	return str;
};


/***/ }),

/***/ "./node_modules/es6-iterator/array.js":
/*!********************************************!*\
  !*** ./node_modules/es6-iterator/array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(/*! es5-ext/object/set-prototype-of */ "./node_modules/es5-ext/object/set-prototype-of/index.js")
  , contains       = __webpack_require__(/*! es5-ext/string/#/contains */ "./node_modules/es5-ext/string/#/contains/index.js")
  , d              = __webpack_require__(/*! d */ "./node_modules/d/index.js")
  , Symbol         = __webpack_require__(/*! es6-symbol */ "./node_modules/es6-symbol/index.js")
  , Iterator       = __webpack_require__(/*! ./ */ "./node_modules/es6-iterator/index.js");

var defineProperty = Object.defineProperty, ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) throw new TypeError("Constructor requires 'new'");
	Iterator.call(this, arr);
	if (!kind) kind = "value";
	else if (contains.call(kind, "key+value")) kind = "key+value";
	else if (contains.call(kind, "key")) kind = "key";
	else kind = "value";
	defineProperty(this, "__kind__", d("", kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

// Internal %ArrayIteratorPrototype% doesn't expose its constructor
delete ArrayIterator.prototype.constructor;

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	_resolve: d(function (i) {
		if (this.__kind__ === "value") return this.__list__[i];
		if (this.__kind__ === "key+value") return [i, this.__list__[i]];
		return i;
	})
});
defineProperty(ArrayIterator.prototype, Symbol.toStringTag, d("c", "Array Iterator"));


/***/ }),

/***/ "./node_modules/es6-iterator/for-of.js":
/*!*********************************************!*\
  !*** ./node_modules/es6-iterator/for-of.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(/*! es5-ext/function/is-arguments */ "./node_modules/es5-ext/function/is-arguments.js")
  , callable    = __webpack_require__(/*! es5-ext/object/valid-callable */ "./node_modules/es5-ext/object/valid-callable.js")
  , isString    = __webpack_require__(/*! es5-ext/string/is-string */ "./node_modules/es5-ext/string/is-string.js")
  , get         = __webpack_require__(/*! ./get */ "./node_modules/es6-iterator/get.js");

var isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;

module.exports = function (iterable, cb /*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = "array";
	else if (isString(iterable)) mode = "string";
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () {
		broken = true;
	};
	if (mode === "array") {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			return broken;
		});
		return;
	}
	if (mode === "string") {
		length = iterable.length;
		for (i = 0; i < length; ++i) {
			char = iterable[i];
			if (i + 1 < length) {
				code = char.charCodeAt(0);
				if (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};


/***/ }),

/***/ "./node_modules/es6-iterator/get.js":
/*!******************************************!*\
  !*** ./node_modules/es6-iterator/get.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(/*! es5-ext/function/is-arguments */ "./node_modules/es5-ext/function/is-arguments.js")
  , isString       = __webpack_require__(/*! es5-ext/string/is-string */ "./node_modules/es5-ext/string/is-string.js")
  , ArrayIterator  = __webpack_require__(/*! ./array */ "./node_modules/es6-iterator/array.js")
  , StringIterator = __webpack_require__(/*! ./string */ "./node_modules/es6-iterator/string.js")
  , iterable       = __webpack_require__(/*! ./valid-iterable */ "./node_modules/es6-iterator/valid-iterable.js")
  , iteratorSymbol = __webpack_require__(/*! es6-symbol */ "./node_modules/es6-symbol/index.js").iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};


/***/ }),

/***/ "./node_modules/es6-iterator/index.js":
/*!********************************************!*\
  !*** ./node_modules/es6-iterator/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var clear    = __webpack_require__(/*! es5-ext/array/#/clear */ "./node_modules/es5-ext/array/#/clear.js")
  , assign   = __webpack_require__(/*! es5-ext/object/assign */ "./node_modules/es5-ext/object/assign/index.js")
  , callable = __webpack_require__(/*! es5-ext/object/valid-callable */ "./node_modules/es5-ext/object/valid-callable.js")
  , value    = __webpack_require__(/*! es5-ext/object/valid-value */ "./node_modules/es5-ext/object/valid-value.js")
  , d        = __webpack_require__(/*! d */ "./node_modules/d/index.js")
  , autoBind = __webpack_require__(/*! d/auto-bind */ "./node_modules/d/auto-bind.js")
  , Symbol   = __webpack_require__(/*! es6-symbol */ "./node_modules/es6-symbol/index.js");

var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) throw new TypeError("Constructor requires 'new'");
	defineProperties(this, {
		__list__: d("w", value(list)),
		__context__: d("w", context),
		__nextIndex__: d("w", 0)
	});
	if (!context) return;
	callable(context.on);
	context.on("_add", this._onAdd);
	context.on("_delete", this._onDelete);
	context.on("_clear", this._onClear);
};

// Internal %IteratorPrototype% doesn't expose its constructor
delete Iterator.prototype.constructor;

defineProperties(
	Iterator.prototype,
	assign(
		{
			_next: d(function () {
				var i;
				if (!this.__list__) return undefined;
				if (this.__redo__) {
					i = this.__redo__.shift();
					if (i !== undefined) return i;
				}
				if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
				this._unBind();
				return undefined;
			}),
			next: d(function () {
				return this._createResult(this._next());
			}),
			_createResult: d(function (i) {
				if (i === undefined) return { done: true, value: undefined };
				return { done: false, value: this._resolve(i) };
			}),
			_resolve: d(function (i) {
				return this.__list__[i];
			}),
			_unBind: d(function () {
				this.__list__ = null;
				delete this.__redo__;
				if (!this.__context__) return;
				this.__context__.off("_add", this._onAdd);
				this.__context__.off("_delete", this._onDelete);
				this.__context__.off("_clear", this._onClear);
				this.__context__ = null;
			}),
			toString: d(function () {
				return "[object " + (this[Symbol.toStringTag] || "Object") + "]";
			})
		},
		autoBind({
			_onAdd: d(function (index) {
				if (index >= this.__nextIndex__) return;
				++this.__nextIndex__;
				if (!this.__redo__) {
					defineProperty(this, "__redo__", d("c", [index]));
					return;
				}
				this.__redo__.forEach(function (redo, i) {
					if (redo >= index) this.__redo__[i] = ++redo;
				}, this);
				this.__redo__.push(index);
			}),
			_onDelete: d(function (index) {
				var i;
				if (index >= this.__nextIndex__) return;
				--this.__nextIndex__;
				if (!this.__redo__) return;
				i = this.__redo__.indexOf(index);
				if (i !== -1) this.__redo__.splice(i, 1);
				this.__redo__.forEach(function (redo, j) {
					if (redo > index) this.__redo__[j] = --redo;
				}, this);
			}),
			_onClear: d(function () {
				if (this.__redo__) clear.call(this.__redo__);
				this.__nextIndex__ = 0;
			})
		})
	)
);

defineProperty(
	Iterator.prototype,
	Symbol.iterator,
	d(function () {
		return this;
	})
);


/***/ }),

/***/ "./node_modules/es6-iterator/is-iterable.js":
/*!**************************************************!*\
  !*** ./node_modules/es6-iterator/is-iterable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(/*! es5-ext/function/is-arguments */ "./node_modules/es5-ext/function/is-arguments.js")
  , isValue     = __webpack_require__(/*! es5-ext/object/is-value */ "./node_modules/es5-ext/object/is-value.js")
  , isString    = __webpack_require__(/*! es5-ext/string/is-string */ "./node_modules/es5-ext/string/is-string.js");

var iteratorSymbol = __webpack_require__(/*! es6-symbol */ "./node_modules/es6-symbol/index.js").iterator
  , isArray        = Array.isArray;

module.exports = function (value) {
	if (!isValue(value)) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return typeof value[iteratorSymbol] === "function";
};


/***/ }),

/***/ "./node_modules/es6-iterator/string.js":
/*!*********************************************!*\
  !*** ./node_modules/es6-iterator/string.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols



var setPrototypeOf = __webpack_require__(/*! es5-ext/object/set-prototype-of */ "./node_modules/es5-ext/object/set-prototype-of/index.js")
  , d              = __webpack_require__(/*! d */ "./node_modules/d/index.js")
  , Symbol         = __webpack_require__(/*! es6-symbol */ "./node_modules/es6-symbol/index.js")
  , Iterator       = __webpack_require__(/*! ./ */ "./node_modules/es6-iterator/index.js");

var defineProperty = Object.defineProperty, StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, "__length__", d("", str.length));
};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

// Internal %ArrayIteratorPrototype% doesn't expose its constructor
delete StringIterator.prototype.constructor;

StringIterator.prototype = Object.create(Iterator.prototype, {
	_next: d(function () {
		if (!this.__list__) return undefined;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
		return undefined;
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];
		return char;
	})
});
defineProperty(StringIterator.prototype, Symbol.toStringTag, d("c", "String Iterator"));


/***/ }),

/***/ "./node_modules/es6-iterator/valid-iterable.js":
/*!*****************************************************!*\
  !*** ./node_modules/es6-iterator/valid-iterable.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isIterable = __webpack_require__(/*! ./is-iterable */ "./node_modules/es6-iterator/is-iterable.js");

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};


/***/ }),

/***/ "./node_modules/es6-symbol/index.js":
/*!******************************************!*\
  !*** ./node_modules/es6-symbol/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es6-symbol/is-implemented.js")()
	? __webpack_require__(/*! ext/global-this */ "./node_modules/ext/global-this/index.js").Symbol
	: __webpack_require__(/*! ./polyfill */ "./node_modules/es6-symbol/polyfill.js");


/***/ }),

/***/ "./node_modules/es6-symbol/is-implemented.js":
/*!***************************************************!*\
  !*** ./node_modules/es6-symbol/is-implemented.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global     = __webpack_require__(/*! ext/global-this */ "./node_modules/ext/global-this/index.js")
  , validTypes = { object: true, symbol: true };

module.exports = function () {
	var Symbol = global.Symbol;
	var symbol;
	if (typeof Symbol !== "function") return false;
	symbol = Symbol("test symbol");
	try { String(symbol); }
	catch (e) { return false; }

	// Return 'true' also for polyfills
	if (!validTypes[typeof Symbol.iterator]) return false;
	if (!validTypes[typeof Symbol.toPrimitive]) return false;
	if (!validTypes[typeof Symbol.toStringTag]) return false;

	return true;
};


/***/ }),

/***/ "./node_modules/es6-symbol/is-symbol.js":
/*!**********************************************!*\
  !*** ./node_modules/es6-symbol/is-symbol.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	if (!value) return false;
	if (typeof value === "symbol") return true;
	if (!value.constructor) return false;
	if (value.constructor.name !== "Symbol") return false;
	return value[value.constructor.toStringTag] === "Symbol";
};


/***/ }),

/***/ "./node_modules/es6-symbol/lib/private/generate-name.js":
/*!**************************************************************!*\
  !*** ./node_modules/es6-symbol/lib/private/generate-name.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d = __webpack_require__(/*! d */ "./node_modules/d/index.js");

var create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;

var created = create(null);
module.exports = function (desc) {
	var postfix = 0, name, ie11BugWorkaround;
	while (created[desc + (postfix || "")]) ++postfix;
	desc += postfix || "";
	created[desc] = true;
	name = "@@" + desc;
	defineProperty(
		objPrototype,
		name,
		d.gs(null, function (value) {
			// For IE11 issue see:
			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
			//    ie11-broken-getters-on-dom-objects
			// https://github.com/medikoo/es6-symbol/issues/12
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		})
	);
	return name;
};


/***/ }),

/***/ "./node_modules/es6-symbol/lib/private/setup/standard-symbols.js":
/*!***********************************************************************!*\
  !*** ./node_modules/es6-symbol/lib/private/setup/standard-symbols.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d            = __webpack_require__(/*! d */ "./node_modules/d/index.js")
  , NativeSymbol = __webpack_require__(/*! ext/global-this */ "./node_modules/ext/global-this/index.js").Symbol;

module.exports = function (SymbolPolyfill) {
	return Object.defineProperties(SymbolPolyfill, {
		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d(
			"", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill("hasInstance")
		),
		isConcatSpreadable: d(
			"",
			(NativeSymbol && NativeSymbol.isConcatSpreadable) ||
				SymbolPolyfill("isConcatSpreadable")
		),
		iterator: d("", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill("iterator")),
		match: d("", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill("match")),
		replace: d("", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill("replace")),
		search: d("", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill("search")),
		species: d("", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill("species")),
		split: d("", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill("split")),
		toPrimitive: d(
			"", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill("toPrimitive")
		),
		toStringTag: d(
			"", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill("toStringTag")
		),
		unscopables: d(
			"", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill("unscopables")
		)
	});
};


/***/ }),

/***/ "./node_modules/es6-symbol/lib/private/setup/symbol-registry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es6-symbol/lib/private/setup/symbol-registry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d              = __webpack_require__(/*! d */ "./node_modules/d/index.js")
  , validateSymbol = __webpack_require__(/*! ../../../validate-symbol */ "./node_modules/es6-symbol/validate-symbol.js");

var registry = Object.create(null);

module.exports = function (SymbolPolyfill) {
	return Object.defineProperties(SymbolPolyfill, {
		for: d(function (key) {
			if (registry[key]) return registry[key];
			return (registry[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d(function (symbol) {
			var key;
			validateSymbol(symbol);
			for (key in registry) {
				if (registry[key] === symbol) return key;
			}
			return undefined;
		})
	});
};


/***/ }),

/***/ "./node_modules/es6-symbol/polyfill.js":
/*!*********************************************!*\
  !*** ./node_modules/es6-symbol/polyfill.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ES2015 Symbol polyfill for environments that do not (or partially) support it



var d                    = __webpack_require__(/*! d */ "./node_modules/d/index.js")
  , validateSymbol       = __webpack_require__(/*! ./validate-symbol */ "./node_modules/es6-symbol/validate-symbol.js")
  , NativeSymbol         = __webpack_require__(/*! ext/global-this */ "./node_modules/ext/global-this/index.js").Symbol
  , generateName         = __webpack_require__(/*! ./lib/private/generate-name */ "./node_modules/es6-symbol/lib/private/generate-name.js")
  , setupStandardSymbols = __webpack_require__(/*! ./lib/private/setup/standard-symbols */ "./node_modules/es6-symbol/lib/private/setup/standard-symbols.js")
  , setupSymbolRegistry  = __webpack_require__(/*! ./lib/private/setup/symbol-registry */ "./node_modules/es6-symbol/lib/private/setup/symbol-registry.js");

var create = Object.create
  , defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty;

var SymbolPolyfill, HiddenSymbol, isNativeSafe;

if (typeof NativeSymbol === "function") {
	try {
		String(NativeSymbol());
		isNativeSafe = true;
	} catch (ignore) {}
} else {
	NativeSymbol = null;
}

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
	return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError("Symbol is not a constructor");
	if (isNativeSafe) return NativeSymbol(description);
	symbol = create(HiddenSymbol.prototype);
	description = description === undefined ? "" : String(description);
	return defineProperties(symbol, {
		__description__: d("", description),
		__name__: d("", generateName(description))
	});
};

setupStandardSymbols(SymbolPolyfill);
setupSymbolRegistry(SymbolPolyfill);

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d("", function () { return this.__name__; })
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return "Symbol (" + validateSymbol(this).__description__ + ")"; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(
	SymbolPolyfill.prototype,
	SymbolPolyfill.toPrimitive,
	d("", function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === "symbol") return symbol;
		return symbol.toString();
	})
);
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(
	HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
);

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(
	HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
);


/***/ }),

/***/ "./node_modules/es6-symbol/validate-symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/es6-symbol/validate-symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(/*! ./is-symbol */ "./node_modules/es6-symbol/is-symbol.js");

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};


/***/ }),

/***/ "./node_modules/es6-weak-map/index.js":
/*!********************************************!*\
  !*** ./node_modules/es6-weak-map/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/es6-weak-map/is-implemented.js")() ? WeakMap : __webpack_require__(/*! ./polyfill */ "./node_modules/es6-weak-map/polyfill.js");


/***/ }),

/***/ "./node_modules/es6-weak-map/is-implemented.js":
/*!*****************************************************!*\
  !*** ./node_modules/es6-weak-map/is-implemented.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var weakMap, obj;

	if (typeof WeakMap !== "function") return false;
	try {
		// WebKit doesn't support arguments and crashes
		weakMap = new WeakMap([[obj = {}, "one"], [{}, "two"], [{}, "three"]]);
	} catch (e) {
		return false;
	}
	if (String(weakMap) !== "[object WeakMap]") return false;
	if (typeof weakMap.set !== "function") return false;
	if (weakMap.set({}, 1) !== weakMap) return false;
	if (typeof weakMap.delete !== "function") return false;
	if (typeof weakMap.has !== "function") return false;
	if (weakMap.get(obj) !== "one") return false;

	return true;
};


/***/ }),

/***/ "./node_modules/es6-weak-map/is-native-implemented.js":
/*!************************************************************!*\
  !*** ./node_modules/es6-weak-map/is-native-implemented.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Exports true if environment provides native `WeakMap` implementation, whatever that is.



module.exports = (function () {
	if (typeof WeakMap !== "function") return false;
	return Object.prototype.toString.call(new WeakMap()) === "[object WeakMap]";
}());


/***/ }),

/***/ "./node_modules/es6-weak-map/polyfill.js":
/*!***********************************************!*\
  !*** ./node_modules/es6-weak-map/polyfill.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue           = __webpack_require__(/*! es5-ext/object/is-value */ "./node_modules/es5-ext/object/is-value.js")
  , setPrototypeOf    = __webpack_require__(/*! es5-ext/object/set-prototype-of */ "./node_modules/es5-ext/object/set-prototype-of/index.js")
  , object            = __webpack_require__(/*! es5-ext/object/valid-object */ "./node_modules/es5-ext/object/valid-object.js")
  , ensureValue       = __webpack_require__(/*! es5-ext/object/valid-value */ "./node_modules/es5-ext/object/valid-value.js")
  , randomUniq        = __webpack_require__(/*! es5-ext/string/random-uniq */ "./node_modules/es5-ext/string/random-uniq.js")
  , d                 = __webpack_require__(/*! d */ "./node_modules/d/index.js")
  , getIterator       = __webpack_require__(/*! es6-iterator/get */ "./node_modules/es6-iterator/get.js")
  , forOf             = __webpack_require__(/*! es6-iterator/for-of */ "./node_modules/es6-iterator/for-of.js")
  , toStringTagSymbol = __webpack_require__(/*! es6-symbol */ "./node_modules/es6-symbol/index.js").toStringTag
  , isNative          = __webpack_require__(/*! ./is-native-implemented */ "./node_modules/es6-weak-map/is-native-implemented.js")

  , isArray = Array.isArray, defineProperty = Object.defineProperty
  , objHasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf
  , WeakMapPoly;

module.exports = WeakMapPoly = function (/* Iterable*/) {
	var iterable = arguments[0], self;

	if (!(this instanceof WeakMapPoly)) throw new TypeError("Constructor requires 'new'");
	self = isNative && setPrototypeOf && (WeakMap !== WeakMapPoly)
		? setPrototypeOf(new WeakMap(), getPrototypeOf(this)) : this;

	if (isValue(iterable)) {
		if (!isArray(iterable)) iterable = getIterator(iterable);
	}
	defineProperty(self, "__weakMapData__", d("c", "$weakMap$" + randomUniq()));
	if (!iterable) return self;
	forOf(iterable, function (val) {
		ensureValue(val);
		self.set(val[0], val[1]);
	});
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);
	WeakMapPoly.prototype = Object.create(WeakMap.prototype, { constructor: d(WeakMapPoly) });
}

Object.defineProperties(WeakMapPoly.prototype, {
	delete: d(function (key) {
		if (objHasOwnProperty.call(object(key), this.__weakMapData__)) {
			delete key[this.__weakMapData__];
			return true;
		}
		return false;
	}),
	get: d(function (key) {
		if (!objHasOwnProperty.call(object(key), this.__weakMapData__)) return undefined;
		return key[this.__weakMapData__];
	}),
	has: d(function (key) {
		return objHasOwnProperty.call(object(key), this.__weakMapData__);
	}),
	set: d(function (key, value) {
		defineProperty(object(key), this.__weakMapData__, d("c", value));
		return this;
	}),
	toString: d(function () {
		return "[object WeakMap]";
	})
});
defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d("c", "WeakMap"));


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ "./node_modules/ext/global-this/implementation.js":
/*!********************************************************!*\
  !*** ./node_modules/ext/global-this/implementation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

module.exports = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ is resolved with global context, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();


/***/ }),

/***/ "./node_modules/ext/global-this/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ext/global-this/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./is-implemented */ "./node_modules/ext/global-this/is-implemented.js")() ? globalThis : __webpack_require__(/*! ./implementation */ "./node_modules/ext/global-this/implementation.js");


/***/ }),

/***/ "./node_modules/ext/global-this/is-implemented.js":
/*!********************************************************!*\
  !*** ./node_modules/ext/global-this/is-implemented.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	if (typeof globalThis !== "object") return false;
	if (!globalThis) return false;
	return globalThis.Array === Array;
};


/***/ }),

/***/ "./node_modules/immediate/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/immediate/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/is-promise/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-promise/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = isPromise;
module.exports.default = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}


/***/ }),

/***/ "./node_modules/lie/lib/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/lie/lib/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var immediate = __webpack_require__(/*! immediate */ "./node_modules/immediate/lib/browser.js");

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["finally"] = function (callback) {
  if (typeof callback !== 'function') {
    return this;
  }
  var p = this.constructor;
  return this.then(resolve, reject);

  function resolve(value) {
    function yes () {
      return value;
    }
    return p.resolve(callback()).then(yes);
  }
  function reject(reason) {
    function no () {
      throw reason;
    }
    return p.resolve(callback()).then(no);
  }
};
Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}


/***/ }),

/***/ "./node_modules/microdash/index.js":
/*!*****************************************!*\
  !*** ./node_modules/microdash/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var each = __webpack_require__(/*! ./src/each */ "./node_modules/microdash/src/each.js"),
    escapeRegExp = __webpack_require__(/*! ./src/escapeRegExp */ "./node_modules/microdash/src/escapeRegExp.js"),
    extend = __webpack_require__(/*! ./src/extend */ "./node_modules/microdash/src/extend.js"),
    filter = __webpack_require__(/*! ./src/filter */ "./node_modules/microdash/src/filter.js"),
    forOwn = __webpack_require__(/*! ./src/forOwn */ "./node_modules/microdash/src/forOwn.js"),
    isArray = __webpack_require__(/*! ./src/isArray */ "./node_modules/microdash/src/isArray.js"),
    isBoolean = __webpack_require__(/*! ./src/isBoolean */ "./node_modules/microdash/src/isBoolean.js"),
    isFunction = __webpack_require__(/*! ./src/isFunction */ "./node_modules/microdash/src/isFunction.js"),
    isNumber = __webpack_require__(/*! ./src/isNumber */ "./node_modules/microdash/src/isNumber.js"),
    isPlainObject = __webpack_require__(/*! ./src/isPlainObject */ "./node_modules/microdash/src/isPlainObject.js"),
    isString = __webpack_require__(/*! ./src/isString */ "./node_modules/microdash/src/isString.js"),
    map = __webpack_require__(/*! ./src/map */ "./node_modules/microdash/src/map.js");

module.exports = {
    each: each,
    escapeRegExp: escapeRegExp,
    extend: extend(Object),
    filter: filter,
    forOwn: forOwn,
    isArray: isArray(Array),
    isBoolean: isBoolean,
    isFunction: isFunction,
    isNumber: isNumber,
    isPlainObject: isPlainObject,
    isString: isString,
    map: map(Array)
};


/***/ }),

/***/ "./node_modules/microdash/src/each.js":
/*!********************************************!*\
  !*** ./node_modules/microdash/src/each.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var hasOwn = {}.hasOwnProperty,
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/microdash/src/isArray.js")(Array);

module.exports = function (object, iterator, thisArg) {
    var key,
        length;

    if (!object) {
        return;
    }

    if (isArray(object) || hasOwn.call(object, 'length')) {
        for (key = 0, length = object.length; key < length; key++) {
            if (iterator.call(thisArg, object[key], key, object) === false) {
                break;
            }
        }

        return;
    }

    /*jshint forin: false */
    for (key in object) {
        if (hasOwn.call(object, key)) {
            if (iterator.call(thisArg, object[key], key, object) === false) {
                break;
            }
        }
    }
};


/***/ }),

/***/ "./node_modules/microdash/src/escapeRegExp.js":
/*!****************************************************!*\
  !*** ./node_modules/microdash/src/escapeRegExp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var REGEX = /[|\\{}()[\]^$+*?.]/g;

// From https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js
module.exports = function (string) {
    if (typeof string !== 'string') {
        throw new TypeError('Expected a string');
    }

    return string.replace(REGEX,  '\\$&');
};


/***/ }),

/***/ "./node_modules/microdash/src/extend.js":
/*!**********************************************!*\
  !*** ./node_modules/microdash/src/extend.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var each = __webpack_require__(/*! ./each */ "./node_modules/microdash/src/each.js"),
    forOwn = __webpack_require__(/*! ./forOwn */ "./node_modules/microdash/src/forOwn.js");

module.exports = function (Object) {
    return Object.assign || function (object) {
        var sources = [].slice.call(arguments, 1);

        each(sources, function (source) {
            forOwn(source, function (value, key) {
                object[key] = value;
            });
        });

        return object;
    };
};


/***/ }),

/***/ "./node_modules/microdash/src/filter.js":
/*!**********************************************!*\
  !*** ./node_modules/microdash/src/filter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var each = __webpack_require__(/*! ./each */ "./node_modules/microdash/src/each.js");

module.exports = function (collection, iteratee, thisArg) {
    var result = [];

    each(collection, function (value, key) {
        if (iteratee.call(thisArg, value, key, collection)) {
            result.push(value);
        }
    });

    return result;
};


/***/ }),

/***/ "./node_modules/microdash/src/forOwn.js":
/*!**********************************************!*\
  !*** ./node_modules/microdash/src/forOwn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var hasOwn = {}.hasOwnProperty;

module.exports = function (object, iterator, thisArg) {
    var key;

    /*jshint forin: false */
    for (key in object) {
        if (hasOwn.call(object, key)) {
            if (iterator.call(thisArg, object[key], key, object) === false) {
                break;
            }
        }
    }
};


/***/ }),

/***/ "./node_modules/microdash/src/getType.js":
/*!***********************************************!*\
  !*** ./node_modules/microdash/src/getType.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var REGEX = /\[object ([^\]]+)\]/;

module.exports = function (object) {
    return {}.toString.call(object).match(REGEX)[1];
};


/***/ }),

/***/ "./node_modules/microdash/src/isArray.js":
/*!***********************************************!*\
  !*** ./node_modules/microdash/src/isArray.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var getType = __webpack_require__(/*! ./getType */ "./node_modules/microdash/src/getType.js");

module.exports = function (Array) {
    return Array.isArray || function (object) {
        return getType(object) === 'Array';
    };
};


/***/ }),

/***/ "./node_modules/microdash/src/isBoolean.js":
/*!*************************************************!*\
  !*** ./node_modules/microdash/src/isBoolean.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



module.exports = function (object) {
    return typeof object === 'boolean';
};


/***/ }),

/***/ "./node_modules/microdash/src/isFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/microdash/src/isFunction.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



module.exports = function (object) {
    return typeof object === 'function';
};


/***/ }),

/***/ "./node_modules/microdash/src/isNumber.js":
/*!************************************************!*\
  !*** ./node_modules/microdash/src/isNumber.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



module.exports = function (object) {
    return typeof object === 'number';
};


/***/ }),

/***/ "./node_modules/microdash/src/isPlainObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/microdash/src/isPlainObject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var getType = __webpack_require__(/*! ./getType */ "./node_modules/microdash/src/getType.js");

module.exports = function (object) {
    return getType(object) === 'Object';
};


/***/ }),

/***/ "./node_modules/microdash/src/isString.js":
/*!************************************************!*\
  !*** ./node_modules/microdash/src/isString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



module.exports = function (object) {
    return typeof object === 'string';
};


/***/ }),

/***/ "./node_modules/microdash/src/map.js":
/*!*******************************************!*\
  !*** ./node_modules/microdash/src/map.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Microdash - Tiny utilities for Node and the browser
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/microdash
 *
 * Released under the MIT license
 * https://github.com/asmblah/microdash/raw/master/MIT-LICENSE.txt
 */



var each = __webpack_require__(/*! ./each */ "./node_modules/microdash/src/each.js"),
    map = Array.prototype.map;

/**
 * Faster implementation using native Array.map(...) where supported
 *
 * @param {Array} collection
 * @param {Function} iteratee
 * @param {*} thisArg
 * @return {Array}
 */
function fasterMap(collection, iteratee, thisArg) {
    return collection !== null && typeof collection !== 'undefined' ?
        map.call(collection, iteratee.bind(thisArg)) :
        [];
}

/**
 * Manual implementation where Array.map(...) is not supported
 *
 * @param {Array} collection
 * @param {Function} iteratee
 * @param {*} thisArg
 * @return {Array}
 */
function slowerMap(collection, iteratee, thisArg) {
    var result = [];

    each(collection, function (value, key) {
        result[key] = iteratee.call(thisArg, value, key, collection);
    });

    return result;
}

module.exports = function (Array) {
    return Array.prototype.map ? fasterMap : slowerMap;
};


/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pauser/index.js":
/*!**************************************!*\
  !*** ./node_modules/pauser/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Pauser - Wrapper for optional Pausable usage
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/pauser/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pauser/raw/master/MIT-LICENSE.txt
 */



var Wrapper = __webpack_require__(/*! ./src/Wrapper */ "./node_modules/pauser/src/Wrapper.js");

module.exports = function (args, wrapper, options) {
    return new Wrapper(args, wrapper, options);
};


/***/ }),

/***/ "./node_modules/pauser/src/Wrapper.js":
/*!********************************************!*\
  !*** ./node_modules/pauser/src/Wrapper.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Pauser - Wrapper for optional Pausable usage
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/pauser/
 *
 * Released under the MIT license
 * https://github.com/asmblah/pauser/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

function Wrapper(args, fn, options) {
    this.args = args;
    this.evaluatedAsync = false;
    this.evaluatedSync = false;
    this.asyncReturnValue = null;
    this.fn = fn;
    this.options = options;
    this.syncReturnValue = null;
}

_.extend(Wrapper.prototype, {
    /**
     * Executes wrapper asynchronously via the Pausable library.
     *
     * @param {Pausable} pausable
     * @returns {*}
     */
    async: function (pausable) {
        var args,
            wrapper = this;

        if (wrapper.evaluatedAsync) {
            return wrapper.asyncReturnValue;
        }

        // Recursively transpile any arguments to the function that are themselves Wrappers
        args = _.map(wrapper.args, function (arg) {
            if (arg instanceof Wrapper) {
                return arg.async(pausable);
            }

            return arg;
        });

        wrapper.asyncReturnValue = pausable.executeSync(args, wrapper.fn, wrapper.options);
        wrapper.evaluatedAsync = true;

        return wrapper.asyncReturnValue;
    },

    /**
     * Executes wrapper synchronously when the Pausable library is not available.
     *
     * @returns {*}
     */
    sync: function () {
        var args,
            wrapper = this;

        if (wrapper.evaluatedSync) {
            return wrapper.syncReturnValue;
        }

        // Recursively evaluate any arguments to the function that are themselves Wrappers
        args = _.map(wrapper.args, function (arg) {
            if (arg instanceof Wrapper) {
                return arg.sync();
            }

            return arg;
        });

        wrapper.syncReturnValue = wrapper.fn.apply(null, args);
        wrapper.evaluatedSync = true;

        return wrapper.syncReturnValue;
    }
});

module.exports = Wrapper;


/***/ }),

/***/ "./node_modules/phpcommon/index.js":
/*!*****************************************!*\
  !*** ./node_modules/phpcommon/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */



var Exception = __webpack_require__(/*! ./src/Error/Exception */ "./node_modules/phpcommon/src/Error/Exception.js"),
    PHPError = __webpack_require__(/*! ./src/Error/PHPError */ "./node_modules/phpcommon/src/Error/PHPError.js"),
    PHPFatalError = __webpack_require__(/*! ./src/Error/PHPFatalError */ "./node_modules/phpcommon/src/Error/PHPFatalError.js"),
    PHPParseError = __webpack_require__(/*! ./src/Error/PHPParseError */ "./node_modules/phpcommon/src/Error/PHPParseError.js"),
    Translator = __webpack_require__(/*! ./src/Translator */ "./node_modules/phpcommon/src/Translator.js");

module.exports = {
    Exception: Exception,
    PHPError: PHPError,
    PHPFatalError: PHPFatalError,
    PHPParseError: PHPParseError,
    Translator: Translator
};


/***/ }),

/***/ "./node_modules/phpcommon/src/Error/Exception.js":
/*!*******************************************************!*\
  !*** ./node_modules/phpcommon/src/Error/Exception.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

function Exception(message) {
    this.message = message;
}

util.inherits(Exception, Error);

_.extend(Exception.prototype, {
    'type': 'Exception'
});

module.exports = Exception;


/***/ }),

/***/ "./node_modules/phpcommon/src/Error/PHPError.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcommon/src/Error/PHPError.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Exception = __webpack_require__(/*! ./Exception */ "./node_modules/phpcommon/src/Error/Exception.js");

/**
 * Represents any kind of PHP error (warning, notice, parse, fatal)
 *
 * @param {string} level
 * @param {string} message
 * @param {string|null=} filePath
 * @param {number|null=} lineNumber
 * @constructor
 */
function PHPError(level, message, filePath, lineNumber) {
    // Form a readable string for the error, for when the library is used outside PHPCore
    // (as inside PHPCore, these errors will be intercepted and inspected using the getter methods below)
    Exception.call(
        this,
        'PHP ' + level + ': ' + message + ' in ' + (filePath || '(unknown)') + ' on line ' + (lineNumber || '(unknown)')
    );

    /**
     * @type {string|null} Path to the file the error occurred in
     */
    this.filePath = filePath;
    /**
     * @type {string}
     */
    this.level = level;
    /**
     * @type {number|null} Which line the error occurred on, if known
     */
    this.lineNumber = lineNumber;
    /**
     * @type {string} Original message without level prefix
     */
    this.originalMessage = message;
}

util.inherits(PHPError, Exception);

_.extend(PHPError, {
    E_DEPRECATED: 'Deprecated',
    E_ERROR: 'Fatal error',
    E_NOTICE: 'Notice',
    E_PARSE: 'Parse error',
    E_STRICT: 'Strict standards',
    E_WARNING: 'Warning'
});

_.extend(PHPError.prototype, {
    /**
     * Fetches the PHP module file the error occurred in if known, otherwise returns null
     *
     * @return {string|null}
     */
    getFilePath: function () {
        return this.filePath;
    },

    /**
     * Fetches the level of the error (E_DEPRECATED, E_WARNING etc.)
     *
     * @return {string}
     */
    getLevel: function () {
        return this.level;
    },

    /**
     * Fetches the line the error occurred on if known, otherwise returns null
     *
     * @return {number|null}
     */
    getLineNumber: function () {
        return this.lineNumber;
    },

    /**
     * Fetches the message for the error, without the level prefix
     *
     * @return {string}
     */
    getMessage: function () {
        return this.originalMessage;
    }
});

module.exports = PHPError;


/***/ }),

/***/ "./node_modules/phpcommon/src/Error/PHPFatalError.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcommon/src/Error/PHPFatalError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */



var util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    PHPError = __webpack_require__(/*! ./PHPError */ "./node_modules/phpcommon/src/Error/PHPError.js");

/**
 * Represents a fatal PHP error
 *
 * @param {string} message
 * @param {string|null} filePath
 * @param {number|null} lineNumber
 * @constructor
 */
function PHPFatalError(message, filePath, lineNumber) {
    PHPError.call(this, PHPError.E_ERROR, message, filePath, lineNumber);
}

util.inherits(PHPFatalError, PHPError);

module.exports = PHPFatalError;


/***/ }),

/***/ "./node_modules/phpcommon/src/Error/PHPParseError.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcommon/src/Error/PHPParseError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */



var util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    PHPError = __webpack_require__(/*! ./PHPError */ "./node_modules/phpcommon/src/Error/PHPError.js");

/**
 * Represents a PHP parse error
 *
 * @param {string} message
 * @param {string|null} filePath
 * @param {number|null} lineNumber
 * @constructor
 */
function PHPParseError(message, filePath, lineNumber) {
    PHPError.call(this, PHPError.E_PARSE, message, filePath, lineNumber);
}

util.inherits(PHPParseError, PHPError);

module.exports = PHPParseError;


/***/ }),

/***/ "./node_modules/phpcommon/src/Translator.js":
/*!**************************************************!*\
  !*** ./node_modules/phpcommon/src/Translator.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCommon - Common tools for PHP environments
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcommon/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcommon/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    DEFAULT_LOCALE = 'en_GB',
    hasOwn = {}.hasOwnProperty,
    templateString = __webpack_require__(/*! template-string */ "./node_modules/template-string/index.js");

/**
 * Stores translations for internal strings in different locales
 *
 * @constructor
 */
function Translator() {
    /**
     * @type {Object.<string, Object.<string, string>>}
     */
    this.cataloguesByLocale = {};
    /**
     * @type {string}
     */
    this.currentLocale = DEFAULT_LOCALE;
}

_.extend(Translator.prototype, {
    /**
     * Adds a translation for a specific key within a given locale
     *
     * @param {string} locale e.g. en_GB
     * @param {string} key e.g. error.my_error.my_sub_msg
     * @param {string} translation
     */
    addTranslation: function (locale, key, translation) {
        var translator = this;

        if (!hasOwn.call(translator.cataloguesByLocale, locale)) {
            translator.cataloguesByLocale[locale] = {};
        }

        this.cataloguesByLocale[locale][key] = translation;
    },

    /**
     * Adds multiple translations, potentially across multiple locales' catalogues
     *
     * @param {Object.<string, object>} structure
     */
    addTranslations: function (structure) {
        var translator = this;

        function add(locale, keyParts, data) {
            if (_.isPlainObject(data)) {
                _.forOwn(data, function (data, keyPart) {
                    add(locale, keyParts.concat([keyPart]), data);
                });
            } else {
                translator.addTranslation(locale, keyParts.join('.'), data);
            }
        }

        _.forOwn(structure, function (data, locale) {
            add(locale, [], data);
        });
    },

    /**
     * Selects which catalogue of messages should be used for translation by locale
     *
     * @param {string} locale
     */
    setLocale: function (locale) {
        this.currentLocale = locale;
    },

    /**
     * Translates the given key for the current locale (falling back to the default locale if not defined)
     * and fills in any placeholders with the given variables
     *
     * @param {string} key
     * @param {Object.<string, string>=} placeholderVariables
     * @returns {string}
     * @throws {Error} When the translation is not defined for the current nor fallback locales
     */
    translate: function (key, placeholderVariables) {
        var translation,
            translator = this;

        if (hasOwn.call(translator.cataloguesByLocale, translator.currentLocale) &&
            hasOwn.call(translator.cataloguesByLocale[translator.currentLocale], key)
        ) {
            // The translation is defined for the current locale - use it
            translation = translator.cataloguesByLocale[translator.currentLocale][key];
        } else {
            // Fall back to the default locale's catalogue

            if (!hasOwn.call(translator.cataloguesByLocale[DEFAULT_LOCALE], key)) {
                throw new Error(
                    'Translation "' + key + '" is not defined for current locale "' + translator.currentLocale +
                    '" nor the default locale "' + DEFAULT_LOCALE + '"'
                );
            }

            translation = translator.cataloguesByLocale[DEFAULT_LOCALE][key];
        }

        return templateString(translation, placeholderVariables);
    }
});

module.exports = Translator;


/***/ }),

/***/ "./node_modules/phpconfig/dist sync recursive":
/*!******************************************!*\
  !*** ./node_modules/phpconfig/dist sync ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/phpconfig/dist sync recursive";

/***/ }),

/***/ "./node_modules/phpconfig/dist/Config.js":
/*!***********************************************!*\
  !*** ./node_modules/phpconfig/dist/Config.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isEmpty(subConfig) {
    return Object.keys(subConfig).length === 0;
}
/**
 * @inheritDoc
 */
var Config = /** @class */ (function () {
    function Config(requirer, exporter, rootConfig, ConfigSetClass) {
        this.requirer = requirer;
        this.exporter = exporter;
        this.rootConfig = rootConfig;
        this.ConfigSetClass = ConfigSetClass;
    }
    /**
     * @inheritDoc
     */
    Config.prototype.exportLibrary = function (mainLibraryName, subLibraryName) {
        return this.exporter.exportLibrary(this.rootConfig, mainLibraryName, subLibraryName);
    };
    /**
     * @inheritDoc
     */
    Config.prototype.getConfigsForLibrary = function (mainLibraryName, subLibraryName) {
        var _this = this;
        var libraryConfig = this.exporter.exportLibrary(this.rootConfig, mainLibraryName, subLibraryName);
        var configs = libraryConfig.pluginConfigFilePaths.map(function (path) {
            var _a;
            var pluginConfig = (_a = _this.requirer.require(path)) !== null && _a !== void 0 ? _a : {};
            if (typeof pluginConfig !== 'object') {
                throw new Error(subLibraryName
                    ? "Imported config for sub-library \"" + subLibraryName + "\" under main library \"" + mainLibraryName + "\" should be an object"
                    : "Imported config for main library \"" + mainLibraryName + "\" should be an object");
            }
            return pluginConfig;
        });
        if (!isEmpty(libraryConfig.topLevelConfig)) {
            configs.push(libraryConfig.topLevelConfig);
        }
        return new this.ConfigSetClass(configs);
    };
    return Config;
}());
exports.default = Config;
//# sourceMappingURL=Config.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/ConfigExporter.js":
/*!*******************************************************!*\
  !*** ./node_modules/phpconfig/dist/ConfigExporter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
var hasOwn = {}.hasOwnProperty;
/**
 * Fetches the config for the given library from the root config
 *
 * @param {RootConfig} allConfig
 * @param {string} mainLibraryName
 * @param {string=} subLibraryName
 * @returns {SubConfig}
 */
function getLibraryConfigFromRoot(allConfig, mainLibraryName, subLibraryName) {
    var _a, _b, _c, _d;
    var mainConfig = (_b = ((_a = allConfig.settings) !== null && _a !== void 0 ? _a : {})[mainLibraryName]) !== null && _b !== void 0 ? _b : {};
    if (typeof mainConfig !== 'object') {
        throw new Error("Config for main library \"" + mainLibraryName + "\" should be an object");
    }
    if (subLibraryName == null) {
        return mainConfig;
    }
    var subConfig = (_d = ((_c = allConfig.settings) !== null && _c !== void 0 ? _c : {})[subLibraryName]) !== null && _d !== void 0 ? _d : null;
    if (subConfig === null) {
        subConfig = {};
    }
    // Config for the sub-library that is specified under the main library
    // should override settings for the sub-library that are set outside
    return Object.assign({}, subConfig, mainConfig[subLibraryName]);
}
/**
 * Fetches the config for the given main library from a plugin config
 *
 * @param {PluginConfig} pluginConfig
 * @param {string} mainLibraryName
 * @returns {string[]}
 */
function getMainLibraryConfigPathsFromPlugin(pluginConfig, mainLibraryName) {
    var _a, _b;
    var mainConfig = (_a = pluginConfig[mainLibraryName]) !== null && _a !== void 0 ? _a : null;
    if (mainConfig === null) {
        // No config is specified for the main library by this plugin
        return [];
    }
    if (typeof mainConfig === 'string') {
        // Main config is provided via the simple path-string syntax;
        // the main library config should be required from the given path
        return [mainConfig];
    }
    if (typeof mainConfig === 'object') {
        // Main config is provided via the extended object syntax;
        // the main library config (if given) should be required from the path
        // given as a property of this object with the main library's name
        var pathToMainConfig = (_b = mainConfig[mainLibraryName]) !== null && _b !== void 0 ? _b : null;
        if (pathToMainConfig === null) {
            // Main library's extended syntax does not specify anything for itself
            return [];
        }
        if (typeof pathToMainConfig !== 'string') {
            throw new Error("Value for main library extended config path \"" + mainLibraryName + "." + mainLibraryName + "\" should be a path");
        }
        return [pathToMainConfig];
    }
    throw new Error("Value for main library \"" + mainLibraryName + "\" should be a path or object");
}
/**
 * Fetches the config for the given sub-library from a plugin config
 *
 * @param {PluginConfig} pluginConfig
 * @param {string} mainLibraryName
 * @param {string} subLibraryName
 * @returns {string[]}
 */
function getSubLibraryConfigPathsFromPlugin(pluginConfig, mainLibraryName, subLibraryName) {
    var _a, _b;
    var isolatedPathToSubLibraryConfig = (_a = pluginConfig[subLibraryName]) !== null && _a !== void 0 ? _a : null;
    var pathToSubLibraryConfigUnderMain = null;
    var mainLibraryConfig = (_b = pluginConfig[mainLibraryName]) !== null && _b !== void 0 ? _b : {};
    if (hasOwn.call(pluginConfig, subLibraryName)) {
        if (typeof isolatedPathToSubLibraryConfig !== 'string') {
            throw new Error("Isolated value for sub-library \"" + subLibraryName + "\" should be a path");
        }
    }
    if (typeof mainLibraryConfig === 'object') {
        // Main config is provided via the extended object syntax;
        // the sub-library config (if given) should be required from the path
        // given as a property of this object with the sub-library's name
        if (hasOwn.call(mainLibraryConfig, subLibraryName)) {
            if (typeof mainLibraryConfig[subLibraryName] !== 'string') {
                throw new Error("Value for sub-library under \"" + mainLibraryName + "." + subLibraryName + "\" should be a path");
            }
            pathToSubLibraryConfigUnderMain = mainLibraryConfig[subLibraryName];
        }
    }
    else if (typeof mainLibraryConfig !== 'string') {
        throw new Error("Value for main library extended config path \"" + mainLibraryName + "." + mainLibraryName + "\" should be a path or object");
    }
    var paths = [];
    if (isolatedPathToSubLibraryConfig !== null) {
        paths.push(isolatedPathToSubLibraryConfig);
    }
    // Sub-library config given under main should take precedence,
    // so that defaults may be specified in the "isolated" config
    // and then overridden here
    if (pathToSubLibraryConfigUnderMain !== null) {
        paths.push(pathToSubLibraryConfigUnderMain);
    }
    return paths;
}
/**
 * Fetches the paths to plugins for a given library from a single plugin config
 *
 * @param {PluginConfig} pluginConfig
 * @param {string} mainLibraryName
 * @param {string=} subLibraryName
 * @returns {string[]}
 */
function getLibraryConfigPathsFromPlugin(pluginConfig, mainLibraryName, subLibraryName) {
    return subLibraryName
        ? getSubLibraryConfigPathsFromPlugin(pluginConfig, mainLibraryName, subLibraryName)
        : getMainLibraryConfigPathsFromPlugin(pluginConfig, mainLibraryName);
}
/**
 * Fetches the paths to plugins for a given library from a set of plugin configs
 *
 * @param {PluginConfig[]} pluginConfigs
 * @param {string} mainLibraryName
 * @param {string} subLibraryName
 * @returns {string[]}
 */
function getLibraryConfigPathsFromPlugins(pluginConfigs, mainLibraryName, subLibraryName) {
    var libraryConfigPaths = [];
    for (var _i = 0, pluginConfigs_1 = pluginConfigs; _i < pluginConfigs_1.length; _i++) {
        var pluginConfig = pluginConfigs_1[_i];
        var pluginSubLibraryConfigPaths = getLibraryConfigPathsFromPlugin(pluginConfig, mainLibraryName, subLibraryName);
        libraryConfigPaths.push.apply(libraryConfigPaths, pluginSubLibraryConfigPaths);
    }
    return libraryConfigPaths;
}
/**
 * @inheritDoc
 */
var ConfigExporter = /** @class */ (function () {
    function ConfigExporter(serialisationChecker) {
        this.serialisationChecker = serialisationChecker;
    }
    /**
     * @inheritDoc
     */
    ConfigExporter.prototype.exportLibrary = function (rootConfig, mainLibraryName, subLibraryName) {
        var libraryName = subLibraryName !== null && subLibraryName !== void 0 ? subLibraryName : mainLibraryName;
        var topLevelConfig = getLibraryConfigFromRoot(rootConfig, mainLibraryName, subLibraryName);
        if (!this.serialisationChecker.isSerialisable(topLevelConfig)) {
            throw new Error("Top-level config for library \"" + libraryName + "\" is not serialisable");
        }
        return {
            libraryName: libraryName,
            topLevelConfig: topLevelConfig,
            pluginConfigFilePaths: rootConfig.plugins
                ? getLibraryConfigPathsFromPlugins(rootConfig.plugins, mainLibraryName, subLibraryName)
                : [],
        };
    };
    return ConfigExporter;
}());
exports.default = ConfigExporter;
//# sourceMappingURL=ConfigExporter.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/ConfigImporter.js":
/*!*******************************************************!*\
  !*** ./node_modules/phpconfig/dist/ConfigImporter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @inheritDoc
 */
var ConfigImporter = /** @class */ (function () {
    function ConfigImporter(ConfigSetClass) {
        this.ConfigSetClass = ConfigSetClass;
    }
    /**
     * @inheritDoc
     */
    ConfigImporter.prototype.importLibrary = function (exportedLibraryConfig) {
        return new this.ConfigSetClass(exportedLibraryConfig.configs);
    };
    return ConfigImporter;
}());
exports.default = ConfigImporter;
//# sourceMappingURL=ConfigImporter.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/ConfigLoader.js":
/*!*****************************************************!*\
  !*** ./node_modules/phpconfig/dist/ConfigLoader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A type predicate for determining at runtime whether a valid root config was given.
 *
 * @param {RootConfig | SubConfig} config
 * @returns {boolean}
 */
function isValidConfig(config) {
    return (Object.keys(config).filter(function (settingName) {
        // Only the keys "plugins" and/or "settings" are allowed
        return settingName !== 'plugins' && settingName !== 'settings';
    }).length === 0);
}
/**
 * @inheritDoc
 */
var ConfigLoader = /** @class */ (function () {
    function ConfigLoader(requirer, loader, exporter, ConfigClass, ConfigSetClass) {
        this.requirer = requirer;
        this.loader = loader;
        this.exporter = exporter;
        this.ConfigClass = ConfigClass;
        this.ConfigSetClass = ConfigSetClass;
    }
    /**
     * @inheritDoc
     */
    ConfigLoader.prototype.getConfig = function (searchPaths) {
        var rootConfig = this.loader.load(searchPaths);
        if (!isValidConfig(rootConfig)) {
            throw new Error('Given root config is invalid: may only specify "plugins" or "settings" or both');
        }
        return new this.ConfigClass(this.requirer, this.exporter, rootConfig, this.ConfigSetClass);
    };
    return ConfigLoader;
}());
exports.default = ConfigLoader;
//# sourceMappingURL=ConfigLoader.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/ConfigSet.js":
/*!**************************************************!*\
  !*** ./node_modules/phpconfig/dist/ConfigSet.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
var hasOwn = {}.hasOwnProperty;
/**
 * @inheritDoc
 */
var ConfigSet = /** @class */ (function () {
    function ConfigSet(configs) {
        this.configs = configs;
    }
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.concatArrays = function (settingName) {
        var concatenatedArray = [];
        for (var _i = 0, _a = this.configs; _i < _a.length; _i++) {
            var _b = settingName, rawSettingValue = _a[_i][_b];
            var settingValue = rawSettingValue !== null && rawSettingValue !== void 0 ? rawSettingValue : [];
            if (!Array.isArray(settingValue)) {
                throw new Error("Invalid value for setting " + settingName + ": all values must be arrays but " + typeof settingValue + " (" + settingValue + ") given");
            }
            concatenatedArray.push.apply(concatenatedArray, settingValue);
        }
        return concatenatedArray;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.getBoolean = function (settingName, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        // TODO: Optimise by only extracting values for this specific setting from each config.
        //       For now this is assumed to be efficient enough (as deep and complex config trees
        //       are unlikely)
        var mergedSettingValues = this.mergeAll();
        if (!hasOwn.call(mergedSettingValues, settingName)) {
            // Setting has no value specified in any config
            return defaultValue;
        }
        var settingValue = mergedSettingValues[settingName];
        if (typeof settingValue !== 'boolean') {
            throw new Error("Expected value for setting \"" + settingName + "\" to be a boolean but it was a " + typeof settingValue);
        }
        return settingValue;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.mergeAll = function () {
        var mergedConfig = {};
        var doMerge = function (config) {
            var _a;
            var _b;
            for (var _i = 0, _c = Object.keys(config); _i < _c.length; _i++) {
                var settingName = _c[_i];
                var settingValue = config[settingName];
                if (settingValue === null || typeof settingValue !== 'object') {
                    // Latest setting is not a non-null object: this one should replace any value completely
                    mergedConfig[settingName] = settingValue;
                    continue;
                }
                if (Array.isArray(settingValue)) {
                    // Latest setting value is an array
                    if (Array.isArray(mergedConfig[settingName])) {
                        // Setting in work area is also an array: just concatenate onto the end
                        (_a = mergedConfig[settingName]).push.apply(_a, settingValue);
                    }
                    else {
                        // Setting in work area is not an array: this one should replace the value completely
                        mergedConfig[settingName] = settingValue;
                    }
                }
                else {
                    // Latest setting is an object: merge it onto the existing one (if any)
                    Object.assign((_b = mergedConfig[settingName]) !== null && _b !== void 0 ? _b : (mergedConfig[settingName] = {}), settingValue);
                }
            }
        };
        for (var _i = 0, _a = this.configs; _i < _a.length; _i++) {
            var config = _a[_i];
            doMerge(config);
        }
        return mergedConfig;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.mergeObjects = function (settingName) {
        var mergedConfig = {};
        for (var _i = 0, _a = this.configs; _i < _a.length; _i++) {
            var _b = settingName, rawSettingValue = _a[_i][_b];
            var settingValue = rawSettingValue !== null && rawSettingValue !== void 0 ? rawSettingValue : {};
            if (typeof settingValue !== 'object') {
                throw new Error("Invalid value for setting " + settingName + ": all values must be objects but " + typeof settingValue + " (" + settingValue + ") given");
            }
            Object.assign(mergedConfig, settingValue);
        }
        return mergedConfig;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.mergeUniqueObjects = function (settingName) {
        var _a;
        var mergedConfig = {};
        for (var _i = 0, _b = this.configs; _i < _b.length; _i++) {
            var config = _b[_i];
            var settingValue = void 0;
            if (settingName) {
                // A setting was specified: merge all values for that setting
                var rawSettingValue = config[settingName];
                settingValue = (_a = rawSettingValue) !== null && _a !== void 0 ? _a : {};
                if (typeof settingValue !== 'object') {
                    throw new Error("Invalid value for setting " + settingName + ": all values must be objects but " + typeof settingValue + " (" + settingValue + ") given");
                }
            }
            else {
                // No setting was specified: merge the configs themselves
                settingValue = config;
            }
            for (var _c = 0, _d = Object.keys(settingValue); _c < _d.length; _c++) {
                var propertyName = _d[_c];
                if (hasOwn.call(mergedConfig, propertyName) &&
                    // Allow a setting to be overridden with the exact same value
                    // (eg. where multiple plugins are used that define the same flag setting)
                    mergedConfig[propertyName] !== settingValue[propertyName]) {
                    var newValue = settingValue[propertyName];
                    var propertyOrSettingName = settingName !== null && settingName !== void 0 ? settingName : propertyName;
                    var propertyOrSetting = settingName
                        ? "property \"" + propertyName + "\""
                        : 'setting';
                    throw new Error("Invalid value for setting " + propertyOrSettingName + ": all objects must be unique but " + propertyOrSetting + " has both value (" + mergedConfig[propertyName] + ") and value (" + newValue + ")");
                }
            }
            Object.assign(mergedConfig, settingValue);
        }
        return mergedConfig;
    };
    /**
     * @inheritDoc
     */
    ConfigSet.prototype.toArray = function () {
        return this.configs;
    };
    return ConfigSet;
}());
exports.default = ConfigSet;
//# sourceMappingURL=ConfigSet.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/Loader.js":
/*!***********************************************!*\
  !*** ./node_modules/phpconfig/dist/Loader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");
/**
 * @inheritDoc
 */
var Loader = /** @class */ (function () {
    function Loader(existsSync, requirer, fileName) {
        this.existsSync = existsSync;
        this.requirer = requirer;
        this.fileName = fileName;
    }
    /**
     * @inheritDoc
     */
    Loader.prototype.load = function (searchDirectories) {
        for (var _i = 0, searchDirectories_1 = searchDirectories; _i < searchDirectories_1.length; _i++) {
            var searchDirectory = searchDirectories_1[_i];
            var searchPath = path_1.join(searchDirectory, this.fileName);
            if (this.existsSync(searchPath)) {
                return this.requirer.require(searchPath);
            }
        }
        return {};
    };
    return Loader;
}());
exports.default = Loader;
//# sourceMappingURL=Loader.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/Requirer.js":
/*!*************************************************!*\
  !*** ./node_modules/phpconfig/dist/Requirer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @inheritDoc
 */
var Requirer = /** @class */ (function () {
    function Requirer(nodeRequire) {
        this.nodeRequire = nodeRequire;
    }
    /**
     * @inheritDoc
     */
    Requirer.prototype.require = function (path) {
        return this.nodeRequire(path);
    };
    return Requirer;
}());
exports.default = Requirer;
//# sourceMappingURL=Requirer.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/SerialisationChecker.js":
/*!*************************************************************!*\
  !*** ./node_modules/phpconfig/dist/SerialisationChecker.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @inheritDoc
 */
var SerialisationChecker = /** @class */ (function () {
    function SerialisationChecker() {
    }
    /**
     * @inheritDoc
     */
    SerialisationChecker.prototype.isSerialisable = function (object) {
        return this.isObjectSerialisable(object);
    };
    SerialisationChecker.prototype.isObjectSerialisable = function (object, objectsSeen) {
        if (objectsSeen === void 0) { objectsSeen = []; }
        if (objectsSeen.includes(object)) {
            return false;
        }
        objectsSeen = objectsSeen.concat([object]);
        if (object instanceof Function || object instanceof RegExp) {
            return false;
        }
        if (Array.isArray(object)) {
            for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
                var element = object_1[_i];
                if (!this.isValueSerialisable(element, objectsSeen)) {
                    return false;
                }
            }
        }
        for (var _a = 0, _b = Object.keys(object); _a < _b.length; _a++) {
            var settingName = _b[_a];
            if (!this.isValueSerialisable(object[settingName], objectsSeen)) {
                return false;
            }
        }
        return true;
    };
    SerialisationChecker.prototype.isValueSerialisable = function (value, objectsSeen) {
        if (objectsSeen === void 0) { objectsSeen = []; }
        if (value == null ||
            typeof value === 'boolean' ||
            typeof value === 'number' ||
            typeof value === 'string') {
            return true;
        }
        if (typeof value === 'object') {
            return this.isObjectSerialisable(value, objectsSeen);
        }
        return false;
    };
    return SerialisationChecker;
}());
exports.default = SerialisationChecker;
//# sourceMappingURL=SerialisationChecker.js.map

/***/ }),

/***/ "./node_modules/phpconfig/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/phpconfig/dist/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * PHPConfig - Loads Uniter's PHP configuration
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpconfig/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpconfig/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConfigLoader = exports.configImporter = void 0;
var Config_1 = __webpack_require__(/*! ./Config */ "./node_modules/phpconfig/dist/Config.js");
var ConfigExporter_1 = __webpack_require__(/*! ./ConfigExporter */ "./node_modules/phpconfig/dist/ConfigExporter.js");
var ConfigImporter_1 = __webpack_require__(/*! ./ConfigImporter */ "./node_modules/phpconfig/dist/ConfigImporter.js");
var ConfigLoader_1 = __webpack_require__(/*! ./ConfigLoader */ "./node_modules/phpconfig/dist/ConfigLoader.js");
var ConfigSet_1 = __webpack_require__(/*! ./ConfigSet */ "./node_modules/phpconfig/dist/ConfigSet.js");
var Loader_1 = __webpack_require__(/*! ./Loader */ "./node_modules/phpconfig/dist/Loader.js");
var Requirer_1 = __webpack_require__(/*! ./Requirer */ "./node_modules/phpconfig/dist/Requirer.js");
var SerialisationChecker_1 = __webpack_require__(/*! ./SerialisationChecker */ "./node_modules/phpconfig/dist/SerialisationChecker.js");
var UNIFIED_CONFIG_FILE_NAME = 'uniter.config.js';
var requirer = new Requirer_1.default(__webpack_require__("./node_modules/phpconfig/dist sync recursive"));
var createConfigLoader = function (existsSync) {
    return new ConfigLoader_1.default(requirer, new Loader_1.default(existsSync, requirer, UNIFIED_CONFIG_FILE_NAME), new ConfigExporter_1.default(new SerialisationChecker_1.default()), Config_1.default, ConfigSet_1.default);
};
exports.createConfigLoader = createConfigLoader;
var configImporter = new ConfigImporter_1.default(ConfigSet_1.default);
exports.configImporter = configImporter;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/phpcore/psync.js":
/*!***************************************!*\
  !*** ./node_modules/phpcore/psync.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

/**
 * "Promise-synchronous" (psync) mode entrypoint
 *
 * Allows the public API to be Promise-based even when not using Pausable,
 * so that switching to/from async mode does not require changes to the consuming application.
 */



var debugFormatterInstaller = __webpack_require__(/*! ./src/shared/debugFormatterInstaller */ "./node_modules/phpcore/src/shared/debugFormatterInstaller.js"),
    runtimeFactory = __webpack_require__(/*! ./src/shared/runtimeFactory */ "./node_modules/phpcore/src/shared/runtimeFactory.js");

debugFormatterInstaller.install();

module.exports = runtimeFactory.create('psync');


/***/ }),

/***/ "./node_modules/phpcore/src/Call.js":
/*!******************************************!*\
  !*** ./node_modules/phpcore/src/Call.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {Scope} scope
 * @param {NamespaceScope} namespaceScope
 * @param {Value[]} args
 * @param {Class|null} newStaticClass
 * @constructor
 */
function Call(scope, namespaceScope, args, newStaticClass) {
    /**
     * @type {Value[]}
     */
    this.args = args;
    /**
     * @type {function|null}
     */
    this.finder = null;
    /**
     * @type {NamespaceScope}
     */
    this.namespaceScope = namespaceScope;
    /**
     * @type {Class|null}
     */
    this.newStaticClass = newStaticClass;
    /**
     * @type {Scope}
     */
    this.scope = scope;
}

_.extend(Call.prototype, {
    /**
     * Fetches the current class for the call, if any
     *
     * @returns {Class|null}
     */
    getCurrentClass: function () {
        return this.scope.getCurrentClass();
    },

    /**
     * Fetches the path to the file this call was made from
     *
     * @returns {string|null}
     */
    getFilePath: function () {
        return this.namespaceScope.getFilePath();
    },

    /**
     * Fetches the Value objects passed as arguments to the called function
     *
     * @returns {Value[]}
     */
    getFunctionArgs: function () {
        return this.args;
    },

    /**
     * Fetches the name of the current function
     *
     * @returns {string}
     */
    getFunctionName: function () {
        return this.scope.getTraceFrameName();
    },

    /**
     * Fetches the number of the last line executed inside this call's scope
     *
     * @returns {number|null}
     */
    getLastLine: function () {
        var call = this;

        if (!call.finder) {
            return null;
        }

        return call.finder();
    },

    /**
     * Fetches the scope inside the called function
     *
     * @returns {Scope}
     */
    getScope: function () {
        return this.scope;
    },

    /**
     * Fetches the static class introduced by this call's scope. If null,
     * the call was a forwarding call, and so the parent call's static class should be used
     *
     * @returns {Class|null}
     */
    getStaticClass: function () {
        var call = this,
            thisObject = call.scope.getThisObject();

        if (thisObject && thisObject.getType() !== 'null') {
            return thisObject.getClass();
        }

        return call.newStaticClass;
    },

    /**
     * Fetches the ObjectValue that is the current `$this` object, if any
     *
     * @returns {ObjectValue|null}
     */
    getThisObject: function () {
        return this.scope.getThisObject();
    },

    /**
     * Fetches the path to the file this call was made from, suitable for stack traces (so without any eval context)
     *
     * @returns {string|null}
     */
    getTraceFilePath: function () {
        var call = this;

        return call.scope.getFilePath(call.namespaceScope.getFilePath());
    },

    /**
     * Registers a finder for looking up the current/last line number inside the called function
     *
     * @param {function} finder
     */
    instrument: function (finder) {
        this.finder = finder;
    },

    /**
     * Determines whether this call is to a userland function (defined inside PHP-land) or not
     *
     * @returns {boolean}
     */
    isUserland: function () {
        // If the called function was defined inside the "invisible" global namespace scope,
        // then it was defined in JS-land either as a built-in or was consumer-provided
        return !this.namespaceScope.isGlobal();
    },

    /**
     * Determines whether all errors should be suppressed for this call
     *
     * @returns {boolean}
     */
    suppressesErrors: function () {
        return this.scope.suppressesErrors();
    },

    /**
     * Determines whether own errors should be suppressed for this call
     *
     * @returns {boolean}
     */
    suppressesOwnErrors: function () {
        return this.scope.suppressesOwnErrors();
    }
});

module.exports = Call;


/***/ }),

/***/ "./node_modules/phpcore/src/CallFactory.js":
/*!*************************************************!*\
  !*** ./node_modules/phpcore/src/CallFactory.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {class} Call
 * @param {class} FFICall
 * @constructor
 */
function CallFactory(Call, FFICall) {
    /**
     * @type {class}
     */
    this.Call = Call;
    /**
     * @type {class}
     */
    this.FFICall = FFICall;
}

_.extend(CallFactory.prototype, {
    /**
     * Creates a new Call
     *
     * @param {Scope} scope
     * @param {NamespaceScope} namespaceScope
     * @param {Reference[]|Value[]|Variable[]|=} args
     * @param {Class|null} newStaticClass
     * @returns {Call}
     */
    create: function (scope, namespaceScope, args, newStaticClass) {
        var factory = this;

        return new factory.Call(scope, namespaceScope, args || [], newStaticClass || null);
    },

    /**
     * Creates a new FFI Call
     *
     * @param {Reference[]|Value[]|Variable[]|=} args
     */
    createFFICall: function (args) {
        var factory = this;

        return new factory.FFICall(args || []);
    }
});

module.exports = CallFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/CallStack.js":
/*!***********************************************!*\
  !*** ./node_modules/phpcore/src/CallStack.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError,
    PHPFatalError = phpCommon.PHPFatalError;

/**
 * @param {ValueFactory} valueFactory
 * @param {Translator} translator
 * @param {ErrorReporting} errorReporting
 * @constructor
 */
function CallStack(valueFactory, translator, errorReporting) {
    /**
     * @type {Call[]}
     */
    this.calls = [];
    /**
     * @type {ErrorReporting}
     */
    this.errorReporting = errorReporting;
    /**
     * @type {Translator}
     */
    this.translator = translator;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(CallStack.prototype, {
    /**
     * Fetches the previous Call near the top of the stack, or null if none
     *
     * @returns {Call|null}
     */
    getCaller: function () {
        var chain = this;

        return chain.calls[chain.calls.length - 2] || null;
    },

    /**
     * Fetches the path to the file containing the last line of code executed
     *
     * @returns {string|null}
     */
    getCallerFilePath: function () {
        var caller = this.getUserlandCaller();

        return caller ? caller.getFilePath() : null;
    },

    /**
     * Fetches the number of the last line of code executed in the caller
     *
     * @returns {number|null}
     */
    getCallerLastLine: function () {
        var caller = this.getUserlandCaller();

        return caller ? caller.getLastLine() : null;
    },

    /**
     * Fetches the scope of the previous Call near the top of the stack, or null if none
     *
     * @returns {Scope|null}
     */
    getCallerScope: function () {
        var chain = this,
            callerCall = chain.calls[chain.calls.length - 2] || null;

        return callerCall ? callerCall.getScope() : null;
    },

    /**
     * Fetches the current Call on the top of the stack, or null if none
     *
     * @returns {Call|null}
     */
    getCurrent: function () {
        var chain = this;

        return chain.calls[chain.calls.length - 1] || null;
    },

    /**
     * Fetches the class that defines the current function being executed
     *
     * @returns {Class|null}
     */
    getCurrentClass: function () {
        var chain = this,
            call = chain.getCurrent();

        if (!call) {
            return null;
        }

        return call.getCurrentClass();
    },

    /**
     * Fetches the path to the file containing the last line of code executed
     *
     * @returns {string|null}
     */
    getLastFilePath: function () {
        var caller = this.getUserlandCallee();

        return caller ? caller.getFilePath() : null;
    },

    /**
     * Fetches the number of the last line of code executed
     *
     * @returns {number|null}
     */
    getLastLine: function () {
        var caller = this.getUserlandCallee();

        return caller ? caller.getLastLine() : null;
    },

    /**
     * Fetches the number of calls on the stack (stack depth)
     *
     * @returns {number}
     */
    getLength: function () {
        return this.calls.length;
    },

    /**
     * Fetches the class that is currently considered the static context,
     * referenced with static:: in PHP-land
     *
     * @returns {Class|null}
     */
    getStaticClass: function () {
        var call,
            callStack = this,
            index,
            newStaticClass,
            staticClass = null;

        for (index = callStack.calls.length - 1; index >= 0; index--) {
            call = callStack.calls[index];
            newStaticClass = call.getStaticClass();

            if (newStaticClass) {
                staticClass = newStaticClass;

                break;
            }
        }

        return staticClass;
    },

    /**
     * Fetches the ObjectValue that is the current `$this` object, if any
     *
     * @returns {ObjectValue|null}
     */
    getThisObject: function () {
        var currentCall = this.getCurrent();

        if (!currentCall) {
            return null;
        }

        return currentCall.getThisObject();
    },

    /**
     * Fetches a call stack trace array, with one element for each stack frame (call)
     *
     * @returns {{index: number, file: string, line: number, func: function, args: *[]}[]}
     */
    getTrace: function () {
        var call,
            callStack = this,
            index,
            trace = [],
            chronoIndex = callStack.calls.length - 2;

        for (index = 1; index < callStack.calls.length; index++) {
            call = callStack.calls[index];

            trace.unshift({
                // Most recent call should have index 0
                index: chronoIndex--,
                file: callStack.calls[index - 1].getTraceFilePath(),
                // Fetch the line number the call _occurred on_, rather than the line
                // last executed inside the called function
                line: callStack.calls[index - 1].getLastLine(),
                func: call.getFunctionName(),
                args: call.getFunctionArgs()
            });
        }

        return trace;
    },

    /**
     * Fetches the PHP-land call for the current stack frame. If we are currently
     * executing a built-in function called from a PHP method, the PHP method
     * would be the PHP-land (userland) caller.
     *
     * @returns {Call|null}
     */
    getUserlandCallee: function () {
        var call,
            callStack = this,
            index;

        if (callStack.calls.length === 0) {
            return null;
        }

        index = callStack.calls.length - 1;
        call = callStack.calls[index];

        do {
            if (call.isUserland() || index === 0) {
                return call;
            }

            call = callStack.calls[--index];
        } while (call);

        throw new Error('Could not find a valid userland callee');
    },

    /**
     * Fetches the PHP-land call for the current stack frame. If we are currently
     * executing a built-in function called from a PHP method, the PHP method
     * would be the PHP-land (userland) caller.
     *
     * @returns {Call|null}
     */
    getUserlandCaller: function () {
        var call,
            callStack = this,
            index;

        if (callStack.calls.length < 2) {
            return null;
        }

        index = callStack.calls.length - 2;
        call = callStack.calls[index];

        do {
            if (call.isUserland() || index === 0) {
                return call;
            }

            call = callStack.calls[--index];
        } while (call);

        throw new Error('Could not find a valid userland caller');
    },

    /**
     * Instruments the current call
     *
     * @param {function} finder
     */
    instrumentCurrent: function (finder) {
        this.getCurrent().instrument(finder);
    },

    /**
     * Removes the current call from the stack
     */
    pop: function () {
        this.calls.pop();
    },

    /**
     * Pushes a new current call onto the top of the stack
     *
     * @param {Call} call
     */
    push: function (call) {
        this.calls.push(call);
    },

    /**
     * Raises an error/warning with the specified level and message
     *
     * @TODO: Most places where this function is called provide built-in strings,
     *        which we should move to translations. An exception is trigger_error(...)'s user-provided messages
     * @param {string} level One of the PHPError.E_* constants, eg. `PHPError.E_WARNING`
     * @param {string} message String text message representing the error
     * @param {string=} errorClass
     * @param {boolean=} reportsOwnContext Whether the error handles reporting its own file/line context
     */
    raiseError: function (level, message, errorClass, reportsOwnContext) {
        var call,
            chain = this,
            calls = chain.calls,
            index;

        if (level === PHPError.E_ERROR) {
            // Throw an uncatchable fatal error (catchable errors must be thrown
            // via .raiseTranslatedError(...))
            throw new PHPFatalError(message, chain.getLastFilePath(), chain.getLastLine());
        }

        // Some constructs like isset(...) should only suppress errors
        // for their own scope
        call = chain.getCurrent();

        if (call && call.suppressesOwnErrors()) {
            return;
        }

        // Check whether any parent scope is set to suppress errors (eg. with the @-operator)
        for (index = calls.length - 1; index >= 0; --index) {
            call = calls[index];

            if (call.suppressesErrors()) {
                return;
            }
        }

        chain.errorReporting.reportError(
            level,
            message,
            chain.getLastFilePath(),
            chain.getLastLine(),
            chain.getTrace(),
            !!reportsOwnContext
        );
    },

    /**
     * Raises a catchable Error or a notice/warning with the specified level, message translation key and variables
     *
     * @param {string} level One of the PHPError.E_* constants, eg. `PHPError.E_WARNING`
     * @param {string} translationKey
     * @param {Object.<string, string>=} placeholderVariables
     * @param {string=} errorClass
     * @param {boolean=} reportsOwnContext Whether the error handles reporting its own file/line context
     * @param {string=} filePath
     * @param {number=} lineNumber
     * @throws {ObjectValue} Throws an ObjectValue-wrapped Throwable if not a notice or warning
     */
    raiseTranslatedError: function (
        level,
        translationKey,
        placeholderVariables,
        errorClass,
        reportsOwnContext,
        filePath,
        lineNumber
    ) {
        var callStack = this,
            message = callStack.translator.translate(translationKey, placeholderVariables);

        if (level === PHPError.E_ERROR) {
            // Non-warning/non-notice errors need to actually stop execution
            // NB: The Error class' constructor will fetch file and line number info
            throw callStack.valueFactory.createErrorObject(
                errorClass || 'Error',
                message,
                null,
                null,
                filePath,
                lineNumber,
                reportsOwnContext
            );
        }

        callStack.raiseError(level, message, errorClass, reportsOwnContext);
    },

    /**
     * Raises an uncatchable PHP fatal error with the specified message translation key and variables
     *
     * @param {string} translationKey
     * @param {Object.<string, string>=} placeholderVariables
     * @throws {PHPFatalError} Throws an uncatchable PHPFatalError
     */
    raiseUncatchableFatalError: function (translationKey, placeholderVariables) {
        var callStack = this,
            message = callStack.translator.translate(translationKey, placeholderVariables);

        callStack.raiseError(PHPError.E_ERROR, message);
    }
});

module.exports = CallStack;


/***/ }),

/***/ "./node_modules/phpcore/src/Class.js":
/*!*******************************************!*\
  !*** ./node_modules/phpcore/src/Class.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ./Reference/StaticProperty */ "./node_modules/phpcore/src/Reference/StaticProperty.js"),
    __webpack_require__(/*! ./Reference/UndeclaredStaticProperty */ "./node_modules/phpcore/src/Reference/UndeclaredStaticProperty.js")
], function (
    _,
    phpCommon,
    StaticPropertyReference,
    UndeclaredStaticPropertyReference
) {
    var IS_STATIC = 'isStatic',
        MAGIC_CALL = '__call',
        MAGIC_CALL_STATIC = '__callStatic',

        CANNOT_ACCESS_PROPERTY = 'core.cannot_access_property',
        UNDEFINED_CLASS_CONSTANT = 'core.undefined_class_constant',
        UNDEFINED_METHOD = 'core.undefined_method',

        VALUE = 'value',
        VISIBILITY = 'visibility',
        hasOwn = {}.hasOwnProperty,
        PHPError = phpCommon.PHPError,
        getMethod = function (object, methodName) {
            var result = null;

            _.forOwn(object, function (value, propertyName) {
                if (
                    propertyName.toLowerCase() === methodName.toLowerCase() &&
                    _.isFunction(value)
                ) {
                    result = value;
                    return false;
                }
            });

            return result;
        };

    /**
     * Represents a class exposed to PHP-land
     *
     * @param {ValueFactory} valueFactory
     * @param {FunctionFactory} functionFactory
     * @param {CallStack} callStack
     * @param {string} name Fully-qualified class name (FQCN)
     * @param {string} constructorName
     * @param {Function} InternalClass
     * @param {Object} rootInternalPrototype
     * @param {Object} staticPropertiesData
     * @param {Object.<string, Function>} constants Map of constant names to value factory functions
     * @param {Class|null} superClass Parent class, if any
     * @param {string[]} interfaceNames FQCNs (FQINs) of interfaces implemented by this class
     * @param {NamespaceScope} namespaceScope
     * @param {ExportRepository} exportRepository
     * @param {ValueCoercer} valueCoercer Value coercer configured specifically for this class
     * @param {FFIFactory} ffiFactory
     * @constructor
     */
    function Class(
        valueFactory,
        functionFactory,
        callStack,
        name,
        constructorName,
        InternalClass,
        rootInternalPrototype,
        staticPropertiesData,
        constants,
        superClass,
        interfaceNames,
        namespaceScope,
        exportRepository,
        valueCoercer,
        ffiFactory
    ) {
        var classObject = this,
            staticProperties = {};

        this.callStack = callStack;
        this.constants = constants;
        this.constructorName = constructorName;
        this.exportRepository = exportRepository;
        /**
         * @type {FFIFactory}
         */
        this.ffiFactory = ffiFactory;
        this.functionFactory = functionFactory;
        this.interfaceNames = interfaceNames || [];
        this.InternalClass = InternalClass;
        this.name = name;
        this.namespaceScope = namespaceScope;
        // The prototype object that we should stop at when walking up the chain
        this.rootInternalPrototype = rootInternalPrototype;
        this.staticProperties = staticProperties;
        this.superClass = superClass || null;
        /**
         * @type {ValueCoercer}
         */
        this.valueCoercer = valueCoercer;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;

        _.each(staticPropertiesData, function (data, name) {
            // Pass the class object to the property initialiser (if any),
            // so that it may refer to other properties/constants of this class with self::*
            staticProperties[name] = new StaticPropertyReference(
                valueFactory,
                callStack,
                classObject,
                name,
                data[VISIBILITY],
                data[VALUE](classObject)
            );
        });
    }

    _.extend(Class.prototype, {
        /**
         * Calls an instance or static method. If `objectValue` is passed, the call
         * will be in an object context, otherwise it will be in a static context.
         *
         * Omit both `objectValue` and `currentNativeObject` for a static call.
         *
         * @param {string} methodName The name of the method to call
         * @param {Value[]} args The wrapped value objects to pass as arguments to the method
         * @param {ObjectValue|null} objectValue The wrapped ObjectValue for this instance
         * @param {object|null} currentNativeObject The current native JS object on the prototype chain to search for the method
         * @param {Class|null} currentClass The original called class (this function is called recursively for inherited methods)
         * @param {bool} isForwardingStaticCall eg. self::f() is forwarding, MyParentClass::f() is non-forwarding
         * @returns {Value} Returns the result of the method if it is defined
         * @throws {PHPFatalError} Throws when the method is not defined
         */
        callMethod: function (methodName, args, objectValue, currentNativeObject, currentClass, isForwardingStaticCall) {
            var classObject = this,
                nativeObject = objectValue ? objectValue.getObject() : null,
                result,
                thisObject = classObject.callStack.getThisObject();

            function callMethod(currentObject, methodName, args) {
                var method = getMethod(currentObject, methodName);

                if (method !== null) {
                    if (!objectValue && !method[IS_STATIC]) {
                        objectValue = thisObject;

                        if (!objectValue) {
                            // TODO: Change for PHP 7 (see https://www.php.net/manual/en/migration70.incompatible.php)
                            classObject.callStack.raiseError(
                                PHPError.E_STRICT,
                                'Non-static method ' + method.data.classObject.name +
                                '::' + methodName + '() should not be called statically'
                            );
                        } else if (!objectValue.classIs(classObject.getName())) {
                            // TODO: Change for PHP 7 (see https://www.php.net/manual/en/migration70.incompatible.php)
                            classObject.callStack.raiseError(
                                PHPError.E_STRICT,
                                'Non-static method ' + method.data.classObject.name +
                                '::' + methodName + '() should not be called statically, ' +
                                'assuming $this from incompatible context'
                            );
                        }
                    }

                    // For a non-forwarding static call, pass the new static class through.
                    // (For a forwarding static call, we will pass `null` through as the "new static class"
                    // inside FunctionFactory, because we just want to use the one the caller has.)
                    if (!isForwardingStaticCall) {
                        classObject.functionFactory.setNewStaticClassIfWrapped(method, currentClass);
                    }

                    return classObject.valueFactory.coerce(
                        method.apply(
                            // Some methods should never have their `this` object and args auto-coerced,
                            // eg the magic `__construct` method as it is proxied in Namespace.js
                            classObject.valueCoercer.isAutoCoercionEnabled() && !method.neverCoerce ?
                                objectValue.getObject() :
                                objectValue,
                            method.neverCoerce ? args : classObject.valueCoercer.coerceArguments(args)
                        )
                    );
                }

                if (
                    currentObject === classObject.rootInternalPrototype &&
                    classObject.superClass
                ) {
                    return classObject.superClass.callMethod(
                        methodName,
                        args,
                        objectValue,
                        Object.getPrototypeOf(currentObject),
                        currentClass,
                        isForwardingStaticCall
                    );
                }

                currentObject = Object.getPrototypeOf(currentObject);

                if (!currentObject) {
                    return null;
                }

                return callMethod(currentObject, methodName, args);
            }

            isForwardingStaticCall = !!isForwardingStaticCall;

            if (!currentNativeObject) {
                // Walk up the prototype chain from the native object
                currentNativeObject = nativeObject;
            }

            if (!currentClass) {
                currentClass = classObject;
            }

            if (nativeObject instanceof classObject.InternalClass) {
                // Ignore own properties of the native object when searching for methods
                if (currentNativeObject === nativeObject) {
                    currentNativeObject = Object.getPrototypeOf(currentNativeObject);
                }
            } else {
                // For some special classes (eg. JSObject, Closure) the native object may not actually
                // be an instance of the InternalClass, so fake inheritance of the native class
                currentNativeObject = classObject.InternalClass.prototype;
            }

            result = callMethod(currentNativeObject, methodName, args);

            if (result !== null) {
                return result;
            }

            // Method was not found on object or its prototype chain: try the magic method(s)

            if (!objectValue && thisObject) {
                // Magic __call(...) should override __callStatic(...)
                // when both present for static call in object context
                result = callMethod(thisObject.getObject(), MAGIC_CALL, [
                    classObject.valueFactory.createString(methodName),
                    classObject.valueFactory.createArray(args)
                ]);

                if (result !== null) {
                    return result;
                }
            }

            result = callMethod(
                currentNativeObject,
                objectValue ? MAGIC_CALL : MAGIC_CALL_STATIC,
                [
                    classObject.valueFactory.createString(methodName),
                    classObject.valueFactory.createArray(args)
                ]
            );

            if (result !== null) {
                return result;
            }

            // Method was not found and no magic __call method is defined
            classObject.callStack.raiseTranslatedError(PHPError.E_ERROR, UNDEFINED_METHOD, {
                className: classObject.name,
                methodName: methodName
            });
        },

        /**
         * Calls the userland constructor for the provided object
         *
         * @param {ObjectValue} objectValue
         * @param {Value[]} args
         */
        construct: function (objectValue, args) {
            var classObject = this;

            if (!classObject.constructorName) {
                // Class does not define a constructor: call the superclass' constructor
                // if it has one, otherwise do nothing
                if (classObject.superClass) {
                    classObject.superClass.construct(objectValue, args);
                }

                return;
            }

            // Call the constructor for the current class and not via the object value,
            // as the method may have been overridden by descendant classes
            classObject.callMethod(classObject.constructorName, args, objectValue);
        },

        /**
         * Exports instances of this class with a defined unwrapper if one has been set,
         * otherwise wraps them in a native JS class that extends the PHP class' internal class
         *
         * @param {ObjectValue} objectValue
         * @returns {Object}
         */
        exportInstanceForJS: function (objectValue) {
            return this.exportRepository.export(objectValue);
        },

        /**
         * Determines whether this class extends the given other class
         *
         * @param {Class} superClass
         * @returns {boolean}
         */
        extends: function (superClass) {
            var classObject = this;

            return classObject.superClass && (classObject.superClass.name === superClass.name || classObject.superClass.extends(superClass));
        },

        /**
         * Fetches the value of a constant of this class. Constants may be defined by the current class,
         * an ancestor or by an interface implemented by this class or an ancestor
         *
         * @param {string} name
         * @returns {Value}
         */
        getConstantByName: function (name) {
            var classObject = this,
                i,
                interfaceObject;

            if (name.toLowerCase() === 'class') {
                // The special MyClass::class constant that fetches the FQCN of the class as a string
                return classObject.valueFactory.createString(classObject.getName());
            }

            if (hasOwn.call(classObject.constants, name)) {
                return classObject.constants[name]();
            }

            for (i = 0; i < classObject.interfaceNames.length; i++) {
                interfaceObject = classObject.namespaceScope.getClass(classObject.interfaceNames[i]);

                try {
                    return interfaceObject.getConstantByName(name);
                } catch (e) {
                    // Not found, try the next interface
                }
            }

            if (classObject.superClass) {
                return classObject.superClass.getConstantByName(name);
            }

            classObject.callStack.raiseTranslatedError(PHPError.E_ERROR, UNDEFINED_CLASS_CONSTANT, {
                name: name
            });
        },

        getInternalClass: function () {
            return this.InternalClass;
        },

        /**
         * Fetches the spec for an instance or static method
         *
         * @param {string} methodName The name of the method to fetch the spec for
         * @param {ObjectValue=null} objectValue The wrapped ObjectValue for this instance
         * @param {object=null} currentNativeObject The current native JS object on the prototype chain to search for the method
         * @param {Class=null} originalClass The original class (this function is called recursively for inherited methods)
         * @returns {MethodSpec|null} Returns the spec of the method if it exists, or null if it does not
         */
        getMethodSpec: function (methodName, objectValue, currentNativeObject, originalClass) {
            var classObject = this,
                nativeObject = objectValue ? objectValue.getObject() : null;

            function getMethodSpec(currentObject, methodName) {
                var method = getMethod(currentObject, methodName);

                if (method !== null) {
                    return classObject.functionFactory.createMethodSpec(originalClass, classObject, methodName, method);
                }

                if (
                    currentObject === classObject.rootInternalPrototype &&
                    classObject.superClass
                ) {
                    return classObject.superClass.getMethodSpec(
                        methodName,
                        objectValue,
                        Object.getPrototypeOf(currentObject),
                        originalClass
                    );
                }

                currentObject = Object.getPrototypeOf(currentObject);

                if (!currentObject) {
                    return null;
                }

                return getMethodSpec(currentObject, methodName);
            }

            if (!currentNativeObject) {
                // Walk up the prototype chain from the native object
                currentNativeObject = nativeObject;
            }

            if (!originalClass) {
                originalClass = classObject;
            }

            if (nativeObject instanceof classObject.InternalClass) {
                // Ignore own properties of the native object when searching for methods
                if (currentNativeObject === nativeObject) {
                    currentNativeObject = Object.getPrototypeOf(currentNativeObject);
                }
            } else {
                // For some special classes (eg. JSObject, Closure) the native object may not actually
                // be an instance of the InternalClass, so fake inheritance of the native class
                currentNativeObject = classObject.InternalClass.prototype;
            }

            return getMethodSpec(currentNativeObject, methodName);
        },

        /**
         * Fetches the FQCN (Fully-Qualified Class Name) of this class.
         * If the namespace prefix is not wanted, see .getUnprefixedName()
         *
         * @returns {string}
         */
        getName: function () {
            return this.name;
        },

        /**
         * Fetches the name of this class with any namespace prefix removed,
         * eg.:
         *     class with FQCN: My\Stuff\AwesomeClass
         *     unprefixed name: AwesomeClass
         *
         * @returns {string}
         */
        getUnprefixedName: function () {
            return this.name.replace(/^.*\\/, '');
        },

        /**
         * Fetches a reference to a static property of this class by its name
         *
         * @param {string} name
         * @param {Class=} calledClass
         * @returns {StaticPropertyReference|UndeclaredStaticPropertyReference}
         */
        getStaticPropertyByName: function (name, calledClass) {
            var callingClass,
                classObject = this,
                staticProperty;

            // The class that the static property was originally dereferenced for:
            // if we've walked up the class hierarchy to find its definition,
            // this will refer to the class that was actually specified to the left of the `::`
            calledClass = calledClass || classObject;

            if (!hasOwn.call(classObject.staticProperties, name)) {
                if (classObject.superClass) {
                    // Inherit static properties from the parent class, if we extend one
                    return classObject.superClass.getStaticPropertyByName(name, calledClass);
                }

                // Undeclared static properties cannot be accessed _except_ by isset(...) or empty(...),
                // which return the relevant boolean result (`false` and `true` respectively)
                return new UndeclaredStaticPropertyReference(
                    classObject.valueFactory,
                    classObject.callStack,
                    classObject,
                    name
                );
            }

            staticProperty = classObject.staticProperties[name];

            // Property is private; may only be read from methods of this class and not derivatives
            if (staticProperty.getVisibility() === 'private') {
                callingClass = classObject.callStack.getCurrentClass();

                if (!callingClass || callingClass.name !== classObject.name) {
                    classObject.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_ACCESS_PROPERTY, {
                        className: calledClass.getName(),
                        propertyName: name,
                        visibility: 'private'
                    });
                }
            // Property is protected; may be read from methods of this class and methods of derivatives
            } else if (staticProperty.getVisibility() === 'protected') {
                callingClass = classObject.callStack.getCurrentClass();

                if (
                    !callingClass ||
                    (
                        classObject.getName() !== callingClass.getName() &&
                        !callingClass.isInFamilyOf(classObject)
                    )
                ) {
                    classObject.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_ACCESS_PROPERTY, {
                        className: classObject.name,
                        propertyName: name,
                        visibility: 'protected'
                    });
                }
            }

            return staticProperty;
        },

        /**
         * Fetches the parent class of this one, or null if it has no parent
         *
         * @returns {Class|null}
         */
        getSuperClass: function () {
            return this.superClass;
        },

        hasStaticPropertyByName: function (name) {
            return hasOwn.call(this.staticProperties, name);
        },

        /**
         * Fetches all interfaces directly implemented by this class
         *
         * @returns {Class[]}
         */
        getInterfaces: function () {
            var classObject = this;

            return classObject.interfaceNames.map(function (interfaceName) {
                return classObject.namespaceScope.getClass(interfaceName);
            });
        },

        /**
         * Returns either the given ObjectValue or its inner native object, based on the class' auto-coercion mode
         *
         * @param {ObjectValue} instance
         * @returns {ObjectValue|Object}
         */
        getThisObjectForInstance: function (instance) {
            return this.valueCoercer.isAutoCoercionEnabled() ? instance.getObject() : instance;
        },

        /**
         * Creates a new instance of this class
         *
         * @param {Value[]=} args
         * @returns {ObjectValue}
         */
        instantiate: function (args) {
            var classObject = this,
                objectValue;

            if (!args) {
                args = [];
            }

            objectValue = classObject.instantiateBare(args);

            // Call the userland constructor
            classObject.construct(objectValue, args);

            return objectValue;
        },

        /**
         * Creates a new instance of this class without calling any userland constructor
         * (note that for JS classes the class-constructor-function will still be called)
         *
         * @param {Value[]=} args
         * @returns {ObjectValue}
         */
        instantiateBare: function (args) {
            var classObject = this,
                nativeObject = Object.create(classObject.InternalClass.prototype),
                objectValue = classObject.valueFactory.createObject(nativeObject, classObject);

            if (!args) {
                args = [];
            }

            classObject.InternalClass.apply(
                // Always use the wrapped object value as `this` regardless of coercion status,
                // so that non-native properties/methods may be accessed
                objectValue,
                classObject.valueCoercer.coerceArguments(args)
            );

            return objectValue;
        },

        /**
         * Creates a new instance of this class and also sets the given internal properties (shorthand)
         *
         * @param {Value[]} args
         * @param {Object.<string, *>} internals
         * @return {ObjectValue}
         */
        instantiateWithInternals: function (args, internals) {
            var classObject = this,
                objectValue = classObject.instantiate(args);

            _.forOwn(internals, function (value, name) {
                objectValue.setInternalProperty(name, value);
            });

            return objectValue;
        },

        /**
         * Determines whether:
         * - This class' FQCN is the same as the one given, or
         * - This class implements an interface with the name given, or
         * - This class has an ancestor with the name given
         *
         * @param {Class} className
         * @returns {boolean}
         */
        is: function (className) {
            var classObject = this,
                interfaceMatches = false;

            // Case-insensitively compare the fully-qualified class paths
            if (classObject.name.toLowerCase() === className.toLowerCase()) {
                return true;
            }

            // Iterate over all the interfaces implemented by this class: if any of them
            // are the requested class or extend from it, return true
            _.each(classObject.interfaceNames, function (interfaceName) {
                var interfaceObject = classObject.namespaceScope.getClass(interfaceName);

                if (interfaceObject.is(className)) {
                    interfaceMatches = true;
                    return false;
                }
            });

            if (interfaceMatches) {
                return true;
            }

            if (classObject.superClass) {
                return classObject.superClass.is(className);
            }

            return false;
        },

        /**
         * Determines whether this class is identical to or is an ancestor or descendant
         * of the specified other class
         *
         * @param {Class} otherClass
         * @returns {boolean}
         */
        isInFamilyOf: function (otherClass) {
            var classObject = this;

            return classObject === otherClass ||
                classObject.extends(otherClass) ||
                otherClass.extends(classObject);
        },

        /**
         * Returns true if auto-coercion is enabled, and false otherwise.
         * Constructor and method arguments will be unwrapped to native JS values when enabled
         *
         * @returns {boolean}
         */
        isAutoCoercionEnabled: function () {
            return this.valueCoercer.isAutoCoercionEnabled();
        },

        /**
         * Wraps instances of this class in instances of the proxying PHPObject class
         *
         * @param {ObjectValue} instance
         * @returns {PHPObject}
         */
        proxyInstanceForJS: function (instance) {
            var classObject = this;

            // Return a wrapper object that presents a promise-based API
            // for calling methods of PHP objects in sync or async mode
            return classObject.ffiFactory.createPHPObject(instance);
        },

        /**
         * Unwraps arguments for a method based on the coercion & prefer-sync modes for the class
         *
         * @param {Value[]} argumentValues
         * @returns {Value[]|*[]}
         */
        unwrapArguments: function (argumentValues) {
            return this.valueCoercer.coerceArguments(argumentValues);
        }
    });

    return Class;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/ClassAutoloader.js":
/*!*****************************************************!*\
  !*** ./node_modules/phpcore/src/ClassAutoloader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    var MAGIC_AUTOLOAD_FUNCTION = '__autoload';

    function ClassAutoloader(valueFactory) {
        this.globalNamespace = null;
        this.splStack = null;
        this.valueFactory = valueFactory;
    }

    _.extend(ClassAutoloader.prototype, {
        appendAutoloadCallable: function (autoloadCallable) {
            var autoloader = this,
                splStack = autoloader.splStack;

            if (!splStack) {
                splStack = [];
                autoloader.splStack = splStack;
            }

            splStack.push(autoloadCallable);
        },

        autoloadClass: function (name) {
            var autoloader = this,
                globalNamespace = autoloader.globalNamespace,
                magicAutoloadFunction,
                splStack = autoloader.splStack;

            if (splStack) {
                _.each(splStack, function (autoloadCallable) {
                    autoloadCallable.call([autoloader.valueFactory.createString(name)], globalNamespace);

                    if (globalNamespace.hasClass(name)) {
                        // Autoloader has defined the class: no need to call any further autoloaders
                        return false;
                    }
                });
            } else {
                magicAutoloadFunction = globalNamespace.getOwnFunction(MAGIC_AUTOLOAD_FUNCTION);

                if (magicAutoloadFunction) {
                    magicAutoloadFunction(autoloader.valueFactory.createString(name));
                }
            }
        },

        removeAutoloadCallable: function (autoloadCallable) {
            var found = false,
                splStack = this.splStack;

            if (!splStack) {
                // SPL stack has not been enabled: nothing to do
                return false;
            }

            _.each(splStack, function (existingAutoloadCallable, index) {
                // Callables may be different value types or different objects,
                // so compare using the *Value API
                if (existingAutoloadCallable.isEqualTo(autoloadCallable).getNative()) {
                    found = true;
                    splStack.splice(index, 1);
                    return false;
                }
            });

            return found;
        },

        setGlobalNamespace: function (globalNamespace) {
            this.globalNamespace = globalNamespace;
        }
    });

    return ClassAutoloader;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Closure.js":
/*!*********************************************!*\
  !*** ./node_modules/phpcore/src/Closure.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    /**
     * @param {ClosureFactory} closureFactory
     * @param {ValueFactory} valueFactory
     * @param {NamespaceScope} namespaceScope
     * @param {Function} unwrappedFunction
     * @param {Function} wrappedFunction
     * @param {Scope} enclosingScope
     * @param {ObjectValue|null} thisObject
     * @param {FunctionSpec} functionSpec
     * @constructor
     */
    function Closure(
        closureFactory,
        valueFactory,
        namespaceScope,
        enclosingScope,
        unwrappedFunction,
        wrappedFunction,
        thisObject,
        functionSpec
    ) {
        /**
         * @type {ClosureFactory}
         */
        this.closureFactory = closureFactory;
        /**
         * @type {Scope}
         */
        this.enclosingScope = enclosingScope;
        /**
         * @type {FunctionSpec}
         */
        this.functionSpec = functionSpec;
        /**
         * @type {NamespaceScope}
         */
        this.namespaceScope = namespaceScope;
        /**
         * @type {ObjectValue|null}
         */
        this.thisObject = thisObject;
        /**
         * @type {Function}
         */
        this.unwrappedFunction = unwrappedFunction;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
        /**
         * @type {Function}
         */
        this.wrappedFunction = wrappedFunction;
    }

    _.extend(Closure.prototype, {
        /**
         * Creates a new closure identical to this one,
         * but bound to the specified `$this` object and class scope
         *
         * @param {ObjectValue|NullValue} thisObject
         * @param {Class|undefined} scopeClass
         * @returns {closure.enclosingScope}
         */
        bind: function (thisObject, scopeClass) {
            var closure = this;

            return closure.closureFactory.create(
                closure.enclosingScope,
                closure.unwrappedFunction,
                closure.namespaceScope,
                scopeClass || null,
                thisObject,
                closure.functionSpec
            );
        },

        /**
         * Invokes this closure with the provided arguments, returning its result
         *
         * @param {Value[]} args
         * @param {ObjectValue|undefined} thisObject
         * @returns {Value}
         */
        invoke: function (args, thisObject) {
            // Store the current PHP thisObj to set for the closure
            var closure = this;

            return closure.valueFactory.coerce(
                closure.wrappedFunction.apply(thisObject || closure.thisObject, args)
            );
        }
    });

    return Closure;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/ClosureFactory.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/ClosureFactory.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    /**
     * @param {FunctionFactory} functionFactory
     * @param {ValueFactory} valueFactory
     * @param {CallStack} callStack
     * @param {class} Closure
     * @constructor
     */
    function ClosureFactory(
        functionFactory,
        valueFactory,
        callStack,
        Closure
    ) {
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {class}
         */
        this.Closure = Closure;
        /**
         * @type {FunctionFactory}
         */
        this.functionFactory = functionFactory;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(ClosureFactory.prototype, {
        /**
         * Creates a new Closure
         *
         * @param {Scope} enclosingScope
         * @param {Function} unwrappedFunction
         * @param {NamespaceScope} namespaceScope
         * @param {Class|undefined} scopeClass
         * @param {ObjectValue|NullValue|null} thisObject Null for a static closure, the object to use otherwise
         * @param {FunctionSpec} functionSpec
         * @returns {Closure}
         */
        create: function (enclosingScope, unwrappedFunction, namespaceScope, scopeClass, thisObject, functionSpec) {
            var factory = this,
                wrappedFunction;

            // If a bound object is specified but no class scope, use the class of the object
            if (!scopeClass) {
                scopeClass = thisObject && thisObject.getType() !== 'null' ?
                    thisObject.getClass() :
                    null;
            }

            wrappedFunction = factory.functionFactory.create(
                namespaceScope,
                scopeClass,
                unwrappedFunction,
                null,
                null,
                // Inside a closure, static:: will either refer to the current bound static class
                // or, if none, then the current/owning class of the method that created it
                factory.callStack.getStaticClass() || scopeClass || null,
                functionSpec
            );

            return new factory.Closure(
                factory,
                factory.valueFactory,
                namespaceScope,
                enclosingScope,
                unwrappedFunction,
                wrappedFunction,
                thisObject,
                functionSpec
            );
        }
    });

    return ClosureFactory;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Debug/DebugFactory.js":
/*!********************************************************!*\
  !*** ./node_modules/phpcore/src/Debug/DebugFactory.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {class} DebugFormatter
 * @param {class} DebugValue
 * @param {class} ValueFormatter
 * @constructor
 */
function DebugFactory(DebugFormatter, DebugValue, ValueFormatter) {
    /**
     * @type {class}
     */
    this.DebugFormatter = DebugFormatter;
    /**
     * @type {class}
     */
    this.DebugValue = DebugValue;
    /**
     * @type {class}
     */
    this.ValueFormatter = ValueFormatter;
}

_.extend(DebugFactory.prototype, {
    /**
     * Creates a new DebugFormatter
     *
     * @returns {DebugFormatter}
     */
    createDebugFormatter: function () {
        var factory = this,
            valueFormatter = new factory.ValueFormatter(factory);

        return new factory.DebugFormatter(valueFormatter);
    },

    /**
     * Creates a DebugValue that wraps the specified value
     *
     * @param {Value} value
     * @returns {DebugValue}
     */
    createValue: function (value) {
        return new this.DebugValue(value);
    }
});

module.exports = DebugFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Debug/DebugFormatter.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/Debug/DebugFormatter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    DebugValue = __webpack_require__(/*! ./DebugValue */ "./node_modules/phpcore/src/Debug/DebugValue.js"),
    DebugVariable = __webpack_require__(/*! ./DebugVariable */ "./node_modules/phpcore/src/Debug/DebugVariable.js");

/**
 * Debugging variable formatter for Chrome's Developer Tools
 *
 * @param {ValueFormatter} valueFormatter
 * @constructor
 */
function DebugFormatter(valueFormatter) {
    /**
     * @type {ValueFormatter}
     */
    this.valueFormatter = valueFormatter;
}

_.extend(DebugFormatter.prototype, {
    /**
     * Formats an "expanded" view of a PHP variable in Chrome's dev tools
     *
     * @param {DebugVariable|DebugValue} debugVariable
     * @returns {[]}
     */
    body: function (debugVariable) {
        var value = debugVariable.getValue(),
            formattedValue = this.valueFormatter.format(value),
            structure = [
                'table',
                {},
                [
                    'tr',
                    {},
                    [
                        'td',
                        {
                            'style': 'font-weight: bold;'
                        },
                        'type:'
                    ],
                    [
                        'td',
                        {},
                        value.getType()
                    ]
                ]
            ];

        function addAttribute(name, value, style) {
            structure.push([
                'tr',
                {},
                [
                    'td',
                    {
                        'style': 'font-weight: bold;'
                    },
                    name + ':'
                ],
                [
                    'td',
                    {
                        'style': style
                    },
                    value
                ]
            ]);
        }

        if (formattedValue.attributes.length === 0) {
            // No attributes provided, only value, so add value as the only attribute
            // so that the value can be expanded in the debugger to see its type along with value
            addAttribute('value', formattedValue.headingValue, formattedValue.headingStyle);
        } else {
            _.each(formattedValue.attributes, function (attribute) {
                addAttribute(attribute.name, attribute.value, attribute.style);
            });
        }

        return structure;
    },

    /**
     * Returns true if the value can be expanded with .body(...) above, false otherwise
     *
     * @param {DebugVariable|DebugValue|*} debugVariable
     * @returns {boolean}
     */
    hasBody: function (debugVariable) {
        return (debugVariable instanceof DebugVariable && debugVariable.isDefined()) ||
            debugVariable instanceof DebugValue;
    },

    /**
     * Formats a minimal/inline view of a PHP variable in Chrome's dev tools
     *
     * @param {DebugVariable|DebugValue|*} debugVariable
     * @returns {[]}
     */
    header: function (debugVariable) {
        var formattedValue,
            value;

        if (!(debugVariable instanceof DebugVariable) && !(debugVariable instanceof DebugValue)) {
            return null;
        }

        if (!debugVariable.isDefined()) {
            return ['span', {'style': 'text-style: italic; color: gray;'}, '<undefined>'];
        }

        value = debugVariable.getValue();

        formattedValue = this.valueFormatter.format(value);

        return ['span', {'style': formattedValue.headingStyle}, formattedValue.headingValue];
    }
});

module.exports = DebugFormatter;


/***/ }),

/***/ "./node_modules/phpcore/src/Debug/DebugFormatterInstaller.js":
/*!*******************************************************************!*\
  !*** ./node_modules/phpcore/src/Debug/DebugFormatterInstaller.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Installer for the debugging variable formatter
 * for Chrome's Developer Tools
 *
 * @param {Window} window
 * @param {DebugFactory} debugFactory
 * @constructor
 */
function DebugFormatterInstaller(window, debugFactory) {
    /**
     * @type {DebugFactory}
     */
    this.debugFactory = debugFactory;
    /**
     * @type {Window}
     */
    this.window = window;
}

_.extend(DebugFormatterInstaller.prototype, {
    /**
     * Installs a DebugFormatter into the global scope
     * for Chrome's Developer Tools to pick up
     */
    install: function () {
        var installer = this,
            debugFormatter = installer.debugFactory.createDebugFormatter();

        if (!installer.window.devtoolsFormatters) {
            installer.window.devtoolsFormatters = [];
        }

        installer.window.devtoolsFormatters.push(debugFormatter);
    }
});

module.exports = DebugFormatterInstaller;


/***/ }),

/***/ "./node_modules/phpcore/src/Debug/DebugValue.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcore/src/Debug/DebugValue.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Represents a PHP value to be displayed in the devtools debugger
 *
 * @param {Value} value
 * @constructor
 */
function DebugValue(value) {
    /**
     * @type {Value}
     */
    this.value = value;
}

_.extend(DebugValue.prototype, {
    /**
     * Fetches the value this debug value represents
     *
     * @returns {Value}
     */
    getValue: function () {
        return this.value;
    },

    /**
     * Determines whether the value is defined: should always be true
     * (this is shared by the interface of DebugVariable, which may return false
     * if the variable has not (yet) been defined in the scope)
     *
     * @returns {boolean}
     */
    isDefined: function () {
        return true;
    }
});

module.exports = DebugValue;


/***/ }),

/***/ "./node_modules/phpcore/src/Debug/DebugVariable.js":
/*!*********************************************************!*\
  !*** ./node_modules/phpcore/src/Debug/DebugVariable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {Scope} scope
 * @param {string} variableName
 * @constructor
 */
function DebugVariable(scope, variableName) {
    /**
     * @type {Scope}
     */
    this.scope = scope;
    /**
     * @type {string}
     */
    this.variableName = variableName;
}

_.extend(DebugVariable.prototype, {
    /**
     * Fetches the value currently assigned to the variable this DebugVariable is tracking
     *
     * @returns {Value}
     */
    getValue: function () {
        var variable = this;

        return variable.scope.getVariable(variable.variableName).getValue();
    },

    /**
     * Determines whether the wrapped Value is defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        var variable = this;

        return variable.scope.getVariable(variable.variableName).isDefined();
    }
});

module.exports = DebugVariable;


/***/ }),

/***/ "./node_modules/phpcore/src/Debug/ValueFormatter.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/Debug/ValueFormatter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    /**
     * Formats the elements of an ArrayValue as a devtools formatter structure
     *
     * @param {ArrayValue} arrayValue
     * @param {DebugFactory} debugFactory
     * @returns {*[]}
     */
    formatArrayElements = function (arrayValue, debugFactory) {
        var elements = [
                'table',
                {}
            ];

        _.each(arrayValue.getKeys(), function (keyValue) {
            var element = arrayValue.getElementByKey(keyValue),
                keyString = keyValue.getNative();

            // Display the keys of elements with string keys in quotes
            if (keyValue.getType() === 'string') {
                keyString = '"' + keyString + '"';
            }

            elements.push([
                'tr',
                {},
                [
                    'td',
                    {
                        'style': 'font-weight: bold;'
                    },
                    // Prefix the key of elements that are references with an ampersand
                    (element.isReference() ? '&' : '') + keyString + ':'
                ],
                [
                    'td',
                    {},
                    // Format the element recursively with a DebugValue
                    // (custom object formatter should be called again if/when expanded in debugger)
                    ['object', {object: debugFactory.createValue(element.getValue())}]
                ]
            ]);
        });

        return elements;
    };

/**
 * Debugging value formatter for Chrome's Developer Tools
 *
 * @param {DebugFactory} debugFactory
 * @constructor
 */
function ValueFormatter(debugFactory) {
    /**
     * @type {DebugFactory}
     */
    this.debugFactory = debugFactory;
}

_.extend(ValueFormatter.prototype, {
    /**
     * Formats a value for display in Chrome's dev tools
     *
     * @param {Value} value
     * @returns {{headingStyle: string, headingValue: (string|number), attributes: object[]}}
     */
    format: function (value) {
        var attributes = [],
            formatter = this,
            headingValue = null,
            headingStyle = '',
            nativeValue = value.getNative(),
            prototype;

        if (value.getType() === 'array') {
            headingValue = 'Array[' + value.getLength() + ']';
            attributes.push(
                {
                    name: 'length',
                    value: value.getLength(),
                    style: 'color: blue;'
                },
                {
                    name: 'elements',
                    value: formatArrayElements(value, formatter.debugFactory)
                }
            );
        } else if (value.getType() === 'null') {
            headingValue = '<null>';
            headingStyle = 'font-weight: bold;';
        } else if (value.getType() === 'object') {
            if (value.getClassName() === 'JSObject') {
                attributes.push({
                    name: 'PHP class',
                    value: 'JSObject'
                });

                if (typeof nativeValue === 'function') {
                    headingValue = '<JS:function ' + nativeValue.name + '()>';

                    attributes.push({
                        name: 'JS class',
                        value: '(Function)'
                    });
                } else {
                    prototype = Object.getPrototypeOf(nativeValue);

                    if (prototype.constructor) {
                        headingValue = '<JS:' + prototype.constructor.name + '>';

                        attributes.push({
                            name: 'JS class',
                            value: prototype.constructor.name
                        });
                    } else {
                        headingValue = '<JS:Object>';

                        attributes.push({
                            name: 'JS class',
                            value: '(anonymous)'
                        });
                    }
                }
            } else {
                headingValue = '<' + value.getClassName() + '>';

                attributes.push({
                    name: 'class',
                    value: value.getClassName()
                });
            }
        } else if (
            value.getType() === 'int' ||
            value.getType() === 'float' ||
            value.getType() === 'boolean'
        ) {
            headingValue = nativeValue;
            headingStyle = 'color: blue;';
        } else if (value.getType() === 'string') {
            headingValue = '"' + nativeValue + '"';
            headingStyle = 'color: red;';
        }

        return {
            attributes: attributes,
            headingStyle: headingStyle,
            headingValue: headingValue
        };
    }
});

module.exports = ValueFormatter;


/***/ }),

/***/ "./node_modules/phpcore/src/Engine.js":
/*!********************************************!*\
  !*** ./node_modules/phpcore/src/Engine.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    PATH = 'path',
    Promise = __webpack_require__(/*! lie */ "./node_modules/lie/lib/browser.js"),
    ToolsWrapper = __webpack_require__(/*! ./Tools */ "./node_modules/phpcore/src/Tools.js"),
    ValueWrapper = __webpack_require__(/*! ./Value */ "./node_modules/phpcore/src/Value.js");

/**
 * Executes a transpiled PHP module
 *
 * @param {Environment} environment PHPCore environment to execute inside
 * @param {Scope|null} topLevelScope Scope for the top-level statements of the module
 * @param {Object} phpCommon
 * @param {Object} options Configuration options for this engine
 * @param {Function} wrapper The wrapper function for the transpiled PHP module
 * @param {Resumable|null} pausable Pausable library for async mode, null for psync or sync modes
 * @param {string} mode
 * @constructor
 */
function Engine(
    environment,
    topLevelScope,
    phpCommon,
    options,
    wrapper,
    pausable,
    mode
) {
    /**
     * @type {Environment}
     */
    this.environment = environment;
    /**
     * @type {string}
     */
    this.mode = mode;
    /**
     * @type {object}
     */
    this.options = _.extend(
        {
            'path': null
        },
        options || {}
    );
    /**
     * @type {Resumable}
     */
    this.pausable = pausable;
    /**
     * @type {Object}
     */
    this.phpCommon = phpCommon;
    /**
     * @type {Scope|null}
     */
    this.topLevelScope = topLevelScope || null;
    /**
     * @type {Function}
     */
    this.wrapper = wrapper;
}

_.extend(Engine.prototype, {
    /**
     * Defines the given alias for the given function
     *
     * @param {string} originalName
     * @param {string} aliasName
     */
    aliasFunction: function (originalName, aliasName) {
        this.environment.aliasFunction(originalName, aliasName);
    },

    /**
     * Creates a new FFI Result, to provide the result of a call to a JS function
     *
     * @param {Function} syncCallback
     * @param {Function|null} asyncCallback
     * @returns {FFIResult}
     */
    createFFIResult: function (syncCallback, asyncCallback) {
        return this.environment.createFFIResult(syncCallback, asyncCallback);
    },

    /**
     * Creates a Pause object for use in async mode
     *
     * @returns {PauseException}
     */
    createPause: function () {
        var engine = this;

        if (!engine.pausable) {
            throw new Error('Pausable is not available');
        }

        return engine.pausable.createPause();
    },

    /**
     * Defines a new class (in any namespace).
     * Note that the class will be defined on the current engine's environment,
     * so any other engines that share this environment will also see the new class
     *
     * @param {string} name FQCN for the class to define
     * @param {function} definitionFactory Called with `internals` object, returns the class definition
     * @returns {Class} Returns the instance of Class that represents a PHP class
     */
    defineClass: function (name, definitionFactory) {
        return this.environment.defineClass(name, definitionFactory);
    },

    /**
     * Defines a global function from a native JS one. If a fully-qualified name is provided
     * with a namespace prefix, eg. `My\Lib\MyFunc` then it will be defined in the specified namespace
     *
     * @param {string} name
     * @param {Function} fn
     */
    defineCoercingFunction: function (name, fn) {
        this.environment.defineCoercingFunction(name, fn);
    },

    /**
     * Defines a constant with the given native value
     *
     * @param {string} name
     * @param {*} value
     * @param {object} options
     */
    defineConstant: function (name, value, options) {
        this.environment.defineConstant(name, value, options);
    },

    /**
     * Defines a new function (in any namespace).
     * Note that the function will be defined on the current engine's environment,
     * so any other engines that share this environment will also see the new function
     *
     * @param {string} name Fully-qualified name for the function to define
     * @param {function} definitionFactory Called with `internals` object, returns the function definition
     * @returns {Class} Returns the defined function
     */
    defineFunction: function (name, definitionFactory) {
        return this.environment.defineFunction(name, definitionFactory);
    },

    /**
     * Defines a global variable and gives it the provided value
     *
     * @param {string} name
     * @param {*} nativeValue
     */
    defineGlobal: function (name, nativeValue) {
        var engine = this,
            valueFactory = engine.environment.getState().getValueFactory(),
            value = valueFactory.coerce(nativeValue);

        engine.environment.defineGlobal(name, value);
    },

    /**
     * Defines a global variable using a getter/setter pair
     *
     * @param {string} name
     * @param {Function} valueGetter
     * @param {Function} valueSetter
     */
    defineGlobalAccessor: function (name, valueGetter, valueSetter) {
        this.environment.defineGlobalAccessor(name, valueGetter, valueSetter);
    },

    /**
     * Defines a global function from a native JS one. If a fully-qualified name is provided
     * with a namespace prefix, eg. `My\Lib\MyFunc` then it will be defined in the specified namespace
     *
     * @param {string} name
     * @param {Function} fn
     */
    defineNonCoercingFunction: function (name, fn) {
        this.environment.defineNonCoercingFunction(name, fn);
    },

    /**
     * Defines a super global variable (available in all scopes implicitly,
     * unlike a normal global which is not available unless imported with a `global` statement)
     * and gives it the provided value. If a native value is given then it will be coerced to a PHP one.
     *
     * @param {string} name
     * @param {Value|*} value
     */
    defineSuperGlobal: function (name, value) {
        this.environment.defineSuperGlobal(name, value);
    },

    defineSuperGlobalAccessor: function (name, valueGetter, valueSetter) {
        this.environment.defineSuperGlobalAccessor(name, valueGetter, valueSetter);
    },

    /**
     * Executes this PHP script, returning either its resulting value if in synchronous mode
     * or a Promise if in asynchronous mode that will later be resolved with its resulting value
     * (from a top-level `return` statement, if any - otherwise defaulting to null)
     *
     * @returns {Promise|Value}
     */
    execute: function __uniterInboundStackMarker__() {
        var callFactory,
            callStack,
            engine = this,
            environment = engine.environment,
            errorReporting,
            globalNamespace,
            globalScope,
            loader,
            mode = engine.mode,
            module,
            moduleFactory,
            options = engine.options,
            path = options[PATH],
            isMainProgram = engine.topLevelScope === null,
            output,
            pausable = engine.pausable,
            phpCommon = engine.phpCommon,
            PHPError = phpCommon.PHPError,
            PHPParseError = phpCommon.PHPParseError,
            referenceFactory,
            resultValue,
            scopeFactory,
            state,
            stderr = engine.getStderr(),
            stdin = engine.getStdin(),
            tools,
            translator,
            valueFactory,
            wrapper = engine.wrapper,
            unwrap = function (wrapper) {
                return mode === 'async' ? wrapper.async(pausable) : wrapper.sync();
            },
            // TODO: Wrap this module with `pauser` to remove the need for this
            Tools = unwrap(ToolsWrapper),
            Value = unwrap(ValueWrapper),
            topLevelNamespaceScope,
            topLevelScope;

        state = environment.getState();
        callFactory = state.getCallFactory();
        errorReporting = state.getErrorReporting();
        loader = state.getLoader();
        moduleFactory = state.getModuleFactory();
        referenceFactory = state.getReferenceFactory();
        scopeFactory = state.getScopeFactory();
        valueFactory = state.getValueFactory();
        globalNamespace = state.getGlobalNamespace();
        callStack = state.getCallStack();
        globalScope = state.getGlobalScope();
        output = state.getOutput();
        // Use the provided top-level scope if specified, otherwise use the global scope
        // (used eg. when an `include(...)` is used inside a function)
        topLevelScope = engine.topLevelScope || globalScope;
        translator = state.getTranslator();
        module = moduleFactory.create(path);
        topLevelNamespaceScope = scopeFactory.createNamespaceScope(globalNamespace, globalNamespace, module);

        // Create the runtime tools object, referenced by the transpiled JS output from PHPToJS
        tools = new Tools(
            callStack,
            environment,
            translator,
            globalNamespace,
            loader,
            module,
            options,
            referenceFactory,
            scopeFactory,
            topLevelNamespaceScope,
            topLevelScope,
            valueFactory
        );

        // Push the 'main' global scope call onto the stack
        callStack.push(callFactory.create(topLevelScope, topLevelNamespaceScope));

        function handleError(error, reject) {
            var errorValue,
                trace;

            if (error instanceof Value && error.getType() === 'exit') {
                return error;
            }

            if (error instanceof Value && error.getType() === 'object') {
                if (!isMainProgram) {
                    // For included files/eval etc., just pass the Throwable up the call stack
                    reject(error);

                    return;
                }

                errorValue = error;
                error = errorValue.coerceToNativeError();
                trace = errorValue.getInternalProperty('trace');

                if (error instanceof PHPParseError) {
                    // ParseErrors are special - when they reach the top level scope,
                    // if nothing has caught them then they are displayed as
                    // "PHP Parse error: ..." rather than "PHP Fatal error: Uncaught ParseError ..."
                    errorReporting.reportError(
                        PHPError.E_PARSE,
                        errorValue.getProperty('message').getNative(),
                        errorValue.getProperty('file').getNative(),
                        errorValue.getProperty('line').getNative(),
                        trace,
                        false
                    );
                } else {
                    errorReporting.reportError(
                        PHPError.E_ERROR,
                        error.getMessage(),
                        errorValue.getProperty('file').getNative(),
                        errorValue.getProperty('line').getNative(),
                        trace,
                        errorValue.getInternalProperty('reportsOwnContext')
                    );
                }

                reject(error);

                return;
            }

            if (error instanceof PHPError) {
                // Some fatal errors are not catchable

                if (isMainProgram) {
                    errorReporting.reportError(
                        PHPError.E_ERROR,
                        error.getMessage(),
                        error.getFilePath(),
                        error.getLineNumber(),
                        null,
                        false
                    );
                }

                reject(error);
                return;
            }

            reject(error);
        }

        // Asynchronous mode - Pausable must be available
        if (mode === 'async') {
            return new Promise(function (resolve, reject) {
                var code = 'return (' +
                    wrapper.toString() +
                    '(stdin, stdout, stderr, tools, globalNamespace));';

                pausable.execute(code, {
                    strict: true,
                    expose: {
                        stdin: stdin,
                        stdout: output,
                        stderr: stderr,
                        tools: tools,
                        globalNamespace: globalNamespace
                    }
                }).then(function (resultValue) {
                    // Pop the top-level scope (of the include, if this module was included) off the stack
                    // regardless of whether an error occurred
                    callStack.pop();

                    resolve(resultValue);
                }, function (error) {
                    var result;

                    // Pop the top-level scope (of the include, if this module was included) off the stack
                    // regardless of whether an error occurred
                    callStack.pop();

                    result = handleError(error, reject);

                    if (result) {
                        resolve(result);
                    }
                });
            });
        }

        // Otherwise load the module synchronously
        try {
            try {
                resultValue = wrapper(stdin, output, stderr, tools, globalNamespace);

                return mode === 'psync' && isMainProgram ?
                    // Promise-sync mode - return a promise resolved with the result
                    Promise.resolve(resultValue) :

                    // Sync mode - just return the result, with no Promise involved
                    resultValue;
            } finally {
                // Pop the top-level scope (of the include, if this module was included) off the stack
                // regardless of whether an error occurred
                callStack.pop();
            }
        } catch (error) {
            if (mode === 'psync' && isMainProgram) {
                // Promise-sync mode - return a promise...

                return new Promise(function (resolve, reject) {
                    var resultValue = handleError(error, function (error) {
                        // ... rejected with the error if applicable
                        reject(error);
                    });

                    // Otherwise if it was a special ExitValue, resolve with it
                    if (resultValue) {
                        resolve(resultValue);
                    }
                });
            }

            return handleError(error, function (error) {
                throw error;
            });
        }
    },

    expose: function (object, name) {
        this.environment.expose(object, name);
    },

    getConstant: function (name) {
        return this.environment.getConstant(name);
    },

    /**
     * Fetches the value of a global variable, if defined.
     * If the variable is not defined then a NULL value will be returned.
     *
     * @param {string} name
     * @return {Value}
     */
    getGlobal: function (name) {
        return this.environment.getGlobal(name);
    },

    getStderr: function () {
        return this.environment.getStderr();
    },

    getStdin: function () {
        return this.environment.getStdin();
    },

    getStdout: function () {
        return this.environment.getStdout();
    },

    /**
     * Sets the value of an existing PHP global. If a native value is given
     * then it will be coerced to a PHP one.
     * If the global is not defined than an error will be thrown -
     * use .defineGlobal(...) when defining a new variable
     *
     * @param {string} name
     * @param {Value|*} value
     * @throws {Error} Throws if the variable is not defined in the global scope
     */
    setGlobal: function (name, value) {
        this.environment.setGlobal(name, value);
    },

    /**
     * Takes the given proxy and returns a new one with a synchronous API,
     * even in Promise-synchronous mode
     *
     * @param {ProxyClass} proxy
     * @return {ProxyClass}
     */
    toNativeWithSyncApi: function (proxy) {
        return this.environment.toNativeWithSyncApi(proxy);
    }
});

module.exports = Engine;


/***/ }),

/***/ "./node_modules/phpcore/src/Environment.js":
/*!*************************************************!*\
  !*** ./node_modules/phpcore/src/Environment.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError,
    PHPFatalError = phpCommon.PHPFatalError,
    PHPParseError = phpCommon.PHPParseError;

/**
 * @param {PHPState} state
 * @constructor
 */
function Environment(state) {
    /**
     * @type {PHPState}
     */
    this.state = state;
}

_.extend(Environment.prototype, {
    /**
     * Defines the given alias for the given function
     *
     * @param {string} originalName
     * @param {string} aliasName
     */
    aliasFunction: function (originalName, aliasName) {
        this.state.aliasFunction(originalName, aliasName);
    },

    /**
     * Creates a new FFI Result, to provide the result of a call to a JS function
     *
     * @param {Function} syncCallback
     * @param {Function|null} asyncCallback
     * @returns {FFIResult}
     */
    createFFIResult: function (syncCallback, asyncCallback) {
        return this.state.createFFIResult(syncCallback, asyncCallback);
    },

    /**
     * Defines a new class (in any namespace)
     *
     * @param {string} name FQCN for the class to define
     * @param {function} definitionFactory Called with `internals` object, returns the class definition
     * @returns {Class} Returns the instance of Class that represents a PHP class
     */
    defineClass: function (name, definitionFactory) {
        return this.state.defineClass(name, definitionFactory);
    },

    /**
     * Defines a global function from a native JS one. If a fully-qualified name is provided
     * with a namespace prefix, eg. `My\Lib\MyFunc` then it will be defined in the specified namespace
     *
     * @param {string} name
     * @param {Function} fn
     */
    defineCoercingFunction: function (name, fn) {
        this.state.defineCoercingFunction(name, fn);
    },

    /**
     * Defines a constant with the given native value
     *
     * @param {string} name
     * @param {*} value
     * @param {object} options
     */
    defineConstant: function (name, value, options) {
        this.state.defineConstant(name, value, options);
    },

    /**
     * Defines a new function (in any namespace).
     *
     * @param {string} name Fully-qualified name for the function to define
     * @param {function} definitionFactory Called with `internals` object, returns the function definition
     * @returns {Class} Returns the defined function
     */
    defineFunction: function (name, definitionFactory) {
        return this.state.defineFunction(name, definitionFactory);
    },

    /**
     * Defines a global variable and gives it the provided value
     *
     * @param {string} name
     * @param {Value} value
     */
    defineGlobal: function (name, value) {
        this.state.defineGlobal(name, value);
    },

    /**
     * Defines a global variable using a getter/setter pair
     *
     * @param {string} name
     * @param {Function} valueGetter
     * @param {Function} valueSetter
     */
    defineGlobalAccessor: function (name, valueGetter, valueSetter) {
        this.state.defineGlobalAccessor(name, valueGetter, valueSetter);
    },

    /**
     * Defines a global function from a native JS one. If a fully-qualified name is provided
     * with a namespace prefix, eg. `My\Lib\MyFunc` then it will be defined in the specified namespace
     *
     * @param {string} name
     * @param {Function} fn
     */
    defineNonCoercingFunction: function (name, fn) {
        this.state.defineNonCoercingFunction(name, fn);
    },

    /**
     * Defines a super global variable (available in all scopes implicitly,
     * unlike a normal global which is not available unless imported with a `global` statement)
     * and gives it the provided value. If a native value is given then it will be coerced to a PHP one.
     *
     * @param {string} name
     * @param {Value|*} value
     */
    defineSuperGlobal: function (name, value) {
        this.state.defineSuperGlobal(name, value);
    },

    defineSuperGlobalAccessor: function (name, valueGetter, valueSetter) {
        this.state.defineSuperGlobalAccessor(name, valueGetter, valueSetter);
    },

    expose: function (object, name) {
        this.state.getGlobalScope().expose(object, name);
    },

    getConstant: function (name) {
        return this.state.getConstant(name);
    },

    /**
     * Fetches the value of a global variable, if defined.
     * If the variable is not defined then a NULL value will be returned.
     *
     * @param {string} name
     * @return {Value}
     */
    getGlobal: function (name) {
        return this.state.getGlobal(name);
    },

    getOptions: function () {
        return this.state.getOptions();
    },

    getState: function () {
        return this.state;
    },

    getStderr: function () {
        return this.state.getStderr();
    },

    getStdin: function () {
        return this.state.getStdin();
    },

    getStdout: function () {
        return this.state.getStdout();
    },

    /**
     * Reports a PHPError (fatal or parse error) originating from the parser or transpiler
     *
     * @param {PHPError} error
     * @throws {Error} Throws if a non-PHPError is given
     */
    reportError: function (error) {
        var errorReporting = this.state.getErrorReporting();

        // Handle any PHP errors from the transpiler or parser using the ErrorReporting
        // mechanism for PHPCore (as INI settings such as `display_errors` should take effect)
        if (error instanceof PHPFatalError) {
            errorReporting.reportError(
                PHPError.E_ERROR,
                error.getMessage(),
                error.getFilePath(),
                error.getLineNumber(),
                null,
                false
            );
        } else if (error instanceof PHPParseError) {
            errorReporting.reportError(
                PHPError.E_PARSE,
                error.getMessage(),
                error.getFilePath(),
                error.getLineNumber(),
                null,
                false
            );
        } else {
            throw new Error('Invalid error type given');
        }
    },

    /**
     * Sets the value of an existing PHP global. If a native value is given
     * then it will be coerced to a PHP one.
     * If the global is not defined than an error will be thrown -
     * use .defineGlobal(...) when defining a new variable
     *
     * @param {string} name
     * @param {Value|*} value
     * @throws {Error} Throws if the variable is not defined in the global scope
     */
    setGlobal: function (name, value) {
        this.state.setGlobal(name, value);
    },

    /**
     * Takes the given proxy and returns a new one with a synchronous API,
     * even in Promise-synchronous mode
     *
     * @param {ProxyClass} proxy
     * @return {ProxyClass}
     */
    toNativeWithSyncApi: function (proxy) {
        return this.state.getFFIValueHelper().toNativeWithSyncApi(proxy);
    }
});

module.exports = Environment;


/***/ }),

/***/ "./node_modules/phpcore/src/Error/ErrorConfiguration.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpcore/src/Error/ErrorConfiguration.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Handles the configuration for error handling in PHP-land
 *
 * @param {INIState} iniState
 * @constructor
 */
function ErrorConfiguration(iniState) {
    /**
     * @type {INIState}
     */
    this.iniState = iniState;
}

_.extend(ErrorConfiguration.prototype, {
    /**
     * Determines whether errors should be displayed
     *
     * @returns {boolean}
     */
    getDisplayErrors: function () {
        var iniOption = this.iniState.get('display_errors');

        return String(iniOption).toLowerCase() !== 'off' && !!iniOption;
    },

    /**
     * Fetches a bitmask of which error levels to report
     * (set by the error_reporting(...) builtin function and "error_reporting" INI option)
     *
     * @returns {number}
     */
    getErrorReportingLevel: function () {
        return parseInt(this.iniState.get('error_reporting'), 10);
    },

    /**
     * Sets the error reporting level (may be a non-integer even though only integer is valid)
     *
     * @param {number|*} level
     */
    setErrorReportingLevel: function (level) {
        this.iniState.set('error_reporting', level);
    }
});

module.exports = ErrorConfiguration;


/***/ }),

/***/ "./node_modules/phpcore/src/Error/ErrorConverter.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/Error/ErrorConverter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError,
    // Maps the error type PHP constant name to the internal PHPError type that should be raised
    ERROR_CONSTANT_NAME_TO_LEVEL = {
        'E_ERROR': PHPError.E_ERROR,
        'E_WARNING': PHPError.E_WARNING,
        'E_PARSE': PHPError.E_PARSE,
        'E_NOTICE': PHPError.E_NOTICE,
        'E_STRICT': PHPError.E_STRICT,
        'E_RECOVERABLE_ERROR': PHPError.E_RECOVERABLE_ERROR,
        'E_DEPRECATED': PHPError.E_DEPRECATED
    };

/**
 * Converts between Uniter error levels and the PHP constant error level values
 *
 * @param {Function} getConstant
 * @constructor
 */
function ErrorConverter(getConstant) {
    /**
     * @type {Function}
     */
    this.getConstant = getConstant;
}

_.extend(ErrorConverter.prototype, {
    /**
     * Converts from a Uniter error level string to the PHP integer value (E_* constant)
     *
     * @param {string} level
     * @returns {number}
     */
    errorLevelToBits: function (level) {
        var bits = null,
            converter = this;

        _.forOwn(ERROR_CONSTANT_NAME_TO_LEVEL, function (candidateLevel, constantName) {
            if (candidateLevel !== level) {
                return;
            }

            bits = converter.getConstant(constantName);

            return false;
        });

        if (bits === null) {
            throw new Error('Unknown error level "' + level + '"');
        }

        return bits;
    }
});

module.exports = ErrorConverter;


/***/ }),

/***/ "./node_modules/phpcore/src/Error/ErrorPromoter.js":
/*!*********************************************************!*\
  !*** ./node_modules/phpcore/src/Error/ErrorPromoter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError;

/**
 * Handles taking an ObjectValue containing an Error instance, raises it via the ErrorReporting mechanism
 * and then returns a native error constructed from its contents
 *
 * @param {ErrorReporting} errorReporting
 * @constructor
 */
function ErrorPromoter(errorReporting) {
    /**
     * @type {ErrorReporting}
     */
    this.errorReporting = errorReporting;
}

_.extend(ErrorPromoter.prototype, {
    /**
     * Reports the specified error message to stdout, stderr, both or neither
     * depending on its level and the current error_reporting level/display_errors configured
     *
     * @param {ObjectValue} errorValue
     * @returns {Error}
     */
    promote: function (errorValue) {
        var nativeError = errorValue.coerceToNativeError(),
            promoter = this,
            trace = errorValue.getInternalProperty('trace');

        if (errorValue.classIs('ParseError')) {
            // ParseErrors are special - when they reach the top level scope,
            // if nothing has caught them then they are displayed as
            // "PHP Parse error: ..." rather than "PHP Fatal error: Uncaught ParseError ..."
            promoter.errorReporting.reportError(
                PHPError.E_PARSE,
                errorValue.getProperty('message').getNative(),
                errorValue.getProperty('file').getNative(),
                errorValue.getProperty('line').getNative(),
                trace,
                false
            );
        } else {
            promoter.errorReporting.reportError(
                PHPError.E_ERROR,
                nativeError.getMessage(),
                errorValue.getProperty('file').getNative(),
                errorValue.getProperty('line').getNative(),
                trace,
                errorValue.getInternalProperty('reportsOwnContext')
            );
        }

        return nativeError;
    }
});

module.exports = ErrorPromoter;


/***/ }),

/***/ "./node_modules/phpcore/src/Error/ErrorReporting.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/Error/ErrorReporting.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError,

    ERROR_WITH_CONTEXT_AND_TRACE = 'core.error_with_context_and_trace',
    ERROR_WITHOUT_CONTEXT_BUT_WITH_TRACE = 'core.error_without_context_but_with_trace',
    ERROR_WITHOUT_TRACE = 'core.error_without_trace',
    UNKNOWN = 'core.unknown';

/**
 * Handles the final output of error messages to the standard streams,
 * based on the current configuration
 *
 * @param {ErrorConfiguration} errorConfiguration
 * @param {ErrorConverter} errorConverter
 * @param {TraceFormatter} traceFormatter
 * @param {Translator} translator
 * @param {Stream} stdout
 * @param {Stream} stderr
 * @constructor
 */
function ErrorReporting(
    errorConfiguration,
    errorConverter,
    traceFormatter,
    translator,
    stdout,
    stderr
) {
    /**
     * @type {ErrorConfiguration}
     */
    this.errorConfiguration = errorConfiguration;
    /**
     * @type {ErrorConverter}
     */
    this.errorConverter = errorConverter;
    /**
     * @type {Stream}
     */
    this.stderr = stderr;
    /**
     * @type {Stream}
     */
    this.stdout = stdout;
    /**
     * @type {TraceFormatter}
     */
    this.traceFormatter = traceFormatter;
    /**
     * @type {Translator}
     */
    this.translator = translator;
}

_.extend(ErrorReporting.prototype, {
    /**
     * Reports the specified error message to stdout, stderr, both or neither
     * depending on its level and the current error_reporting level/display_errors configured
     *
     * @param {string} level
     * @param {string} message
     * @param {string|null=} filePath
     * @param {number|null=} lineNumber
     * @param {{index: number, file: string, line: number, func: Function, args: *[]}[]=} trace
     * @param {boolean} reportsOwnContext Whether the error handles reporting its own file/line context
     */
    reportError: function (level, message, filePath, lineNumber, trace, reportsOwnContext) {
        var errorReporting = this,
            displayErrors = errorReporting.errorConfiguration.getDisplayErrors(),
            allowedErrorBitmask = errorReporting.errorConfiguration.getErrorReportingLevel(),
            levelBits = errorReporting.errorConverter.errorLevelToBits(level),
            formattedTrace,
            normalisedLineNumber = lineNumber || errorReporting.translator.translate(UNKNOWN),
            normalisedFilePath = filePath || errorReporting.translator.translate(UNKNOWN),
            suffix;

        /*jshint bitwise: false */
        if ((allowedErrorBitmask & levelBits) === 0) {
            // This error level is not enabled for reporting: do nothing
            return;
        }

        // When written to one of the standard streams, the file/line combo is provided
        // in a colon-separated format rather than the verbose "in ... on line ..."

        if (level === PHPError.E_ERROR && trace) {
            formattedTrace = trace ? errorReporting.traceFormatter.format(trace) : null;

            if (reportsOwnContext) {
                suffix = errorReporting.translator.translate(ERROR_WITHOUT_CONTEXT_BUT_WITH_TRACE, {
                    filePath: normalisedFilePath,
                    line: normalisedLineNumber,
                    formattedTrace: formattedTrace
                });
            } else {
                suffix = errorReporting.translator.translate(ERROR_WITH_CONTEXT_AND_TRACE, {
                    filePath: normalisedFilePath,
                    line: normalisedLineNumber,
                    formattedTrace: formattedTrace
                });
            }
        } else {
            if (reportsOwnContext) {
                suffix = '';
            } else {
                suffix = errorReporting.translator.translate(ERROR_WITHOUT_TRACE, {
                    filePath: normalisedFilePath,
                    line: normalisedLineNumber
                });
            }
        }

        // NB: The double-space after colon is intentional, to match the reference implementation
        errorReporting.stderr.write('PHP ' + level + ':  ' + message + suffix + '\n');

        if (displayErrors) {
            errorReporting.stdout.write('\n' + level + ': ' + message + suffix + '\n');
        }
    }
});

module.exports = ErrorReporting;


/***/ }),

/***/ "./node_modules/phpcore/src/Error/TraceFormatter.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/Error/TraceFormatter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    UNKNOWN = 'core.unknown';

/**
 * Standard way to convert a call stack trace (returned by CallStack.getTrace())
 * to a printable formatted form. Used by Error::getTraceAsString(), Exception::getTraceAsString()
 * and when an uncaught fatal error is written to stdout/stderr.
 *
 * @param {Translator} translator
 * @constructor
 */
function TraceFormatter(translator) {
    /**
     * @type {Translator}
     */
    this.translator = translator;
}

_.extend(TraceFormatter.prototype, {
    /**
     * Formats a call stack trace to a string
     *
     * @param {{index: number, file: string, line: number, func: Function, args: *[]}[]} trace
     * @returns {string}
     */
    format: function (trace) {
        var formatter = this,
            traceStrings = [];

        _.each(trace, function (callData) {
            // Convert arguments to a string representation
            var args = _.map(callData.args, function (argValue) {
                return argValue.formatAsString();
            }),
                line = callData.line || formatter.translator.translate(UNKNOWN);

            traceStrings.push(
                '#' + callData.index + ' ' + callData.file + '(' + line + '): ' +
                callData.func + '(' + args.join(', ') + ')'
            );
        });

        traceStrings.push('#' + trace.length + ' {main}');

        return traceStrings.join('\n');
    }
});

module.exports = TraceFormatter;


/***/ }),

/***/ "./node_modules/phpcore/src/Exception/LoadFailedException.js":
/*!*******************************************************************!*\
  !*** ./node_modules/phpcore/src/Exception/LoadFailedException.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Exception = phpCommon.Exception;

/**
 * Represents a failed load operation. Loads may be made by an include/require or an eval(...)
 *
 * @param {Error} previousError
 * @constructor
 */
function LoadFailedException(previousError) {
    Exception.call(this, 'Load failed' + (previousError ? ' :: ' + previousError.message : ''));

    /**
     * @type {Error}
     */
    this.previousError = previousError;
}

util.inherits(LoadFailedException, Exception);

_.extend(LoadFailedException.prototype, {
    /**
     * Fetches the previous error or exception that caused the load to fail
     *
     * @returns {Error}
     */
    getPreviousError: function () {
        return this.previousError;
    }
});

module.exports = LoadFailedException;


/***/ }),

/***/ "./node_modules/phpcore/src/Exception/NoActiveOutputBufferException.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/phpcore/src/Exception/NoActiveOutputBufferException.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Exception = phpCommon.Exception;

/**
 * Represents an attempt to fetch or pop the active output buffer when none is active
 *
 * @constructor
 */
function NoActiveOutputBufferException() {
    Exception.call(this, 'No output buffer is active');
}

util.inherits(NoActiveOutputBufferException, Exception);

module.exports = NoActiveOutputBufferException;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Call.js":
/*!**********************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Call.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {Value[]} args
 * @constructor
 */
function Call(args) {
    /**
     * @type {Reference[]|Value[]|Variable[]}
     */
    this.args = args;
}

_.extend(Call.prototype, {
    /**
     * Fetches the current class for the call, if any
     *
     * @returns {Class|null}
     */
    getCurrentClass: function () {
        return null;
    },

    /**
     * Fetches the path to the file this call was made from
     *
     * @returns {string|null}
     */
    getFilePath: function () {
        return '(JavaScript code)';
    },

    /**
     * Fetches the Value objects passed as arguments to the called function
     *
     * @returns {Value[]}
     */
    getFunctionArgs: function () {
        return this.args;
    },

    /**
     * Fetches the name of the current function
     *
     * @returns {string}
     */
    getFunctionName: function () {
        return '(JavaScript function)';
    },

    /**
     * Fetches the number of the last line executed inside this call's scope
     *
     * @returns {number|null}
     */
    getLastLine: function () {
        return null;
    },

    /**
     * Fetches the scope inside the called function
     *
     * @returns {Scope}
     */
    getScope: function () {
        return null;
    },

    /**
     * Fetches the static class introduced by this call's scope. If null,
     * the call was a forwarding call, and so the parent call's static class should be used
     *
     * @returns {Class|null}
     */
    getStaticClass: function () {
        return null;
    },

    /**
     * Fetches the ObjectValue that is the current `$this` object, if any
     *
     * @returns {ObjectValue|null}
     */
    getThisObject: function () {
        return null;
    },

    /**
     * Fetches the path to the file this call was made from, suitable for stack traces (so without any eval context)
     *
     * @returns {string|null}
     */
    getTraceFilePath: function () {
        return '(JavaScript code)';
    },

    /**
     * Registers a finder for looking up the current/last line number inside the called function
     */
    instrument: function () {
        throw new Error('Unable to instrument an FFI Call');
    },

    /**
     * Determines whether this call is a userland call (from inside PHP-land) or not
     *
     * @returns {boolean}
     */
    isUserland: function () {
        return false;
    },

    /**
     * Determines whether all errors should be suppressed for this call
     *
     * @returns {boolean}
     */
    suppressesErrors: function () {
        return false;
    },

    /**
     * Determines whether own errors should be suppressed for this call
     *
     * @returns {boolean}
     */
    suppressesOwnErrors: function () {
        return false;
    }
});

module.exports = Call;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Call/Caller.js":
/*!*****************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Call/Caller.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ../Call */ "./node_modules/phpcore/src/FFI/Call.js"),
    __webpack_require__(/*! lie */ "./node_modules/lie/lib/browser.js"),
    __webpack_require__(/*! ../../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    phpCommon,
    FFICall,
    Promise,
    Value
) {
    var Exception = phpCommon.Exception;

    /**
     * Encapsulates calling a PHP-land method from JS-land using the FFI API
     *
     * @param {CallFactory} callFactory
     * @param {CallStack} callStack
     * @param {ErrorPromoter} errorPromoter
     * @param {Resumable|null} pausable
     * @param {string} mode
     * @constructor
     */
    function Caller(
        callFactory,
        callStack,
        errorPromoter,
        pausable,
        mode
    ) {
        /**
         * @type {CallFactory}
         */
        this.callFactory = callFactory;
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {ErrorPromoter}
         */
        this.errorPromoter = errorPromoter;
        /**
         * @type {string}
         */
        this.mode = mode;
        /**
         * @type {Resumable|null}
         */
        this.pausable = pausable;
    }

    _.extend(Caller.prototype, {
        /**
         * Calls a method in asynchronous mode
         *
         * @param {ObjectValue} objectValue
         * @param {string} methodName
         * @param {Value[]} args
         * @returns {Promise<Value>}
         */
        callMethodAsync: function (objectValue, methodName, args) {
            var caller = this;

            if (caller.mode !== 'async') {
                throw new Exception('Caller.callMethodAsync() :: Must be in async mode');
            }

            // Call the method via Pausable to allow for blocking operation
            return caller.pausable.call(
                objectValue.callMethod,
                [methodName, args],
                objectValue
            )
                // Pop the call off the stack _before_ returning, to mirror sync mode's behaviour
                .finally(caller.popFFICall.bind(caller))
                .catch(function (error) {
                    if (error instanceof Value && error.getType() === 'object') {
                        // Method threw a PHP Exception, so throw a native JS error for it
                        throw caller.errorPromoter.promote(error);
                    }

                    // Normal error: just pass it up to the caller
                    throw error;
                });
        },

        /**
         * Calls a method in either Promise-synchronous (psync) or synchronous (sync) mode.
         * If in psync mode, useSyncApiAlthoughPsync may be passed as true, in which case
         * the API will be presented in a synchronous fashion without Promises.
         *
         * @param {ObjectValue} objectValue
         * @param {string} methodName
         * @param {Value[]} args
         * @param {boolean=} useSyncApiAlthoughPsync
         * @returns {Promise<Value>|Value}
         */
        callMethodSyncLike: function (objectValue, methodName, args, useSyncApiAlthoughPsync) {
            var caller = this;

            if (caller.mode === 'async') {
                throw new Exception('callMethodSyncLike() :: Cannot call in async mode');
            }

            function invoke() {
                try {
                    return objectValue.callMethod(methodName, args);
                } catch (error) {
                    if (error instanceof Value && error.getType() === 'object') {
                        // Method threw a PHP Exception, so throw a native JS error for it
                        throw caller.errorPromoter.promote(error);
                    }

                    throw error;
                } finally {
                    caller.popFFICall();
                }
            }

            if (caller.mode === 'psync' && !useSyncApiAlthoughPsync) {
                // For Promise-synchronous mode, we need to return a promise
                // even though the actual invocation must return synchronously
                return new Promise(function (resolve, reject) {
                    try {
                        resolve(invoke());
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Otherwise we're in sync mode (or psync mode with sync API explicitly requested)
            return invoke();
        },

        /**
         * Pushes an FFI call onto the call stack
         *
         * @param {Value[]} args
         */
        pushFFICall: function (args) {
            var caller = this;

            // Push an FFI call onto the stack, representing the call from JavaScript-land
            caller.callStack.push(caller.callFactory.createFFICall(args));
        },

        /**
         * Pops the FFI call off of the call stack
         */
        popFFICall: function () {
            var caller = this;

            if (!(caller.callStack.getCurrent() instanceof FFICall)) {
                throw new Exception('Caller.popFFICall() :: Current call is not an FFI call');
            }

            caller.callStack.pop();
        }
    });

    return Caller;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Call/NativeCaller.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Call/NativeCaller.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    /**
     * @param {Caller} caller
     * @param {string} mode
     * @constructor
     */
    function NativeCaller(caller, mode) {
        /**
         * @type {Caller}
         */
        this.caller = caller;
        /**
         * @type {string}
         */
        this.mode = mode;
    }

    _.extend(NativeCaller.prototype, {
        /**
         * Encapsulates calling a PHP-land method from JS-land using the FFI API,
         * unwrapping the result to a native value
         *
         * @param {ObjectValue} objectValue
         * @param {string} methodName
         * @param {Value[]} args
         * @param {boolean=} useSyncApiAlthoughPsync
         * @returns {Promise<*>|*}
         */
        callMethod: function (objectValue, methodName, args, useSyncApiAlthoughPsync) {
            var nativeCaller = this,
                result;

            // Push an FFI call onto the stack, representing the call from JavaScript-land
            nativeCaller.caller.pushFFICall(args);

            if (nativeCaller.mode === 'async') {
                return nativeCaller.caller.callMethodAsync(objectValue, methodName, args)
                    .then(function (resultValue) {
                        return resultValue.getNative();
                    });
            }

            // Otherwise we're in sync or psync mode
            result = nativeCaller.caller.callMethodSyncLike(objectValue, methodName, args, useSyncApiAlthoughPsync);

            return nativeCaller.mode === 'psync' && !useSyncApiAlthoughPsync ?
                result.then(function (resultValue) {
                    return resultValue.getNative();
                }) :
                result.getNative();
        }
    });

    return NativeCaller;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Call/ValueCaller.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Call/ValueCaller.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    /**
     * @param {Caller} caller
     * @param {string} mode
     * @constructor
     */
    function ValueCaller(caller, mode) {
        /**
         * @type {Caller}
         */
        this.caller = caller;
        /**
         * @type {string}
         */
        this.mode = mode;
    }

    _.extend(ValueCaller.prototype, {
        /**
         * Encapsulates calling a PHP-land method from JS-land using the FFI API,
         * returning the result as a Value object
         *
         * @param {ObjectValue} objectValue
         * @param {string} methodName
         * @param {Value[]} args
         * @param {boolean=} useSyncApiAlthoughPsync
         * @returns {Promise<Value>|Value}
         */
        callMethod: function (objectValue, methodName, args, useSyncApiAlthoughPsync) {
            var valueCaller = this;

            // Push an FFI call onto the stack, representing the call from JavaScript-land
            valueCaller.caller.pushFFICall(args);

            if (valueCaller.mode === 'async') {
                // Unlike NativeCaller, do not coerce to native here
                return valueCaller.caller.callMethodAsync(objectValue, methodName, args);
            }

            // Otherwise we're in sync or psync mode
            return valueCaller.caller.callMethodSyncLike(objectValue, methodName, args, useSyncApiAlthoughPsync);
        }
    });

    return ValueCaller;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Export/ExportFactory.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Export/ExportFactory.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Fetches the exported value for an FFIObjectValue, creating and caching it if needed
 *
 * @param {UnwrapperRepository} unwrapperRepository
 * @param {ProxyFactory} proxyFactory
 * @constructor
 */
function ExportFactory(unwrapperRepository, proxyFactory) {
    /**
     * @type {ProxyFactory}
     */
    this.proxyFactory = proxyFactory;
    /**
     * @type {UnwrapperRepository}
     */
    this.unwrapperRepository = unwrapperRepository;
}

_.extend(ExportFactory.prototype, {
    /**
     * Creates an exported value for the object value that the wrapped reference points to.
     * If a custom unwrapper has been defined for its class then that will be used instead.
     *
     * @param {ObjectValue} objectValue
     * @returns {Object|*}
     */
    create: function (objectValue) {
        var classObject = objectValue.getClass(),
            coercedObject,
            factory = this,
            unwrapper = factory.unwrapperRepository.getUnwrapperForClass(classObject);

        if (unwrapper !== null) {
            // A custom unwrapper has been defined for the class of this object

            // In auto-coercing mode, provide the native object, otherwise the object value
            coercedObject = objectValue.getThisObject();

            // Provide the object as both the thisObj and the first argument for ease of use
            return unwrapper.call(coercedObject, coercedObject);
        }

        // No custom unwrapper has been defined, use a generated ProxyClass
        return factory.proxyFactory.create(objectValue);
    }
});

module.exports = ExportFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Export/ExportRepository.js":
/*!*****************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Export/ExportRepository.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Fetches the exported value for an ObjectValue, creating and caching it if needed
 *
 * @param {ExportFactory} exportFactory
 * @param {ValueStorage} valueStorage
 * @constructor
 */
function ExportRepository(exportFactory, valueStorage) {
    /**
     * @type {ExportFactory}
     */
    this.exportFactory = exportFactory;
    /**
     * @type {ValueStorage}
     */
    this.valueStorage = valueStorage;
}

_.extend(ExportRepository.prototype, {
    /**
     * Fetches an exported native object for the given object value
     *
     * @param {ObjectValue} objectValue
     * @returns {Object|*}
     */
    export: function (objectValue) {
        var exportedValue,
            repository = this;

        if (repository.valueStorage.hasExportForObjectValue(objectValue)) {
            // Cache the exported value for each ObjectValue for identity and to save on memory
            return repository.valueStorage.getExportForObjectValue(objectValue);
        }

        exportedValue = repository.exportFactory.create(objectValue);

        // Allow us to always map the source object value to this same exported value
        repository.valueStorage.setExportForObjectValue(objectValue, exportedValue);

        /*
         * If the exported value is an object that is ever passed back into PHP-land,
         * allow us to map it back to the source object value.
         * If a primitive value is exported instead then we can ignore, as it will just
         * be coerced to and from its native value and a scalar value object
         */
        if (typeof exportedValue === 'object' && exportedValue !== null) {
            repository.valueStorage.setObjectValueForExport(exportedValue, objectValue);
        }

        return exportedValue;
    }
});

module.exports = ExportRepository;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Export/UnwrapperRepository.js":
/*!********************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Export/UnwrapperRepository.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    WeakMap = __webpack_require__(/*! es6-weak-map */ "./node_modules/es6-weak-map/index.js");

/**
 * Stores custom unwrappers for classes. When later fetched, if a class does not define
 * an unwrapper on itself, its ancestry will be checked to see if any ancestor does,
 * in which case that unwrapper will be used.
 *
 * @constructor
 */
function UnwrapperRepository() {
    /**
     * @type {WeakMap<object, Function>}
     */
    this.classToUnwrapperMap = new WeakMap();
}

_.extend(UnwrapperRepository.prototype, {
    /**
     * Defines a custom unwrapper for a class
     *
     * @param {Class} classObject
     * @param {Function} unwrapper
     */
    defineUnwrapper: function (classObject, unwrapper) {
        this.classToUnwrapperMap.set(classObject, unwrapper);
    },

    /**
     * Fetches the custom unwrapper for the class or an ancestor if defined
     *
     * @param {Class} classObject
     * @returns {Function|null}
     */
    getUnwrapperForClass: function (classObject) {
        var currentClass = classObject,
            repository = this,
            unwrapper = null;

        while (currentClass !== null) {
            if (repository.classToUnwrapperMap.has(currentClass)) {
                // A custom unwrapper has been defined for the class
                return repository.classToUnwrapperMap.get(currentClass);
            }

            // Now check whether any interfaces implemented directly by the class define an unwrapper
            /*jshint loopfunc: true */
            if (currentClass.getInterfaces().some(function (interfaceObject) {
                unwrapper = repository.getUnwrapperForClass(interfaceObject);

                if (unwrapper !== null) {
                    // A custom unwrapper has been defined for the interface (or somewhere in its ancestry)

                    return true; // No need to keep checking
                }
            })) {
                return unwrapper;
            }

            currentClass = currentClass.getSuperClass();
        }

        // No custom unwrapper has been defined
        return null;
    }
});

module.exports = UnwrapperRepository;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/FFIFactory.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/FFIFactory.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {class} AsyncObjectValue
 * @param {class} PHPObject
 * @param {class} ValueCoercer
 * @param {ValueFactory} valueFactory
 * @param {CallStack} callStack
 * @param {NativeCaller} nativeCaller
 * @param {ValueCaller} valueCaller
 * @constructor
 */
function FFIFactory(
    AsyncObjectValue,
    PHPObject,
    ValueCoercer,
    valueFactory,
    callStack,
    nativeCaller,
    valueCaller
) {
    /**
     * @type {class}
     */
    this.AsyncObjectValue = AsyncObjectValue;
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {Object.<boolean, ValueCoercer}
     */
    this.modeToValueCoercerMap = {};
    /**
     * @type {NativeCaller}
     */
    this.nativeCaller = nativeCaller;
    /**
     * @type {class}
     */
    this.PHPObject = PHPObject;
    /**
     * @type {ValueCaller}
     */
    this.valueCaller = valueCaller;
    /**
     * @type {class}
     */
    this.ValueCoercer = ValueCoercer;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(FFIFactory.prototype, {
    /**
     * Creates an AsyncObjectValue that wraps the given ObjectValue
     *
     * @param {ObjectValue} wrappedObjectValue
     * @returns {AsyncObjectValue}
     */
    createAsyncObjectValue: function (wrappedObjectValue) {
        var factory = this;

        return new factory.AsyncObjectValue(
            factory.valueFactory,
            factory.callStack,
            factory.valueCaller,
            wrappedObjectValue
        );
    },

    /**
     * Creates a PHPObject, which wraps an ObjectValue and allows its methods
     * to be called and passed native values for its parameter arguments
     * and coerces its return value back to a native too.
     *
     * @param {ObjectValue} objectValue
     * @returns {PHPObject}
     */
    createPHPObject: function (objectValue) {
        var factory = this;

        return new factory.PHPObject(factory.valueFactory, factory.nativeCaller, objectValue);
    },

    /**
     * Fetches a value coercer for the given configuration. Note that as there are only
     * two possible modes, the instances are cached on first fetch to save memory usage.
     *
     * @param {boolean} autoCoercionEnabled
     * @returns {ValueCoercer}
     */
    createValueCoercer: function (autoCoercionEnabled) {
        var factory = this;

        if (!factory.modeToValueCoercerMap[autoCoercionEnabled]) {
            factory.modeToValueCoercerMap[autoCoercionEnabled] = new factory.ValueCoercer(autoCoercionEnabled);
        }

        return factory.modeToValueCoercerMap[autoCoercionEnabled];
    }
});

module.exports = FFIFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Internals/ClassInternalsClassFactory.js":
/*!******************************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Internals/ClassInternalsClassFactory.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    Exception = phpCommon.Exception;

/**
 * @param {Internals} baseInternals
 * @param {UnwrapperRepository} unwrapperRepository
 * @param {ValueFactory} valueFactory
 * @param {Namespace} globalNamespace
 * @param {NamespaceScope} globalNamespaceScope
 * @constructor
 */
function ClassInternalsClassFactory(
    baseInternals,
    unwrapperRepository,
    valueFactory,
    globalNamespace,
    globalNamespaceScope
) {
    /**
     * @type {Internals}
     */
    this.baseInternals = baseInternals;
    /**
     * @type {Namespace}
     */
    this.globalNamespace = globalNamespace;
    /**
     * @type {NamespaceScope}
     */
    this.globalNamespaceScope = globalNamespaceScope;
    /**
     * @type {UnwrapperRepository}
     */
    this.unwrapperRepository = unwrapperRepository;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(ClassInternalsClassFactory.prototype, {
    /**
     * Creates a ClassInternals class for use when defining a class using JS
     *
     * @return {class}
     */
    create: function () {
        var factory = this;

        /**
         * @param {string} fqcn
         * @constructor
         */
        function ClassInternals(fqcn) {
            /**
             * @type {string[]}
             */
            this.definedInterfaceNames = [];
            /**
             * @type {boolean}
             */
            this.enableAutoCoercion = true;
            /**
             * @type {string}
             */
            this.fqcn = fqcn;
            /**
             * @type {Class|null}
             */
            this.superClass = null;
            /**
             * @type {Function|null}
             */
            this.unwrapper = null;
        }

        // Extend the base Internals object so we inherit all the public service properties etc.
        ClassInternals.prototype = Object.create(factory.baseInternals);

        _.extend(ClassInternals.prototype, {
            /**
             * Calls the constructor for the superclass of this class, if this class extends another
             *
             * @param {ObjectValue|object} instance Object instance (see below)
             * @param {Value[]|*[]} args Arguments (Value objects if non-coercing, native if coercing)
             */
            callSuperConstructor: function (instance, args) {
                var argValues,
                    instanceValue,
                    internals = this;

                if (!internals.superClass) {
                    throw new Exception(
                        'Cannot call superconstructor: no superclass is defined for class "' + internals.fqcn + '"'
                    );
                }

                if (!args) {
                    args = [];
                }

                /*
                 * If the class is in auto-coercing mode, `instance` will be the native
                 * object value. If the class is in non-coercing mode, `instance` will be
                 * an ObjectValue wrapping the instance, so we need to coerce what we are passed
                 * to make sure it is an ObjectValue as expected by Class.prototype.construct(...).
                 * The same applies to the arguments list.
                 */
                if (internals.enableAutoCoercion) {
                    instanceValue = factory.valueFactory.coerce(instance);

                    argValues = _.map(args, function (nativeArg) {
                        return factory.valueFactory.coerce(nativeArg);
                    });
                } else {
                    instanceValue = instance;
                    argValues = args;
                }

                internals.superClass.construct(instanceValue, argValues);
            },

            /**
             * Defines the class
             *
             * @param {Function} definitionFactory
             * @return {Class}
             */
            defineClass: function (definitionFactory) {
                var internals = this,
                    name,
                    Class = definitionFactory(internals),
                    classObject,
                    namespace,
                    // Split the FQCN into a Namespace from its prefix and its name within that namespace
                    // (ie. a FQCN of "My\Stuff\MyClass" gives Namespace<My\Stuff> and name "MyClass")
                    parsed = factory.globalNamespace.parseName(internals.fqcn);

                if (internals.superClass) {
                    Class.superClass = internals.superClass;
                }

                // Add any new interfaces to implement to the class definition
                if (!Class.interfaces) {
                    Class.interfaces = [];
                }
                [].push.apply(Class.interfaces, internals.definedInterfaceNames);

                namespace = parsed.namespace;
                name = parsed.name;

                // Now create the internal Uniter class (an instance of Class)
                // from the PHP class definition information
                classObject = namespace.defineClass(
                    name,
                    Class,
                    factory.globalNamespaceScope,
                    internals.enableAutoCoercion
                );

                if (internals.unwrapper) {
                    // Custom unwrappers may be used to eg. unwrap a PHP \DateTime object to a JS Date object
                    factory.unwrapperRepository.defineUnwrapper(classObject, internals.unwrapper);
                }

                return classObject;
            },

            /**
             * Defines a custom unwrapper for this class. When an instance of this class
             * is exported to JS-land, the unwrapper will be used to produce the unwrapped value
             *
             * @param {Function} unwrapper
             */
            defineUnwrapper: function (unwrapper) {
                this.unwrapper = unwrapper;
            },

            /**
             * Disables auto-coercion for the class
             */
            disableAutoCoercion: function () {
                this.enableAutoCoercion = false;
            },

            /**
             * Extends another defined class
             *
             * @param {string} fqcn
             */
            extendClass: function (fqcn) {
                this.superClass = factory.globalNamespace.getClass(fqcn);
            },

            /**
             * Implements an interface
             *
             * @param {string} interfaceName
             */
            implement: function (interfaceName) {
                this.definedInterfaceNames.push(interfaceName);
            }
        });

        return ClassInternals;
    }
});

module.exports = ClassInternalsClassFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Internals/FunctionInternalsClassFactory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Internals/FunctionInternalsClassFactory.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {Internals} baseInternals
 * @param {ValueFactory} valueFactory
 * @param {FFIFactory} ffiFactory
 * @param {Namespace} globalNamespace
 * @param {NamespaceScope} globalNamespaceScope
 * @constructor
 */
function FunctionInternalsClassFactory(
    baseInternals,
    valueFactory,
    ffiFactory,
    globalNamespace,
    globalNamespaceScope
) {
    /**
     * @type {Internals}
     */
    this.baseInternals = baseInternals;
    /**
     * @type {FFIFactory}
     */
    this.ffiFactory = ffiFactory;
    /**
     * @type {Namespace}
     */
    this.globalNamespace = globalNamespace;
    /**
     * @type {NamespaceScope}
     */
    this.globalNamespaceScope = globalNamespaceScope;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(FunctionInternalsClassFactory.prototype, {
    /**
     * Creates a FunctionInternals class for use when defining a function using JS
     *
     * @return {class}
     */
    create: function () {
        var factory = this;

        /**
         * @param {string} fqfn
         * @constructor
         */
        function FunctionInternals(fqfn) {
            /**
             * @type {boolean}
             */
            this.enableAutoCoercion = true;
            /**
             * @type {string}
             */
            this.fqfn = fqfn;
        }

        // Extend the base Internals object so we inherit all the public service properties etc.
        FunctionInternals.prototype = Object.create(factory.baseInternals);

        _.extend(FunctionInternals.prototype, {
            /**
             * Defines the function
             *
             * @param {Function} definitionFactory
             */
            defineFunction: function (definitionFactory) {
                var internals = this,
                    name,
                    func = definitionFactory(internals),
                    namespace,
                    parsed = factory.globalNamespace.parseName(internals.fqfn),
                    valueCoercer = factory.ffiFactory.createValueCoercer(internals.enableAutoCoercion);

                namespace = parsed.namespace;
                name = parsed.name;

                namespace.defineFunction(
                    name,
                    function __uniterOutboundStackMarker__() {
                        // Unwrap args from PHP-land to JS-land to native values if/as appropriate
                        var effectiveArguments = valueCoercer.coerceArguments(arguments);

                        return func.apply(internals, effectiveArguments);
                    },
                    factory.globalNamespaceScope
                );
            },

            /**
             * Disables auto-coercion for the class
             */
            disableAutoCoercion: function () {
                this.enableAutoCoercion = false;
            }
        });

        return FunctionInternals;
    }
});

module.exports = FunctionInternalsClassFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Internals/Internals.js":
/*!*************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Internals/Internals.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {string} mode Synchronicity mode: "async", "psync" or "sync"
 * @param {Resumable|null} pausable
 * @param {ValueFactory} valueFactory
 * @param {CallFactory} callFactory
 * @param {CallStack} callStack
 * @param {ValueHelper} valueHelper
 * @param {ClassAutoloader} classAutoloader
 * @param {ErrorConfiguration} errorConfiguration
 * @param {ErrorPromoter} errorPromoter
 * @param {ErrorReporting} errorReporting
 * @param {Namespace} globalNamespace,
 * @param {Scope} globalScope,
 * @param {INIState} iniState,
 * @param {OptionSet} optionSet,
 * @param {Output} output,
 * @param {Runtime} runtime,
 * @param {Stream} stdout,
 * @param {TraceFormatter} traceFormatter,
 * @param {Translator} translator,
 * @param {PHPState} state
 * @constructor
 */
function Internals(
    mode,
    pausable,
    valueFactory,
    callFactory,
    callStack,
    valueHelper,
    classAutoloader,
    errorConfiguration,
    errorPromoter,
    errorReporting,
    globalNamespace,
    globalScope,
    iniState,
    optionSet,
    output,
    runtime,
    stdout,
    traceFormatter,
    translator,
    state
) {
    /**
     * @public
     * @type {CallFactory}
     */
    this.callFactory = callFactory;
    /**
     * @public
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @public
     * @type {ClassAutoloader}
     */
    this.classAutoloader = classAutoloader;
    /**
     * @public
     * @type {ErrorConfiguration}
     */
    this.errorConfiguration = errorConfiguration;
    /**
     * @public
     * @type {ErrorPromoter}
     */
    this.errorPromoter = errorPromoter;
    /**
     * @public
     * @type {ErrorReporting}
     */
    this.errorReporting = errorReporting;
    /**
     * @public
     * @type {Namespace}
     */
    this.globalNamespace = globalNamespace;
    /**
     * @public
     * @type {Scope}
     */
    this.globalScope = globalScope;
    /**
     * @public
     * @type {INIState}
     */
    this.iniState = iniState;
    /**
     * @public
     * @type {string}
     */
    this.mode = mode;
    /**
     * @public
     * @type {OptionSet}
     */
    this.optionSet = optionSet;
    /**
     * @public
     * @type {Output}
     */
    this.output = output;
    /**
     * @public
     * @type {Resumable|null}
     */
    this.pausable = pausable;
    /**
     * @public
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * @public
     * @type {PHPState}
     */
    this.state = state;
    /**
     * @public
     * @type {Stream}
     */
    this.stdout = stdout;
    /**
     * @public
     * @type {TraceFormatter}
     */
    this.traceFormatter = traceFormatter;
    /**
     * @public
     * @type {Translator}
     */
    this.translator = translator;
    /**
     * @public
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
    /**
     * @public
     * @type {ValueHelper}
     */
    this.valueHelper = valueHelper;

    // Sanity check
    if (mode === 'async' && !pausable) {
        throw new Error('Pausable is required for async mode');
    }
}

_.extend(Internals.prototype, {
    /**
     * Creates a new FFI Result, to provide the result of a call to a JS function
     *
     * @param {Function} syncCallback
     * @param {Function|null} asyncCallback
     * @returns {FFIResult}
     */
    createFFIResult: function (syncCallback, asyncCallback) {
        return this.state.createFFIResult(syncCallback, asyncCallback);
    },

    /**
     * Fetches a binding by its name
     *
     * @param {string} bindingName
     * @returns {*}
     */
    getBinding: function (bindingName) {
        return this.state.getBinding(bindingName);
    },

    /**
     * Fetches the native value of a constant by its name
     *
     * @param {string} name
     * @returns {*}
     */
    getConstant: function (name) {
        return this.state.getConstant(name);
    },

    /**
     * Fetches the value of a global variable, if defined.
     * If the variable is not defined then a NULL value will be returned.
     *
     * @param {string} name
     * @return {Value}
     */
    getGlobal: function (name) {
        return this.state.getGlobal(name);
    },

    /**
     * Determines whether we're in true asynchronous mode (not psync or sync mode)
     *
     * @return {boolean}
     */
    isAsync: function () {
        return this.mode === 'async';
    },

    /**
     * Determines whether we're in Promise-synchronous mode
     *
     * @return {boolean}
     */
    isPsync: function () {
        return this.mode === 'psync';
    },

    /**
     * Determines whether we're in synchronous mode
     *
     * @return {boolean}
     */
    isSync: function () {
        return this.mode === 'sync';
    },

    /**
     * Sets the value of an existing PHP global. If a native value is given
     * then it will be coerced to a PHP one.
     * If the global is not defined than an error will be thrown -
     * use .defineGlobal(...) when defining a new variable
     *
     * @param {string} name
     * @param {Value|*} value Value object or native value to be coerced
     * @throws {Error} Throws if the variable is not defined in the global scope
     */
    setGlobal: function (name, value) {
        this.state.setGlobal(name, value);
    }
});

module.exports = Internals;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Result.js":
/*!************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Result.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    isPromise = __webpack_require__(/*! is-promise */ "./node_modules/is-promise/index.js"),
    Promise = __webpack_require__(/*! lie */ "./node_modules/lie/lib/browser.js");

/**
 * Represents a result returned from JS-land back to PHP-land. This allows
 * a result that may be fetched asynchronously to be used in async mode
 * while also providing a way to fetch it synchronously in sync mode.
 *
 * @param {Function} syncCallback
 * @param {Function=} asyncCallback
 * @param {Resumable=} pausable
 * @constructor
 */
function Result(syncCallback, asyncCallback, pausable) {
    /**
     * @type {Function|null}
     */
    this.asyncCallback = asyncCallback;
    /**
     * @type {Resumable|null}
     */
    this.pausable = pausable || null;
    /**
     * @type {Function}
     */
    this.syncCallback = syncCallback;
}

_.extend(Result.prototype, {
    /**
     * Fetches the result asynchronously. If only a synchronous callback is provided,
     * it will be used but then its result will be wrapped in a resolved Promise.
     *
     * @returns {Promise}
     */
    getAsync: function () {
        var promise;

        if (this.asyncCallback) {
            // We have an async callback - it must return a valid Promise (thenable)
            promise = this.asyncCallback();

            if (!isPromise(promise)) {
                throw new Error('Async callback did not return a Promise');
            }

            return promise;
        }

        // Otherwise if no async callback was provided, fall back to using the sync one
        // but maintain the same API by wrapping it in a resolved Promise
        return Promise.resolve(this.getSync());
    },

    /**
     * Fetches the result synchronously
     *
     * @returns {*}
     */
    getSync: function () {
        return this.syncCallback();
    },

    /**
     * Resolves this FFI result to a value, awaiting the Promise
     * returned by the async callback if needed
     *
     * @param {ValueFactory} valueFactory
     * @return {Value}
     */
    resolve: function (valueFactory) {
        var result = this,
            pause;

        if (!result.pausable) {
            /**
             * We're in either sync or psync mode - use the synchronous fetcher
             * as we are unable to wait for an asynchronous operation to complete.
             * Remember that we still need to coerce the result as needed,
             * in case the fetcher returns an unwrapped native JS value.
             */
            return valueFactory.coerce(result.getSync());
        }

        pause = result.pausable.createPause();

        // Wait for the returned promise to resolve or reject before continuing
        result.getAsync().then(function (resultValue) {
            // Remember we still need to coerce the result as above
            pause.resume(valueFactory.coerce(resultValue));
        }, function (error) {
            pause.throw(error);
        });

        return pause.now();
    }
});

module.exports = Result;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Stack/GlobalStackHooker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Stack/GlobalStackHooker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {NonV8FrameStackHooker|V8FrameStackHooker} frameStackHooker
 * @param {Global} global
 * @constructor
 */
function GlobalStackHooker(frameStackHooker, global) {
    /**
     * @type {NonV8FrameStackHooker|V8FrameStackHooker}
     */
    this.frameStackHooker = frameStackHooker;
    /**
     * @type {Global}
     */
    this.global = global;
}

_.extend(GlobalStackHooker.prototype, {
    /**
     * Hooks error stack handling for all frames/global contexts accessible from the current one.
     */
    hook: function () {
        var hooker = this,
            hookErrorStacksForAllSubFrames = function (frame) {
                try {
                    hooker.frameStackHooker.hook(frame);
                } catch (e) {
                    // Unable to access the context.
                }

                try {
                    _.each(frame.frames, function (frame) {
                        hookErrorStacksForAllSubFrames(frame);
                    });
                } catch (e) {
                    // Unable to access the context.
                }
            };

        if (hooker.global.top !== hooker.global) {
            // We're not the top context, so attempt to hook from there recursively.
            // Note that due to same-origin policy this may not be feasible.
            hookErrorStacksForAllSubFrames(hooker.global.top);
        }

        hookErrorStacksForAllSubFrames(hooker.global);
    }
});

module.exports = GlobalStackHooker;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Stack/NonV8FrameStackHooker.js":
/*!*********************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Stack/NonV8FrameStackHooker.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Handles the hooking of native JS error stack traces for a specific window/frame
 * in environments where <Error>.stack is defined as an accessor property, eg. Firefox/SpiderMonkey
 *
 * @param {StackCleaner} stackCleaner
 * @constructor
 */
function NonV8FrameStackHooker(stackCleaner) {
    /**
     * @type {StackCleaner}
     */
    this.stackCleaner = stackCleaner;
}

_.extend(NonV8FrameStackHooker.prototype, {
    /**
     * Hooks native JS error stack traces for a specific window/frame
     *
     * @param {Window} frame
     */
    hook: function (frame) {
        var hooker = this,
            NativeError = frame.Error,
            originalDescriptor = Object.getOwnPropertyDescriptor(NativeError.prototype, 'stack');

        if (originalDescriptor !== null && originalDescriptor.get && originalDescriptor.set) {
            Object.defineProperty(NativeError.prototype, 'stack', {
                configurable: true,
                enumerable: false,
                get: function () {
                    // Fetch the stack via the native mechanism before running it through our cleaning routine
                    return hooker.stackCleaner.cleanStack(originalDescriptor.get.call(this));
                },
                set: function (stackTrace) {
                    // Use the native .stack property value assignment logic for simplicity
                    originalDescriptor.set.call(this, stackTrace);
                }
            });
        }
    }
});

module.exports = NonV8FrameStackHooker;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Stack/StackCleaner.js":
/*!************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Stack/StackCleaner.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    STATE_JS_LAND = 'js land',
    STATE_PHP_LAND = 'php land';

/**
 * Handles the cleaning of JS/PHP mixed stack traces to remove PHPCore internal frames
 *
 * @constructor
 */
function StackCleaner() {

}

_.extend(StackCleaner.prototype, {
    /**
     * Removes all frames from the given stack trace that relate to PHPCore internals,
     * to produce a more useful and readable output, especially with tools such as Cypress.
     *
     * @param {string} stack
     * @param {number=} stackTraceLimit
     * @returns {string}
     */
    cleanStack: function (stack, stackTraceLimit) {
        var frameIndex,
            line,
            resultFrames = [],
            state = STATE_JS_LAND,
            stackLines = stack.split('\n');

        for (frameIndex = stackLines.length - 1; frameIndex >= 0; frameIndex--) {
            line = stackLines[frameIndex];

            // TODO: Define these special func names with Object.defineProperty(...)
            //       to accommodate minification
            if (/__uniterInboundStackMarker__/.test(line)) {
                state = STATE_PHP_LAND;
            } else if (/__uniterOutboundStackMarker__/.test(line)) {
                // We're now back out in JS land
                state = STATE_JS_LAND;
            } else if (state === STATE_JS_LAND || /__uniter(Module|Function)StackMarker__/.test(line)) {
                resultFrames.unshift(
                    line
                        // Tidy stack frames from top-level PHP modules
                        .replace(/\b__uniterModuleStackMarker__/g, '__uniter_php_module__')
                        // Remove stack markers from named PHP functions
                        .replace(/\B__uniterFunctionStackMarker__/g, '')
                        // Tidy stack frames from PHP closures
                        .replace(/\b__uniterFunctionStackMarker__/g, '__uniter_php_closure__')
                );
            }
        }

        if (typeof stackTraceLimit !== 'undefined' && isFinite(stackTraceLimit)) {
            resultFrames = resultFrames.slice(0, stackTraceLimit);
        }

        return resultFrames.join('\n');
    }
});

module.exports = StackCleaner;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Stack/StackHooker.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Stack/StackHooker.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {GlobalStackHooker} globalStackHooker
 * @param {OptionSet} optionSet
 * @constructor
 */
function StackHooker(globalStackHooker, optionSet) {
    /**
     * @type {GlobalStackHooker}
     */
    this.globalStackHooker = globalStackHooker;
    /**
     * @type {OptionSet}
     */
    this.optionSet = optionSet;
}

_.extend(StackHooker.prototype, {
    /**
     * Detects whether native stack cleaning is enabled, installing the relevant hooks if so
     */
    hook: function () {
        var hooker = this,
            // TODO: Consider defaulting to on (opt-out) once stable
            stackCleaningEnabled = hooker.optionSet.getOption('stackCleaning') === true;

        if (stackCleaningEnabled) {
            hooker.globalStackHooker.hook();
        }
    }
});

module.exports = StackHooker;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Stack/V8FrameStackHooker.js":
/*!******************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Stack/V8FrameStackHooker.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Handles the hooking of native JS error stack traces for a specific window/frame in V8,
 * where we can use the Stack Trace API (https://v8.dev/docs/stack-trace-api)
 *
 * @param {StackCleaner} stackCleaner
 * @constructor
 */
function V8FrameStackHooker(stackCleaner) {
    /**
     * @type {StackCleaner}
     */
    this.stackCleaner = stackCleaner;
}

_.extend(V8FrameStackHooker.prototype, {
    /**
     * Hooks native JS error stack traces for a specific window/frame
     *
     * @param {Window} frame
     */
    hook: function (frame) {
        var hooker = this,
            NativeError = frame.Error,

            // On init, take note of the current limit so we can continue to apply it until/unless changed
            // via the setter on the overriding CustomError we define below
            stackTraceLimit = NativeError.stackTraceLimit;

        // Hook the creation of error stack traces in V8 using the Stack Trace API
        NativeError.prepareStackTrace = function (error/*, structuredStackTrace*/) {
            var cleanedStack = hooker.stackCleaner.cleanStack(
                error.stack,
                // Allow one extra line for the error message
                stackTraceLimit + 1
            );

            // For older versions of V8 we need to write to the .stack property,
            // as the return value from .prepareStackTrace(...) is not always respected
            error.stack = cleanedStack;

            return cleanedStack;
        };

        /**
         * Capture all stack frames so that we can correctly clean the stack. Note that
         * Error.stackTraceLimit may still be set elsewhere (to give its "visible" value),
         * which will use the accessor property that shadows this one below.
         *
         * Once a stack has been cleaned it will be truncated to the limit set.
         */
        NativeError.stackTraceLimit = Infinity;

        /**
         * Custom Error class that allows hooking static .stackTraceLimit so we can apply it post-cleaning
         *
         * @param {string} message
         * @constructor
         */
        function CustomError(message) {
            this.message = message;

            // Unlike the native Error class that we're overriding, we need to explicitly capture .stack
            NativeError.captureStackTrace(this, CustomError);
        }

        // Define the Error.* V8 Stack Trace API static members
        Object.defineProperties(CustomError, {
            captureStackTrace: {
                configurable: true,
                enumerable: true,
                value: NativeError.captureStackTrace,
                writable: true
            },

            // Name this class as the native Error
            name: {
                configurable: true,
                enumerable: false,
                value: 'Error'
            },

            // Shadow the native preparer we set above.
            prepareStackTrace: {
                configurable: true,
                enumerable: true,

                get: function () {
                    return undefined;
                },

                set: function () {
                    // TODO: Support this by also cleaning structuredStackTrace
                    //       so that it may be passed on to the next preparer in the chain
                    throw new Error('Uniter: Stacking of Error.prepareStackTrace not yet supported');
                }
            },

            /**
             * Allow Error.stackTraceLimit to be get and set, always returning the correct current value.
             * However, internally we need to set the limit differently in order to capture enough frames
             * to correctly clean the stack.
             *
             * NB: Attempting to simply redefine this property as an accessor on the native Error class
             *     seems to result in the V8 Stack Trace API being disabled, hence this custom Error class.
             */
            stackTraceLimit: {
                configurable: true,
                enumerable: true,

                /**
                 * Fetches the current (visible) Error.stackTraceLimit
                 *
                 * @returns {number}
                 */
                get: function () {
                    return stackTraceLimit;
                },

                /**
                 * Handles a new (visible) Error.stackTraceLimit being set
                 *
                 * @param {number} newLimit
                 */
                set: function (newLimit) {
                    stackTraceLimit = newLimit;
                }
            }
        });

        // Use the native Error.prototype so that we implement any other properties
        // and so that instanceof will still work correctly.
        CustomError.prototype = NativeError.prototype;

        frame.Error = CustomError;
    }
});

module.exports = V8FrameStackHooker;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/AsyncObjectValue.js":
/*!****************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/AsyncObjectValue.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    util,
    Value
) {
    /**
     * @param {ValueFactory} factory
     * @param {CallStack} callStack
     * @param {ValueCaller} valueCaller
     * @param {ObjectValue} wrappedObjectValue
     * @constructor
     */
    function AsyncObjectValue(factory, callStack, valueCaller, wrappedObjectValue) {
        var nativeValue = wrappedObjectValue.getObject();

        Value.call(this, factory, callStack, 'object', nativeValue);

        /**
         * @type {ValueCaller}
         */
        this.valueCaller = valueCaller;
        /**
         * @type {ObjectValue}
         */
        this.wrappedObjectValue = wrappedObjectValue;
    }

    util.inherits(AsyncObjectValue, Value);

    _.extend(AsyncObjectValue.prototype, {
        /**
         * Calls the specified method of this object
         *
         * @param {string} methodName
         * @param {Value[]?} args
         * @returns {Promise<Value>} Returns the result of the method
         * @throws {PHPFatalError} Throws when the method does not exist
         */
        callMethod: function (methodName, args) {
            var value = this;

            return value.valueCaller.callMethod(value.wrappedObjectValue, methodName, args);
        }
    });

    return AsyncObjectValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/PHPObject.js":
/*!*********************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/PHPObject.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    /**
     * Provides a proxy for accessing all data/methods of an instance of a PHP-defined class.
     *
     * Objects that implement __call(), __get(), __set() or define a public property
     * anywhere along their class ancestry could benefit from being unwrapped to a PHPObject
     * as this will permit access to those from native JS code, at the expense of a more complex API.
     *
     * @param {ValueFactory} valueFactory
     * @param {NativeCaller} nativeCaller
     * @param {ObjectValue} objectValue
     * @constructor
     */
    function PHPObject(
        valueFactory,
        nativeCaller,
        objectValue
    ) {
        /**
         * @type {NativeCaller}
         */
        this.nativeCaller = nativeCaller;
        /**
         * @type {ObjectValue}
         */
        this.objectValue = objectValue;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(PHPObject.prototype, {
        /**
         * Calls the specified method of the wrapped ObjectValue, returning a Promise.
         * Allows JS-land code to call objects exported/returned from PHP-land,
         * where asynchronous (blocking) operation is possible.
         *
         * @param {string} methodName
         * @returns {Promise<*>|*}
         */
        callMethod: function (methodName) {
            var phpObject = this,
                // Arguments will be from JS-land, so coerce any to internal PHP value objects
                args = _.map([].slice.call(arguments, 1), function (arg) {
                    return phpObject.valueFactory.coerce(arg);
                });

            return phpObject.nativeCaller.callMethod(phpObject.objectValue, methodName, args);
        },

        /**
         * Fetches the unwrapped ObjectValue that this PHPObject was created from
         *
         * @returns {ObjectValue}
         */
        getObjectValue: function () {
            return this.objectValue;
        }
    });

    return PHPObject;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyClassFactory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/Proxy/ProxyClassFactory.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates the ProxyClass for a given PHP class
 *
 * @param {ValueStorage} valueStorage
 * @param {ProxyMemberFactory} proxyMemberFactory
 * @constructor
 */
function ProxyClassFactory(valueStorage, proxyMemberFactory) {
    /**
     * @type {ProxyMemberFactory}
     */
    this.proxyMemberFactory = proxyMemberFactory;
    /**
     * @type {ValueStorage}
     */
    this.valueStorage = valueStorage;
}

_.extend(ProxyClassFactory.prototype, {
    /**
     * Creates the ProxyClass for a given PHP class
     *
     * @param {Class} classObject
     * @returns {class}
     */
    create: function (classObject) {
        var currentClass,
            currentPrototype,
            factory = this,
            methodNamesProxied = {};

        /**
         * @param {ObjectValue} objectValue Internal ObjectValue instance
         * @param {boolean} useSyncApiAlthoughPsync
         * @constructor
         */
        function ProxyClass(objectValue, useSyncApiAlthoughPsync) {
            /*
             * This data is stored in a WeakMap using this instance as the key, for multiple reasons:
             * a) To ensure there are no collisions with methods of the proxied class
             *    (ie. if we stored objectValue as a property of this object, but the proxied class
             *    happened to have a method called "objectValue" there would be an issue)
             * b) To more neatly allow the data to be extracted and funneled into a new instance
             *    in the scenario where we want a proxy with a synchronous API (see ValueHelper)
             */
            factory.valueStorage.setPrivatesForNativeProxy(this, {
                objectValue: objectValue,
                useSyncApiAlthoughPsync: Boolean(useSyncApiAlthoughPsync)
            });
        }
        ProxyClass.prototype = Object.create(classObject.getInternalClass().prototype);

        function defineProxyMethod(methodName) {
            ProxyClass.prototype[methodName] = factory.proxyMemberFactory.createProxyMethod(methodName);
        }

        currentClass = classObject;

        /*
         * Iterate up the class hierarchy, proxying methods as we go. Note that
         * in most cases the first class' prototype chain is probably all we need
         * to process, however some classes in the hierarchy may have non-standard
         * native objects (eg. JSObject) and so we need to process each one's
         * prototype chain just in case.
         *
         * TODO: Remove the need for this duplication by handling the special JSObject case
         *       in that class alone.
         */
        while (currentClass) {
            currentPrototype = currentClass.getInternalClass().prototype;

            while (currentPrototype !== null && currentPrototype !== Object.prototype) {
                /*jshint loopfunc: true */
                _.forOwn(currentPrototype, function (property, propertyName) {
                    if (
                        // Only proxy methods
                        typeof property !== 'function' ||
                        // Only proxy each method once
                        methodNamesProxied[propertyName] === true
                    ) {
                        return;
                    }

                    defineProxyMethod(propertyName);

                    methodNamesProxied[propertyName] = true;
                });

                currentPrototype = Object.getPrototypeOf(currentPrototype);
            }

            currentClass = currentClass.getSuperClass();
        }

        return ProxyClass;
    }
});

module.exports = ProxyClassFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyClassRepository.js":
/*!**************************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/Proxy/ProxyClassRepository.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    WeakMap = __webpack_require__(/*! es6-weak-map */ "./node_modules/es6-weak-map/index.js");

/**
 * Fetches the generated JS proxy class for a PHP class, creating and caching it if needed
 *
 * @param {ProxyClassFactory} proxyClassFactory
 * @constructor
 */
function ProxyClassRepository(proxyClassFactory) {
    /**
     * @type {WeakMap<object, Function>}
     */
    this.classToProxyClassMap = new WeakMap();
    /**
     * @type {ProxyClassFactory}
     */
    this.proxyClassFactory = proxyClassFactory;
}

_.extend(ProxyClassRepository.prototype, {
    /**
     * Fetches the proxy class for the given PHP class
     *
     * @param {Class} classObject
     * @returns {class}
     */
    getProxyClass: function (classObject) {
        var ProxyClass,
            repository = this;

        if (repository.classToProxyClassMap.has(classObject)) {
            // Cache the ProxyClass for each PHP class for identity and to save on memory
            return repository.classToProxyClassMap.get(classObject);
        }

        ProxyClass = repository.proxyClassFactory.create(classObject);

        repository.classToProxyClassMap.set(classObject, ProxyClass);

        return ProxyClass;
    }
});

module.exports = ProxyClassRepository;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/Proxy/ProxyFactory.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates an exported proxying object value for an FFIObjectValue based on its class' interface
 *
 * @param {ProxyClassRepository} proxyClassRepository
 * @param {string} mode Synchronicity mode
 * @constructor
 */
function ProxyFactory(proxyClassRepository, mode) {
    /**
     * @type {string}
     */
    this.mode = mode;
    /**
     * @type {ProxyClassRepository}
     */
    this.proxyClassRepository = proxyClassRepository;
}

_.extend(ProxyFactory.prototype, {
    /**
     * Creates an exported proxy object value for the object value that the wrapped reference points to
     *
     * @param {ObjectValue} objectValue
     * @param {boolean=} useSyncApiAlthoughPsync
     * @returns {Object|*}
     */
    create: function (objectValue, useSyncApiAlthoughPsync) {
        var factory = this,
            ProxyClass = factory.proxyClassRepository.getProxyClass(objectValue.getClass());

        if (useSyncApiAlthoughPsync && factory.mode !== 'psync') {
            throw new Error('Cannot explicitly request sync API when not in psync mode');
        }

        return new ProxyClass(objectValue, useSyncApiAlthoughPsync);
    }
});

module.exports = ProxyFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyMemberFactory.js":
/*!************************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/Proxy/ProxyMemberFactory.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates proxying versions of PHP class members (methods and properties)
 *
 * @param {ValueFactory} valueFactory
 * @param {ValueStorage} valueStorage
 * @param {NativeCaller} nativeCaller
 * @constructor
 */
function ProxyMemberFactory(
    valueFactory,
    valueStorage,
    nativeCaller
) {
    /**
     * @type {NativeCaller}
     */
    this.nativeCaller = nativeCaller;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
    /**
     * @type {ValueStorage}
     */
    this.valueStorage = valueStorage;
}

_.extend(ProxyMemberFactory.prototype, {
    /**
     * Creates a proxying method for the ProxyClass for a method of a PHP class
     *
     * @param {string} methodName
     * @returns {Function}
     */
    createProxyMethod: function (methodName) {
        var factory = this;

        return function __uniterInboundStackMarker__() {
            // Arguments will be from JS-land, so coerce any to internal PHP value objects
            var args = _.map(arguments, function (arg) {
                    return factory.valueFactory.coerce(arg);
                }),
                privates = factory.valueStorage.getPrivatesForNativeProxy(this),
                objectValue = privates.objectValue,
                useSyncApiAlthoughPsync = privates.useSyncApiAlthoughPsync;

            return factory.nativeCaller.callMethod(objectValue, methodName, args, useSyncApiAlthoughPsync);
        };
    }
});

module.exports = ProxyMemberFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/ValueCoercer.js":
/*!************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/ValueCoercer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {boolean} autoCoercionEnabled
 * @constructor
 */
function ValueCoercer(autoCoercionEnabled) {
    /**
     * @type {boolean}
     */
    this.autoCoercionEnabled = autoCoercionEnabled;
}

_.extend(ValueCoercer.prototype, {
    /**
     * Unwraps arguments for a method based on the coercion mode for the class
     *
     * @param {Value[]} argumentValues
     * @returns {Value[]|*[]}
     */
    coerceArguments: function (argumentValues) {
        var coercer = this;

        if (coercer.autoCoercionEnabled) {
            argumentValues = _.map(argumentValues, function (argumentValue) {
                return argumentValue.getNative();
            });
        }

        return argumentValues;
    },

    /**
     * Determines whether auto-coercion is enabled
     *
     * @returns {boolean}
     */
    isAutoCoercionEnabled: function () {
        return this.autoCoercionEnabled;
    }
});

module.exports = ValueCoercer;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/ValueHelper.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/ValueHelper.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    WeakMap = __webpack_require__(/*! es6-weak-map */ "./node_modules/es6-weak-map/index.js");

/**
 * @param {ProxyFactory} proxyFactory
 * @param {FFIFactory} ffiFactory
 * @param {ValueStorage} valueStorage
 * @param {string} mode
 * @constructor
 */
function ValueHelper(proxyFactory, ffiFactory, valueStorage, mode) {
    /**
     * @type {FFIFactory}
     */
    this.ffiFactory = ffiFactory;
    /**
     * @type {string}
     */
    this.mode = mode;
    /**
     * @type {ProxyFactory}
     */
    this.proxyFactory = proxyFactory;
    /**
     * Used for mapping native objects that have previously been re-proxied
     * with a synchronous API to the re-proxied object
     *
     * @type {WeakMap}
     */
    this.proxyToSyncApiProxy = new WeakMap();
    /**
     * @type {ValueStorage}
     */
    this.valueStorage = valueStorage;
}

_.extend(ValueHelper.prototype, {
    /**
     * Takes the given proxy and returns a new one with a synchronous API,
     * even in Promise-synchronous mode. Note that an error will be thrown
     * if in async mode as synchronous operation is then impossible.
     *
     * @param {ProxyClass} proxy
     * @return {ProxyClass}
     */
    toNativeWithSyncApi: function (proxy) {
        var helper = this,
            objectValue,
            privates,
            reproxy;

        if (helper.mode === 'sync') {
            // In sync mode, the original proxy will use a synchronous API,
            // so there is nothing to do, just return it unchanged
            return proxy;
        }

        if (helper.mode === 'async') {
            // Sanity check
            throw new Error(
                'ValueHelper.toNativeWithSyncApi() :: Unable to provide a synchronous API in async mode'
            );
        }

        if (helper.proxyToSyncApiProxy.has(proxy)) {
            // We already have a re-proxied object with a sync API, so reuse it
            // both for speed and identity
            return helper.proxyToSyncApiProxy.get(proxy);
        }

        if (!helper.valueStorage.hasPrivatesForNativeProxy(proxy)) {
            throw new Error('ValueHelper.toNativeWithSyncApi() :: Invalid proxy instance given');
        }

        privates = helper.valueStorage.getPrivatesForNativeProxy(proxy);
        objectValue = privates.objectValue;

        reproxy = helper.proxyFactory.create(objectValue, true);

        // Store this conversion so we can reuse the reproxied object as mentioned above
        helper.proxyToSyncApiProxy.set(proxy, reproxy);
        // Also map the reproxied object to itself
        helper.proxyToSyncApiProxy.set(reproxy, reproxy);

        // Ensure the reproxied object may also be mapped back to the original object value
        // (eg. in the scenario where an object is exported to JS-land, reproxied for a sync API
        // and then the reproxied object is passed back into PHP-land)
        helper.valueStorage.setObjectValueForExport(reproxy, objectValue);

        return reproxy;
    },

    /**
     * Takes the given ObjectValue and returns a special AsyncObjectValue that wraps it,
     * providing the same API but with Promises returned when relevant methods are called,
     * to avoid the caller having to be Pausable-aware
     *
     * @param {ObjectValue} objectValue
     * @returns {AsyncObjectValue}
     */
    toValueWithAsyncApi: function (objectValue) {
        var helper = this;

        return helper.ffiFactory.createAsyncObjectValue(objectValue);
    }
});

module.exports = ValueHelper;


/***/ }),

/***/ "./node_modules/phpcore/src/FFI/Value/ValueStorage.js":
/*!************************************************************!*\
  !*** ./node_modules/phpcore/src/FFI/Value/ValueStorage.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    WeakMap = __webpack_require__(/*! es6-weak-map */ "./node_modules/es6-weak-map/index.js");

/**
 * @constructor
 */
function ValueStorage() {
    /**
     * @type {WeakMap<Object|*, ObjectValue>}
     */
    this.exportToObjectValueMap = new WeakMap();
    /**
     * @type {WeakMap<ObjectValue, Object|*>}
     */
    this.objectValueToExportMap = new WeakMap();
    /**
     * @type {WeakMap<object, {objectValue: ObjectValue, useSyncApiAlthoughPsync: boolean}>}
     */
    this.proxyPrivatesMap = new WeakMap();
}

_.extend(ValueStorage.prototype, {
    /**
     * Fetches the cached export for the given object value
     * (cached both for identity and to save on memory usage)
     *
     * @param {ObjectValue} objectValue
     * @returns {Object|*}
     */
    getExportForObjectValue: function (objectValue) {
        return this.objectValueToExportMap.get(objectValue);
    },

    /**
     * Fetches the original ObjectValue that was exported
     *
     * @param {Object|*} exportedValue
     * @returns {ObjectValue}
     */
    getObjectValueForExport: function (exportedValue) {
        return this.exportToObjectValueMap.get(exportedValue);
    },

    /**
     * Fetches the private data for the given native proxy
     *
     * @param {ProxyClass} proxy
     * @returns {{objectValue: ObjectValue, useSyncApiAlthoughPsync: boolean}}
     */
    getPrivatesForNativeProxy: function (proxy) {
        return this.proxyPrivatesMap.get(proxy);
    },

    /**
     * Determines whether we have a cached export for an object value
     * (cached both for identity and to save on memory usage)
     *
     * @param {ObjectValue} objectValue
     * @returns {boolean}
     */
    hasExportForObjectValue: function (objectValue) {
        return this.objectValueToExportMap.has(objectValue);
    },

    /**
     * Determines whether we have an original ObjectValue for the given export value
     *
     * @param {Object} exportedValue
     * @returns {boolean}
     */
    hasObjectValueForExport: function (exportedValue) {
        return this.exportToObjectValueMap.has(exportedValue);
    },

    /**
     * Determines whether there is private data for the given native proxy
     * (ie. whether it is actually a valid native proxy)
     *
     * @param {ProxyClass} proxy
     * @returns {boolean}
     */
    hasPrivatesForNativeProxy: function (proxy) {
        return this.proxyPrivatesMap.has(proxy);
    },

    /**
     * Stores the given export for the specified object value
     *
     * @param {ObjectValue} objectValue
     * @param {Object|*} exportedValue
     */
    setExportForObjectValue: function (objectValue, exportedValue) {
        var storage = this;

        storage.objectValueToExportMap.set(objectValue, exportedValue);
    },

    /**
     * Stores an export for an object value (note that an object value may be unwrapped
     * to several exports, eg. for psync mode, both an async and a sync API proxy)
     *
     * @param {Object|*} exportedValue
     * @param {ObjectValue} objectValue
     */
    setObjectValueForExport: function (exportedValue, objectValue) {
        this.exportToObjectValueMap.set(exportedValue, objectValue);
    },

    /**
     * Stores the private data for the given native proxy
     *
     * @param {ProxyClass} proxy
     * @param {{objectValue: ObjectValue, useSyncApiAlthoughPsync: boolean}} privates
     */
    setPrivatesForNativeProxy: function (proxy, privates) {
        var storage = this;

        if (storage.proxyPrivatesMap.has(proxy)) {
            throw new Error('Proxy already has privates set');
        }

        storage.proxyPrivatesMap.set(proxy, privates);
    }
});

module.exports = ValueStorage;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/ClosureContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/ClosureContext.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    FunctionContextInterface = __webpack_require__(/*! ./FunctionContextInterface */ "./node_modules/phpcore/src/Function/FunctionContextInterface.js");

/**
 * Represents a PHP closure function
 *
 * @param {NamespaceScope} namespaceScope
 * @param {Class|null} classObject Used when the closure is defined inside a class
 * @constructor
 * @implements {FunctionContextInterface}
 */
function ClosureContext(namespaceScope, classObject) {
    /**
     * @type {Class|null}
     */
    this.classObject = classObject;
    /**
     * @type {NamespaceScope}
     */
    this.namespaceScope = namespaceScope;
}

util.inherits(ClosureContext, FunctionContextInterface);

_.extend(ClosureContext.prototype, {
    /**
     * Fetches the fully-qualified name of the closure (eg. as used by __METHOD__)
     *
     * @returns {string}
     */
    getName: function () {
        return this.namespaceScope.getNamespacePrefix() + '{closure}';
    },

    /**
     * Fetches the name of the closure as required for stack traces
     *
     * @returns {string}
     */
    getTraceFrameName: function () {
        var spec = this,
            name = spec.namespaceScope.getNamespacePrefix() + '{closure}';

        if (spec.classObject) {
            name = spec.classObject.getName() + '::' + name;
        }

        return name;
    },

    /**
     * Fetches the name of the closure, without any qualifying class prefix
     * (eg. as used by __FUNCTION__).
     * NB1: the namespace prefix is intentionally always included
     * NB2: the class (if set) is intentionally never included
     *
     * @returns {string}
     */
    getUnprefixedName: function () {
        return this.namespaceScope.getNamespacePrefix() + '{closure}';
    }
});

module.exports = ClosureContext;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/FunctionContext.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/FunctionContext.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    FunctionContextInterface = __webpack_require__(/*! ./FunctionContextInterface */ "./node_modules/phpcore/src/Function/FunctionContextInterface.js");

/**
 * Represents a PHP function
 *
 * @param {NamespaceScope} namespaceScope
 * @param {string} name
 * @constructor
 * @implements {FunctionContextInterface}
 */
function FunctionContext(namespaceScope, name) {
    /**
     * @type {string}
     */
    this.name = name;
    /**
     * @type {NamespaceScope}
     */
    this.namespaceScope = namespaceScope;
}

util.inherits(FunctionContext, FunctionContextInterface);

_.extend(FunctionContext.prototype, {
    /**
     * Fetches the fully-qualified name of the function (eg. as used by __METHOD__)
     *
     * @returns {string}
     */
    getName: function () {
        var spec = this;

        return spec.namespaceScope.getNamespacePrefix() + spec.name;
    },

    /**
     * Fetches the name of the function as required for stack traces
     *
     * @returns {string}
     */
    getTraceFrameName: function () {
        return this.getName();
    },

    /**
     * Fetches the name of the function
     * (eg. as used by __FUNCTION__)
     *
     * @returns {string}
     */
    getUnprefixedName: function () {
        return this.getName(); // Functions must always be prefixed
    }
});

module.exports = FunctionContext;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/FunctionContextInterface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/FunctionContextInterface.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    throwUnimplemented = function (functionName) {
        return function () {
            throw new Error(functionName + '() :: Not implemented');
        };
    };

/**
 * @interface
 */
function FunctionContextInterface() {
    throw new Error('FunctionContextInterface cannot be instantiated');
}

_.extend(FunctionContextInterface.prototype, {
    /**
     * Fetches the fully-qualified name of the function
     *
     * @param {boolean=} isStaticCall
     * @returns {string}
     */
    getName: throwUnimplemented('getName'),

    /**
     * Fetches the name of the function as required for stack traces
     *
     * @param {boolean=} isStaticCall
     * @returns {string}
     */
    getTraceFrameName: throwUnimplemented('getTraceFrameName'),

    /**
     * Fetches the name of the function, without any qualifying namespace and/or class prefix
     * (eg. as used by __FUNCTION__)
     *
     * @returns {string}
     */
    getUnprefixedName: throwUnimplemented('getUnprefixedName')
});

module.exports = FunctionContextInterface;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/FunctionSpec.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcore/src/Function/FunctionSpec.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    TOO_FEW_ARGS_FOR_EXACT_COUNT = 'core.too_few_args_for_exact_count';

/**
 * Represents the parameters for a PHP function
 *
 * @param {CallStack} callStack
 * @param {ValueFactory} valueFactory
 * @param {FunctionContextInterface} context
 * @param {NamespaceScope} namespaceScope
 * @param {Parameter[]} parameterList
 * @param {string|null} filePath
 * @param {number|null} lineNumber
 * @constructor
 */
function FunctionSpec(
    callStack,
    valueFactory,
    context,
    namespaceScope,
    parameterList,
    filePath,
    lineNumber
) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {FunctionContextInterface}
     */
    this.context = context;
    /**
     * @type {string|null}
     */
    this.filePath = filePath;
    /**
     * @type {number|null}
     */
    this.lineNumber = lineNumber;
    /**
     * @type {NamespaceScope}
     */
    this.namespaceScope = namespaceScope;
    /**
     * @type {Parameter[]|null[]}
     */
    this.parameterList = parameterList;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(FunctionSpec.prototype, {
    /**
     * Coerces the given set of arguments for this function as needed
     *
     * @param {Reference[]|Value[]|Variable[]} argumentReferenceList
     * @returns {Reference[]|Value[]|Variable[]}
     */
    coerceArguments: function (argumentReferenceList) {
        var coercedArguments = argumentReferenceList.slice(),
            spec = this;

        _.each(spec.parameterList, function (parameter, index) {
            if (!parameter) {
                // Parameter is omitted due to bundle-size optimisations or similar, ignore
                return;
            }

            if (argumentReferenceList.length <= index) {
                // Argument is not provided: do not attempt to fetch it
                return;
            }

            // Coerce the argument as the parameter requires
            coercedArguments[index] = parameter.coerceArgument(argumentReferenceList[index]);
        });

        // TODO: PHP7 scalar types should be coerced at this point, assuming caller
        //       was in weak-types mode
        return coercedArguments;
    },

    /**
     * Creates a new function (and its FunctionSpec) for an alias of the current FunctionSpec
     *
     * @param {string} aliasName
     * @param {Function} func
     * @param {FunctionSpecFactory} functionSpecFactory
     * @param {FunctionFactory} functionFactory
     * @return {Function}
     */
    createAliasFunction: function (aliasName, func, functionSpecFactory, functionFactory) {
        var spec = this,
            aliasFunctionSpec = functionSpecFactory.createAliasFunctionSpec(
                spec.namespaceScope,
                aliasName,
                spec.parameterList,
                spec.filePath,
                spec.lineNumber
            );

        return functionFactory.create(
            spec.namespaceScope,
            // Class will always be null for 'normal' functions
            // as defining a function inside a class will define it
            // inside the current namespace instead.
            null,
            func,
            aliasName,
            null,
            null,
            aliasFunctionSpec
        );
    },

    /**
     * Fetches the fully-qualified name of the function
     *
     * @param {boolean} isStaticCall
     * @returns {string}
     */
    getFunctionName: function (isStaticCall) {
        return this.context.getName(isStaticCall);
    },

    /**
     * Fetches the fully-qualified name of the function
     *
     * @param {boolean} isStaticCall
     * @returns {string}
     */
    getFunctionTraceFrameName: function (isStaticCall) {
        return this.context.getTraceFrameName(isStaticCall);
    },

    /**
     * Fetches the parameter of this function at the specified 0-based position
     * in the parameter list.
     * Note that some of its parameters and return type may not be given
     * at runtime due to bundle-size optimisations, for example
     *
     * @param {number} position
     * @returns {Parameter}
     */
    getParameterByPosition: function (position) {
        var spec = this;

        if (position >= spec.parameterList.length || !spec.parameterList[position]) {
            throw new Error('Unable to fetch parameter #' + position + ' of function "' + spec.context.getName() + '"');
        }

        return spec.parameterList[position];
    },

    /**
     * Fetches the name of this function, without any qualifying namespace and/or class prefix
     *
     * @returns {string}
     */
    getUnprefixedFunctionName: function () {
        return this.context.getUnprefixedName();
    },

    /**
     * Populates any unspecified arguments with their default values from parameters
     *
     * @param {Reference[]|Value[]|Variable[]} argumentReferenceList
     * @returns {Reference[]|Value[]|Variable[]}
     */
    populateDefaultArguments: function (argumentReferenceList) {
        var coercedArguments = argumentReferenceList.slice(),
            currentParameter,
            spec = this;

        // Provide special line number instrumentation while loading default arguments
        spec.callStack.instrumentCurrent(function () {
            if (!currentParameter) {
                return null;
            }

            return currentParameter.getLineNumber();
        });

        _.each(spec.parameterList, function (parameter, index) {
            if (!parameter) {
                // Parameter is omitted due to bundle-size optimisations or similar, ignore

                return;
            }

            if (parameter.isRequired() && argumentReferenceList.length <= index) {
                // No argument is given for this required parameter - should fail validation later

                return;
            }

            currentParameter = parameter;

            // Coerce the argument as the parameter requires
            coercedArguments[index] = parameter.populateDefaultArgument(argumentReferenceList[index]);
        });

        return coercedArguments;
    },

    /**
     * Validates that the given set of arguments are valid for this function
     *
     * @param {Reference[]|Value[]|Variable[]} argumentReferenceList
     */
    validateArguments: function (argumentReferenceList) {
        var spec = this;

        _.each(spec.parameterList, function (parameter, index) {
            var filePath = null,
                lineNumber = null;

            if (!parameter) {
                // Parameter is omitted due to bundle-size optimisations or similar, ignore
                return;
            }

            if (parameter.isRequired() && argumentReferenceList.length <= index) {
                if (spec.callStack.getCurrent()) {
                    filePath = spec.callStack.getCallerFilePath();
                    lineNumber = spec.callStack.getCallerLastLine();
                }

                // No argument is given for this required parameter - error
                throw spec.valueFactory.createTranslatedErrorObject(
                    'ArgumentCountError',
                    TOO_FEW_ARGS_FOR_EXACT_COUNT,
                    {
                        func: spec.context.getName(),
                        expectedCount: spec.parameterList.length,
                        actualCount: argumentReferenceList.length,
                        callerFile: filePath !== null ? filePath : '(unknown)',
                        callerLine: lineNumber !== null ? lineNumber : '(unknown)'
                    },
                    null,
                    null,
                    spec.filePath,
                    spec.lineNumber
                );
            }

            // Validate the argument as the parameter requires
            parameter.validateArgument(argumentReferenceList[index]);
        });
    }
});

module.exports = FunctionSpec;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/FunctionSpecFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/FunctionSpecFactory.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates FunctionSpec-related objects
 *
 * @param {class} FunctionSpec
 * @param {class} FunctionContext
 * @param {class} MethodContext
 * @param {class} ClosureContext
 * @param {CallStack} callStack
 * @param {ParameterListFactory} parameterListFactory
 * @param {ValueFactory} valueFactory
 * @constructor
 */
function FunctionSpecFactory(
    FunctionSpec,
    FunctionContext,
    MethodContext,
    ClosureContext,
    callStack,
    parameterListFactory,
    valueFactory
) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {class}
     */
    this.ClosureContext = ClosureContext;
    /**
     * @type {class}
     */
    this.FunctionContext = FunctionContext;
    /**
     * @type {class}
     */
    this.FunctionSpec = FunctionSpec;
    /**
     * @type {class}
     */
    this.MethodContext = MethodContext;
    /**
     * @type {ParameterListFactory}
     */
    this.parameterListFactory = parameterListFactory;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(FunctionSpecFactory.prototype, {
    /**
     * Creates a FunctionSpec for a function alias
     *
     * @param {NamespaceScope} namespaceScope
     * @param {string} functionName
     * @param {Parameter[]} parameters
     * @param {string|null} filePath
     * @param {number|null} lineNumber
     * @returns {FunctionSpec}
     */
    createAliasFunctionSpec: function (namespaceScope, functionName, parameters, filePath, lineNumber) {
        var factory = this,
            context = new factory.FunctionContext(namespaceScope, functionName);

        return new factory.FunctionSpec(
            factory.callStack,
            factory.valueFactory,
            context,
            namespaceScope,
            parameters,
            filePath,
            lineNumber
        );
    },

    /**
     * Creates a FunctionSpec from the given spec data for a closure
     *
     * @param {NamespaceScope} namespaceScope
     * @param {Class|null} classObject
     * @param {Array} parametersSpecData
     * @param {string|null} filePath
     * @param {number|null} lineNumber
     * @returns {FunctionSpec}
     */
    createClosureSpec: function (namespaceScope, classObject, parametersSpecData, filePath, lineNumber) {
        var factory = this,
            context = new factory.ClosureContext(namespaceScope, classObject),
            parameters = factory.parameterListFactory.createParameterList(
                context,
                parametersSpecData,
                namespaceScope,
                filePath,
                lineNumber
            );

        return new factory.FunctionSpec(
            factory.callStack,
            factory.valueFactory,
            context,
            namespaceScope,
            parameters,
            filePath,
            lineNumber
        );
    },

    /**
     * Creates a FunctionSpec from the given spec data
     *
     * @param {NamespaceScope} namespaceScope
     * @param {string} functionName
     * @param {Array} parametersSpecData
     * @param {string|null} filePath
     * @param {number|null} lineNumber
     * @returns {FunctionSpec}
     */
    createFunctionSpec: function (namespaceScope, functionName, parametersSpecData, filePath, lineNumber) {
        var factory = this,
            context = new factory.FunctionContext(namespaceScope, functionName),
            parameters = factory.parameterListFactory.createParameterList(
                context,
                parametersSpecData,
                namespaceScope,
                filePath,
                lineNumber
            );

        return new factory.FunctionSpec(
            factory.callStack,
            factory.valueFactory,
            context,
            namespaceScope,
            parameters,
            filePath,
            lineNumber
        );
    },

    /**
     * Creates a FunctionSpec from the given spec data for a method
     *
     * @param {NamespaceScope} namespaceScope
     * @param {Class} classObject
     * @param {string} methodName
     * @param {Array} parametersSpecData
     * @param {string|null} filePath
     * @param {number|null} lineNumber
     * @returns {FunctionSpec}
     */
    createMethodSpec: function (namespaceScope, classObject, methodName, parametersSpecData, filePath, lineNumber) {
        var factory = this,
            context = new factory.MethodContext(classObject, methodName),
            parameters = factory.parameterListFactory.createParameterList(
                context,
                parametersSpecData,
                namespaceScope,
                filePath,
                lineNumber
            );

        return new factory.FunctionSpec(
            factory.callStack,
            factory.valueFactory,
            context,
            namespaceScope,
            parameters,
            filePath,
            lineNumber
        );
    }
});

module.exports = FunctionSpecFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/MethodContext.js":
/*!************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/MethodContext.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    FunctionContextInterface = __webpack_require__(/*! ./FunctionContextInterface */ "./node_modules/phpcore/src/Function/FunctionContextInterface.js");

/**
 * Represents a PHP method function
 *
 * @param {Class} classObject
 * @param {string|null} name
 * @constructor
 * @implements {FunctionContextInterface}
 */
function MethodContext(classObject, name) {
    /**
     * @type {Class}
     */
    this.classObject = classObject;
    /**
     * @type {string|null}
     */
    this.name = name;
}

util.inherits(MethodContext, FunctionContextInterface);

_.extend(MethodContext.prototype, {
    /**
     * Fetches the fully-qualified name of the method
     *
     * @param {boolean=} isStaticCall
     * @returns {string}
     */
    getName: function (isStaticCall) {
        var spec = this;

        return spec.classObject.getName() + (isStaticCall !== false ? '::' : '->') + spec.name;
    },

    /**
     * Fetches the name of the method as required for stack traces
     *
     * @param {boolean=} isStaticCall
     * @returns {string}
     */
    getTraceFrameName: function (isStaticCall) {
        return this.getName(isStaticCall);
    },

    /**
     * Fetches the name of the method, without any qualifying namespace and/or class prefix
     * (eg. as used by __FUNCTION__)
     *
     * @returns {string}
     */
    getUnprefixedName: function () {
        return this.name;
    }
});

module.exports = MethodContext;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/Parameter.js":
/*!********************************************************!*\
  !*** ./node_modules/phpcore/src/Function/Parameter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError,
    Value = __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js").sync(),

    INSTANCE_OF_TYPE_ACTUAL = 'core.instance_of_type_actual',
    INVALID_VALUE_FOR_TYPE = 'core.invalid_value_for_type',
    ONLY_VARIABLES_BY_REFERENCE = 'core.only_variables_by_reference',
    UNKNOWN = 'core.unknown';

/**
 * Represents a parameter to a PHP function
 *
 * @param {CallStack} callStack
 * @param {Translator} translator
 * @param {string|null} name
 * @param {number} index
 * @param {TypeInterface} typeObject
 * @param {FunctionContextInterface} context
 * @param {boolean} passedByReference
 * @param {Function|null} defaultValueProvider
 * @param {string|null} filePath
 * @param {number|null} lineNumber
 * @constructor
 */
function Parameter(
    callStack,
    translator,
    name,
    index,
    typeObject,
    context,
    passedByReference,
    defaultValueProvider,
    filePath,
    lineNumber
) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {FunctionContextInterface}
     */
    this.context = context;
    /**
     * @type {Function|null}
     */
    this.defaultValueProvider = defaultValueProvider;
    /**
     * @type {string|null}
     */
    this.filePath = filePath;
    /**
     * @type {number}
     */
    this.index = index;
    /**
     * @type {number|null}
     */
    this.lineNumber = lineNumber;
    /**
     * @type {string|null}
     */
    this.name = name;
    /**
     * @type {boolean}
     */
    this.passedByReference = passedByReference;
    /**
     * @type {Translator}
     */
    this.translator = translator;
    /**
     * @type {TypeInterface}
     */
    this.typeObject = typeObject;
}

_.extend(Parameter.prototype, {
    /**
     * Coerces the given argument for this parameter to a suitable value or reference,
     * causing the correct notice to be raised if an undefined variable or reference
     * is given where a value was expected
     *
     * @param {Reference|Value|Variable} argumentReference
     * @returns {Reference|Value|Variable}
     */
    coerceArgument: function (argumentReference) {
        var parameter = this;

        if (parameter.passedByReference) {
            // It is valid to pass an undefined variable/reference to a by-ref parameter
            return argumentReference;
        }

        return argumentReference.getValue();
    },

    /**
     * Fetches the line number this parameter was defined on, if known
     *
     * @returns {number|null}
     */
    getLineNumber: function () {
        return this.lineNumber;
    },

    /**
     * Determines whether this parameter must have an argument provided.
     * Arguments are required for PHP function parameters unless that parameter defines a default value
     *
     * @returns {boolean}
     */
    isRequired: function () {
        return this.defaultValueProvider === null;
    },

    /**
     * Fetches the default value for this parameter if its argument is missing
     *
     * @param {Reference|Value|Variable|null=} argumentReference
     * @returns {Reference|Value|Variable}
     */
    populateDefaultArgument: function (argumentReference) {
        var parameter = this;

        if (!argumentReference) {
            if (parameter.isRequired()) {
                // This should never happen - the scenario is captured within FunctionSpec
                throw new Error('Missing argument for required parameter "' + parameter.name + '"');
            }

            argumentReference = parameter.defaultValueProvider();
        }

        // TODO: For PHP 7, if the caller is in weak mode then we need to coerce if the type is scalar

        // Make sure we preserve any reference rather than always casting to value
        return argumentReference;
    },

    /**
     * Validates whether the given argument is valid for this parameter
     *
     * @param {Reference|Value|Variable|null=} argumentReference
     */
    validateArgument: function (argumentReference) {
        var actualType,
            argumentIsValid,
            argumentValue,
            callerFilePath = null,
            callerLineNumber = null,
            definitionFilePath,
            definitionLineNumber,
            expectedType,
            parameter = this;

        if (parameter.passedByReference && argumentReference instanceof Value) {
            // Parameter expects a reference but was given a value - error
            parameter.callStack.raiseTranslatedError(
                PHPError.E_ERROR,
                ONLY_VARIABLES_BY_REFERENCE,
                {},
                null,
                false,
                parameter.callStack.getCallerFilePath(),
                parameter.callStack.getCallerLastLine()
            );
        }

        if (!argumentReference) {
            if (parameter.isRequired()) {
                // This should never happen - the scenario is captured within FunctionSpec
                throw new Error('Missing argument for required parameter "' + parameter.name + '"');
            }

            // Argument was omitted but its parameter is optional: allow it through, we'll use its default value
            return;
        }

        argumentValue = argumentReference.getValueOrNull();

        argumentIsValid =
            // Check whether the type allows the given argument (including null,
            // if it is a nullable type) or ...
            parameter.typeObject.allowsValue(argumentValue) ||
            (
                // ... otherwise if null is given but not allowed by the type,
                // null will need to have been given as the default value in order to be allowed
                argumentValue.getType() === 'null' &&
                parameter.defaultValueProvider &&
                parameter.defaultValueProvider().getType() === 'null'
            );

        if (!argumentIsValid) {
            // TODO: For PHP 7, if the caller is in weak mode then we need to coerce if the type is scalar

            definitionFilePath = parameter.filePath || parameter.translator.translate(UNKNOWN);
            definitionLineNumber = parameter.lineNumber || parameter.translator.translate(UNKNOWN);

            if (parameter.callStack.getCurrent()) {
                callerFilePath = parameter.callStack.getCallerFilePath();
                callerLineNumber = parameter.callStack.getCallerLastLine();
            }

            actualType = argumentValue.getDisplayType();
            expectedType = parameter.typeObject.getExpectedMessage(parameter.translator);

            if (argumentValue.getType() === 'object') {
                actualType = parameter.translator.translate(INSTANCE_OF_TYPE_ACTUAL, {
                    actualType: actualType
                });
            }

            // Parameter is typehinted as expecting instances of a class or interface,
            // but the given argument does not match
            parameter.callStack.raiseTranslatedError(
                PHPError.E_ERROR,
                INVALID_VALUE_FOR_TYPE,
                {
                    index: parameter.index + 1,
                    func: parameter.context.getName(),
                    expectedType: expectedType,
                    actualType: actualType,
                    callerFile: callerFilePath !== null ? callerFilePath : parameter.translator.translate(UNKNOWN),
                    callerLine: callerLineNumber !== null ? callerLineNumber : parameter.translator.translate(UNKNOWN),
                    definitionFile: definitionFilePath,
                    definitionLine: definitionLineNumber
                },
                'TypeError',
                true,
                definitionFilePath,
                definitionLineNumber
            );
        }
    }
});

module.exports = Parameter;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/ParameterFactory.js":
/*!***************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/ParameterFactory.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {class} Parameter
 * @param {CallStack} callStack
 * @param {Translator} translator
 * @constructor
 */
function ParameterFactory(Parameter, callStack, translator) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {class}
     */
    this.Parameter = Parameter;
    /**
     * @type {Translator}
     */
    this.translator = translator;
}

_.extend(ParameterFactory.prototype, {
    /**
     * Creates a Parameter from the given spec data
     *
     * @param {string|null} name
     * @param {number} index
     * @param {Type} typeObject
     * @param {FunctionContextInterface} context
     * @param {boolean} passedByReference
     * @param {Function|null} defaultValueProvider
     * @param {string|null} filePath
     * @param {number|null} lineNumber
     * @returns {Parameter}
     */
    createParameter: function (
        name,
        index,
        typeObject,
        context,
        passedByReference,
        defaultValueProvider,
        filePath,
        lineNumber
    ) {
        var factory = this;

        return new factory.Parameter(
            factory.callStack,
            factory.translator,
            name,
            index,
            typeObject,
            context,
            passedByReference,
            defaultValueProvider,
            filePath,
            lineNumber
        );
    }
});

module.exports = ParameterFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/ParameterListFactory.js":
/*!*******************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/ParameterListFactory.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates the correct Parameters from a function, closure or method parameter list spec
 *
 * @param {ParameterFactory} parameterFactory
 * @param {ParameterTypeFactory} parameterTypeFactory
 * @constructor
 */
function ParameterListFactory(parameterFactory, parameterTypeFactory) {
    /**
     * @type {ParameterFactory}
     */
    this.parameterFactory = parameterFactory;
    /**
     * @type {ParameterTypeFactory}
     */
    this.parameterTypeFactory = parameterTypeFactory;
}

_.extend(ParameterListFactory.prototype, {
    /**
     * Creates the correct Parameters from a function, closure or method parameter list spec
     *
     * @param {FunctionContextInterface} context
     * @param {Array} parametersSpecData
     * @param {NamespaceScope} namespaceScope
     * @param {string|null} filePath
     * @param {number|null} lineNumber
     * @returns {Parameter[]|null[]}
     */
    createParameterList: function (
        context,
        parametersSpecData,
        namespaceScope,
        filePath,
        lineNumber
    ) {
        var factory = this,
            parameters = [];

        _.each(parametersSpecData, function (parameterSpecData, parameterIndex) {
            var parameterType;

            if (!parameterSpecData) {
                // Parameter is omitted due to bundle-size optimisations or similar, ignore
                parameters.push(null);

                return;
            }

            parameterType = factory.parameterTypeFactory.createParameterType(parameterSpecData, namespaceScope);

            parameters.push(factory.parameterFactory.createParameter(
                parameterSpecData.name,
                parameterIndex,
                parameterType,
                context,
                parameterSpecData.ref,
                parameterSpecData.value || null,
                filePath,
                lineNumber
            ));
        });

        return parameters;
    }
});

module.exports = ParameterListFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Function/ParameterTypeFactory.js":
/*!*******************************************************************!*\
  !*** ./node_modules/phpcore/src/Function/ParameterTypeFactory.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates the correct Type from a function, closure or method parameter spec
 *
 * @param {TypeFactory} typeFactory
 * @constructor
 */
function ParameterTypeFactory(typeFactory) {
    /**
     * @type {TypeFactory}
     */
    this.typeFactory = typeFactory;
}

_.extend(ParameterTypeFactory.prototype, {
    /**
     * Creates the correct Type from a function, closure or method parameter spec
     *
     * @param {Object} parameterSpecData
     * @param {NamespaceScope} namespaceScope
     * @returns {TypeInterface}
     */
    createParameterType: function (parameterSpecData, namespaceScope) {
        var factory = this,
            resolvedClass;

        switch (parameterSpecData.type) {
            case 'array':
                return factory.typeFactory.createArrayType();
            case 'callable':
                return factory.typeFactory.createCallableType(namespaceScope);
            case 'class':
                // We must now resolve the class name given relative to the current namespace scope,
                // as it may be a relative class name that relies on the current namespace or a `use` import
                resolvedClass = namespaceScope.resolveClass(parameterSpecData.className);

                return factory.typeFactory.createClassType(resolvedClass.namespace.getPrefix() + resolvedClass.name);
            case 'iterable':
                return factory.typeFactory.createIterableType();
            case undefined:
                return factory.typeFactory.createMixedType();
            default:
                throw new Error('Unsupported parameter type "' + parameterSpecData.type + '"');
        }
    }
});

module.exports = ParameterTypeFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/FunctionFactory.js":
/*!*****************************************************!*\
  !*** ./node_modules/phpcore/src/FunctionFactory.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    var slice = [].slice;

    /**
     * @param {class} MethodSpec
     * @param {ScopeFactory} scopeFactory
     * @param {CallFactory} callFactory
     * @param {ValueFactory} valueFactory
     * @param {CallStack} callStack
     * @constructor
     */
    function FunctionFactory(
        MethodSpec,
        scopeFactory,
        callFactory,
        valueFactory,
        callStack
    ) {
        /**
         * @type {CallFactory}
         */
        this.callFactory = callFactory;
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {class}
         */
        this.MethodSpec = MethodSpec;
        /**
         * @type {Class|null}
         */
        this.newStaticClassForNextCall = null;
        /**
         * @type {ScopeFactory}
         */
        this.scopeFactory = scopeFactory;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(FunctionFactory.prototype, {
        /**
         * Wraps the specified function in another that handles the PHP call stack and scoping
         *
         * @param {NamespaceScope} namespaceScope
         * @param {Class|null} currentClass Used by eg. self::
         * @param {Function} func
         * @param {string|null} name
         * @param {ObjectValue|null} currentObject
         * @param {Class|null} staticClass Used by eg. static::
         * @param {FunctionSpec} functionSpec
         * @returns {Function}
         */
        create: function (namespaceScope, currentClass, func, name, currentObject, staticClass, functionSpec) {
            var factory = this,
                wrapperFunc = function () {
                    var args = slice.call(arguments),
                        thisObject = currentObject || this,
                        scope,
                        call,
                        newStaticClass = null,
                        result;

                    if (factory.newStaticClassForNextCall !== null) {
                        newStaticClass = factory.newStaticClassForNextCall;
                        factory.newStaticClassForNextCall = null;
                    } else if (staticClass) {
                        // Allow an explicit static class to be specified, eg. by a Closure
                        newStaticClass = staticClass;
                    }

                    if (!factory.valueFactory.isValue(thisObject)) {
                        thisObject = null;
                    }

                    // Coerce parameter arguments as required
                    args = functionSpec.coerceArguments(args);

                    scope = factory.scopeFactory.create(currentClass, wrapperFunc, thisObject);
                    call = factory.callFactory.create(scope, namespaceScope, args, newStaticClass);

                    // Push the call onto the stack
                    factory.callStack.push(call);

                    try {
                        // Now validate the arguments at this point (coercion was done earlier)
                        // - if any error is raised then the call will still be popped off
                        //   by the finally clause below
                        functionSpec.validateArguments(args);

                        // Now populate any optional arguments that were omitted with their default values
                        args = functionSpec.populateDefaultArguments(args);

                        result = func.apply(scope, args);

                        // Coerce the result to a Value object, handling any FFIResult as needed
                        // (in async mode this could result in a pause if required)
                        result = factory.valueFactory.coerce(result);

                        // TODO: Coerce the result as needed (if the PHP function has a return type defined
                        //       and we are in loose-types mode)
                    } finally {
                        // Pop the call off the stack when done
                        factory.callStack.pop();
                    }

                    return result;
                };

            wrapperFunc.functionSpec = functionSpec;
            wrapperFunc.isPHPCoreWrapped = true;
            wrapperFunc.originalFunc = func;

            return wrapperFunc;
        },

        /**
         * Creates a new MethodSpec, that describes the specified method of a class
         *
         * @TODO: Replace with FunctionSpec instead?
         *
         * @param {Class} originalClass The original class checked against (eg. a derived class for an inherited method)
         * @param {Class} classObject The class the method is actually defined on (may be an ancestor)
         * @param {string} methodName
         * @param {Function} method
         */
        createMethodSpec: function (originalClass, classObject, methodName, method) {
            return new this.MethodSpec(originalClass, classObject, methodName, method);
        },

        /**
         * Specifies the class to use as the static:: class for the next call
         * to the specified wrapped function
         *
         * @param {Function} func
         * @param {Class} newStaticClass
         */
        setNewStaticClassIfWrapped: function (func, newStaticClass) {
            if (!func.isPHPCoreWrapped) {
                return;
            }

            this.newStaticClassForNextCall = newStaticClass;
        }
    });

    return FunctionFactory;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/INIState.js":
/*!**********************************************!*\
  !*** ./node_modules/phpcore/src/INIState.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    hasOwn = {}.hasOwnProperty;

/**
 * Contains all INI options at runtime
 *
 * @constructor
 */
function INIState() {
    /**
     * @type {Object.<string, *>}
     */
    this.settings = {
        'include_path': '.'
    };
}

_.extend(INIState.prototype, {
    /**
     * Fetches an INI option, returning null if it is not defined
     *
     * @param {string} name
     * @returns {*}
     */
    get: function (name) {
        return hasOwn.call(this.settings, name) ?
            this.settings[name] :
            null;
    },

    /**
     * Sets the value of an INI option
     *
     * @param {string} name
     * @param {*} value
     */
    set: function (name, value) {
        this.settings[name] = value;
    }
});

module.exports = INIState;


/***/ }),

/***/ "./node_modules/phpcore/src/Iterator/ArrayIterator.js":
/*!************************************************************!*\
  !*** ./node_modules/phpcore/src/Iterator/ArrayIterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Used by transpiled foreach(...) statements to iterate over the elements in an array
 * or the properties of an object that does not implement Traversable
 *
 * @param {ArrayValue|ObjectValue} arrayLikeValue
 * @constructor
 */
function ArrayIterator(arrayLikeValue) {
    /**
     * @type {ArrayValue|ObjectValue}
     */
    this.arrayLikeValue = arrayLikeValue;
    /**
     * @type {number}
     */
    this.pointer = 0;
}

_.extend(ArrayIterator.prototype, {
    /**
     * Advances this iterator to the next element
     */
    advance: function () {
        this.pointer++;
    },

    /**
     * Fetches a reference to the element this iterator is currently pointing at
     *
     * @returns {Reference}
     */
    getCurrentElementReference: function () {
        var iterator = this;

        return iterator.arrayLikeValue.getElementByIndex(iterator.pointer).getReference();
    },

    /**
     * Fetches the value of the element this iterator is currently pointing at
     *
     * @returns {Value}
     */
    getCurrentElementValue: function () {
        var iterator = this;

        return iterator.arrayLikeValue.getElementByIndex(iterator.pointer).getValue();
    },

    /**
     * Fetches the key of the element this iterator is currently pointing at.
     * If the array is empty or the pointer is past the end of the array,
     * null will be returned.
     *
     * @returns {Value|null}
     */
    getCurrentKey: function () {
        var iterator = this;

        return iterator.arrayLikeValue.getKeyByIndex(iterator.pointer);
    },

    /**
     * Fetches the ArrayValue or ObjectValue that this iterator iterates over
     *
     * @returns {ArrayValue|ObjectValue}
     */
    getIteratedValue: function () {
        return this.arrayLikeValue;
    },

    /**
     * Determines whether this iterator is pointing past the end of the array being iterated over
     *
     * @returns {boolean}
     */
    isNotFinished: function () {
        var iterator = this;

        return iterator.pointer < iterator.arrayLikeValue.getLength();
    }
});

module.exports = ArrayIterator;


/***/ }),

/***/ "./node_modules/phpcore/src/KeyReferencePair.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcore/src/KeyReferencePair.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

function KeyReferencePair(key, reference) {
    this.key = key;
    this.reference = reference;
}

_.extend(KeyReferencePair.prototype, {
    getKey: function () {
        return this.key;
    },

    getReference: function () {
        return this.reference;
    }
});

module.exports = KeyReferencePair;


/***/ }),

/***/ "./node_modules/phpcore/src/KeyValuePair.js":
/*!**************************************************!*\
  !*** ./node_modules/phpcore/src/KeyValuePair.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

function KeyValuePair(key, value) {
    this.key = key;
    this.value = value;
}

_.extend(KeyValuePair.prototype, {
    getKey: function () {
        return this.key;
    },

    getValue: function () {
        return this.value;
    }
});

module.exports = KeyValuePair;


/***/ }),

/***/ "./node_modules/phpcore/src/List.js":
/*!******************************************!*\
  !*** ./node_modules/phpcore/src/List.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

function List(valueFactory, elements) {
    this.elements = elements;
    this.valueFactory = valueFactory;
}

_.extend(List.prototype, {
    setValue: function (value) {
        var list = this;

        if (value.getType() === 'array') {
            _.each(list.elements, function (reference, index) {
                reference.setValue(value.getElementByIndex(index).getValue());
            });
        } else {
            // Non-array value assigned to list, all references should just be nulled
            _.each(list.elements, function (reference) {
                reference.setValue(list.valueFactory.createNull());
            });
        }

        return value;
    }
});

module.exports = List;


/***/ }),

/***/ "./node_modules/phpcore/src/LoadScope.js":
/*!***********************************************!*\
  !*** ./node_modules/phpcore/src/LoadScope.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Wraps a Scope having a load (eval, include etc.) performed from inside it
 *
 * @param {ValueFactory} valueFactory
 * @param {Scope} effectiveScope
 * @param {string} callerFilePath
 * @param {string} type The type of load, eg. `eval` or `include`
 * @constructor
 */
function LoadScope(valueFactory, effectiveScope, callerFilePath, type) {
    /**
     * @type {string}
     */
    this.callerFilePath = callerFilePath;
    /**
     * @type {Scope}
     */
    this.effectiveScope = effectiveScope;
    /**
     * @type {string}
     */
    this.type = type;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(LoadScope.prototype, {
    /**
     * Creates a closure, either static (with no `$this` object bound) or non-static
     *
     * @param {NamespaceScope} namespaceScope
     * @param {Function} func
     * @param {Array=} parametersSpecData
     * @param {boolean=} isStatic
     * @param {number|null=} lineNumber
     * @returns {Closure}
     */
    createClosure: function (namespaceScope, func, parametersSpecData, isStatic, lineNumber) {
        return this.effectiveScope.createClosure(
            namespaceScope,
            func,
            parametersSpecData,
            isStatic,
            lineNumber
        );
    },

    /**
     * Defines a variable with the given name in this scope
     *
     * @param {string} name
     * @returns {Variable}
     */
    defineVariable: function (name) {
        return this.effectiveScope.defineVariable(name);
    },

    /**
     * Defines one or more variables with the given names in this scope
     *
     * @param {string[]} names
     */
    defineVariables: function (names) {
        this.effectiveScope.defineVariables(names);
    },

    /**
     * Returns a hash with the values of all variables defined
     * for this scope, including all superglobals
     *
     * @returns {Object.<string, Value>}
     */
    exportVariables: function () {
        return this.effectiveScope.exportVariables();
    },

    /**
     * Defines a variable in the current scope with the given native value
     *
     * @param {Value} value
     * @param {string} name
     */
    expose: function (value, name) {
        this.effectiveScope.expose(value, name);
    },

    /**
     * Fetches the name of the current class, or an empty string if there is none
     *
     * @returns {StringValue}
     */
    getClassName: function () {
        return this.effectiveScope.getClassName();
    },

    /**
     * Fetches the name of the class in which this scope's function is defined
     *
     * @returns {StringValue}
     * @throws {PHPFatalError} When there is no current class scope
     */
    getClassNameOrThrow: function () {
        return this.effectiveScope.getClassNameOrThrow();
    },

    /**
     * Fetches the current class, if any
     *
     * @returns {Class|null}
     */
    getCurrentClass: function () {
        return this.effectiveScope.getCurrentClass();
    },

    /**
     * Fetches the current file path, taking eval or include into account
     *
     * @param {string|null} filePath
     * @returns {string|null}
     */
    getFilePath: function (filePath) {
        return filePath !== null ? filePath : this.callerFilePath;
    },

    /**
     * Fetches the current function name (used by eg. the magic __FUNCTION__ constant)
     *
     * @returns {StringValue}
     */
    getFunctionName: function () {
        // Eval/include contexts do not report the calling function, if any
        return this.valueFactory.createString('');
    },

    /**
     * Fetches the current method name (used by eg. the magic __METHOD__ constant)
     *
     * Note that this differs from .getFunctionName() when the current function is a method
     *
     * @returns {StringValue}
     */
    getMethodName: function () {
        // Eval/include contexts do not report the calling method, if any
        return this.valueFactory.createString('');
    },

    /**
     * Fetches the name of the parent of the current class in scope
     *
     * @returns {StringValue}
     * @throws {PHPFatalError} When there is no current class scope or current class has no parent
     */
    getParentClassNameOrThrow: function () {
        return this.effectiveScope.getParentClassNameOrThrow();
    },

    /**
     * Fetches the name of the current static class scope, which may be different
     * from the class in which its function is defined (eg. after a forward_static_call(...))
     *
     * @returns {StringValue}
     * @throws {PHPFatalError} When there is no static class scope
     */
    getStaticClassNameOrThrow: function () {
        return this.effectiveScope.getStaticClassNameOrThrow();
    },

    /**
     * Fetches the current object (the value of $this) if any
     *
     * @returns {ObjectValue|null}
     */
    getThisObject: function () {
        return this.effectiveScope.getThisObject();
    },

    /**
     * Fetches the current function or method name as used in stack traces
     *
     * Note that this differs from .getFunctionName() and .getMethodName()
     *
     * @returns {string}
     */
    getTraceFrameName: function () {
        return this.type;
    },

    /**
     * Fetches a variable for the current or super global scope,
     * implicitly defining it if needed
     *
     * @param {string} name
     * @returns {Variable}
     */
    getVariable: function (name) {
        return this.effectiveScope.getVariable(name);
    },

    /**
     * Imports a global variable into this scope by defining the variable
     * in this scope and setting its reference to point to the global one.
     *
     * @param {string} variableName
     */
    importGlobal: function (variableName) {
        this.effectiveScope.importGlobal(variableName);
    },

    /**
     * Imports a static variable into this scope by defining the variable
     * in this scope and setting its reference to point to the "static" one,
     * stored against the current function/method. The first time the variable
     * is declared, it will be assigned the initial value (if any).
     *
     * @param {string} variableName
     * @param {Value|null} initialValue
     */
    importStatic: function (variableName, initialValue) {
        this.effectiveScope.importStatic(variableName, initialValue);
    },

    /**
     * Whether this call scope is in a static context or not
     *
     * @returns {boolean}
     */
    isStatic: function () {
        return this.effectiveScope.isStatic();
    },

    /**
     * Raises a catchable Error or a notice/warning with the specified level, message translation key and variables,
     * scoped to the current function scope
     *
     * @param {string} level One of the PHPError.E_* constants, eg. `PHPError.E_WARNING`
     * @param {string} translationKey
     * @param {Object.<string, string>=} placeholderVariables
     * @param {string=} errorClass
     * @param {boolean=} reportsOwnContext Whether the error handles reporting its own file/line context
     * @param {string=} filePath
     * @param {number=} lineNumber
     * @throws {ObjectValue} Throws an ObjectValue-wrapped Throwable if not a notice or warning
     */
    raiseScopedTranslatedError: function (
        level,
        translationKey,
        placeholderVariables,
        errorClass,
        reportsOwnContext,
        filePath,
        lineNumber
    ) {
        this.effectiveScope.raiseScopedTranslatedError(
            level,
            translationKey,
            placeholderVariables,
            errorClass,
            reportsOwnContext,
            filePath,
            lineNumber
        );
    },

    /**
     * Suppresses errors for this and any descendant scopes
     */
    suppressErrors: function () {
        this.effectiveScope.suppressErrors();
    },

    /**
     * Suppresses errors for only this and not any descendant scopes
     */
    suppressOwnErrors: function () {
        this.effectiveScope.suppressOwnErrors();
    },

    /**
     * Determines whether errors have been suppressed for this and any descendant scopes
     *
     * @returns {boolean}
     */
    suppressesErrors: function () {
        return this.effectiveScope.suppressesErrors();
    },

    /**
     * Determines whether errors have been suppressed for this but not any descendant scopes
     *
     * @returns {boolean}
     */
    suppressesOwnErrors: function () {
        return this.effectiveScope.suppressesOwnErrors();
    },

    /**
     * Unsuppresses errors for this and any descendant scopes
     */
    unsuppressErrors: function () {
        this.effectiveScope.unsuppressErrors();
    },

    /**
     * Unsuppresses errors for this but not any descendant scopes
     */
    unsuppressOwnErrors: function () {
        this.effectiveScope.unsuppressOwnErrors();
    }
});

module.exports = LoadScope;


/***/ }),

/***/ "./node_modules/phpcore/src/Loader.js":
/*!********************************************!*\
  !*** ./node_modules/phpcore/src/Loader.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ./Value/Exit */ "./node_modules/phpcore/src/Value/Exit.js"),
    __webpack_require__(/*! ./Exception/LoadFailedException */ "./node_modules/phpcore/src/Exception/LoadFailedException.js"),
    __webpack_require__(/*! ./Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    path,
    phpCommon,
    ExitValue,
    LoadFailedException,
    Value
) {
    var Exception = phpCommon.Exception,
        PHPFatalError = phpCommon.PHPFatalError,
        PHPParseError = phpCommon.PHPParseError;

    /**
     * @param {ValueFactory} valueFactory
     * @param {Resumable|null} pausable
     * @constructor
     */
    function Loader(valueFactory, pausable) {
        /**
         * @type {Resumable|null}
         */
        this.pausable = pausable;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(Loader.prototype, {
        /**
         * Loads a resource by calling the provided loader. Used for:
         *
         * - `include(...)`
         * - `require(...)`
         * - `eval(...)`
         *
         * When the relevant transport options are installed.
         *
         * @param {string} type The type of load to be done, eg. `eval` or `include`
         * @param {string} filePath The path to the resource being loaded
         * @param {object} options
         * @param {Environment} environment
         * @param {Module} module
         * @param {Scope} enclosingScope
         * @param {Function} load
         * @returns {*}
         */
        load: function (type, filePath, options, environment, module, enclosingScope, load) {
            var done = false,
                errorResult = null,
                loader = this,
                pause = null,
                result,
                subOptions;

            function completeWith(moduleResult) {
                done = true;

                if (pause) {
                    if (moduleResult instanceof ExitValue) {
                        pause.throw(moduleResult);
                        return;
                    }

                    pause.resume(moduleResult);
                } else {
                    if (moduleResult instanceof ExitValue) {
                        throw moduleResult;
                    }

                    result = moduleResult;
                }
            }

            function resolve(valueOrModule) {
                var executeResult;

                // Handle wrapper function being returned from loader for module
                if (_.isFunction(valueOrModule)) {
                    executeResult = valueOrModule(subOptions, environment, enclosingScope).execute();

                    if (!loader.pausable) {
                        completeWith(executeResult);
                        return;
                    }

                    executeResult.then(
                        completeWith,
                        function (error) {
                            pause.throw(error);
                        }
                    );

                    return;
                }

                // Handle PHP code string being returned from loader for module
                if (_.isString(valueOrModule)) {
                    throw new Exception(type + '(' + filePath + ') :: Returning a PHP string is not supported');
                }

                // Handle a value object being returned as the module's return value
                if (loader.valueFactory.isValue(valueOrModule)) {
                    completeWith(valueOrModule);
                    return;
                }

                throw new Exception(type + '(' + filePath + ') :: Module is in a weird format');
            }

            function reject(error) {
                var filePath,
                    lineNumber,
                    subError;

                if (error instanceof PHPParseError) {
                    filePath = error.getFilePath();
                    lineNumber = error.getLineNumber();

                    // Parse errors should be thrown as a ParseError in PHP 7+
                    // NB: The Error class' constructor will fetch file and line number info
                    subError = loader.valueFactory.createErrorObject(
                        'ParseError',
                        error.getMessage(),
                        null,
                        null,
                        filePath !== null ? filePath : '(unknown)',
                        lineNumber !== null ? lineNumber : 0
                    );
                } else if (error instanceof PHPFatalError) {
                    // Uncatchable fatal error (?)

                    subError = error;
                } else if (error instanceof Value) {
                    // Throwable Error, Exception or an exit occurred (ExitValue)

                    subError = error;
                } else {
                    subError = new LoadFailedException(error);
                }

                if (pause) {
                    pause.throw(subError);
                } else {
                    errorResult = subError;
                }
            }

            // Resolve "./" and "../" components in the file path
            filePath = path.normalize(filePath);

            subOptions = _.extend({}, options, {
                // TODO: Can we improve this? Can we include a module's path in its compiled output,
                //       rather than having the runtime provide its path like this?
                'path': filePath
            });

            // NB: The loader may throw an error, which will be caught and passed to reject()
            //     for consistent behaviour
            try {
                load(filePath, {
                    reject: reject,
                    resolve: resolve
                }, module.getFilePath(), loader.valueFactory);
            } catch (error) {
                reject(error);
            }

            if (errorResult) {
                throw errorResult;
            }

            if (done) {
                return result;
            }

            if (!loader.pausable) {
                // Pausable is not available, so we cannot yield while the module is loaded
                throw new Exception(type + '(' + filePath + ') :: Async support not enabled');
            }

            pause = loader.pausable.createPause();
            return pause.now();
        }
    });

    return Loader;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/MethodSpec.js":
/*!************************************************!*\
  !*** ./node_modules/phpcore/src/MethodSpec.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    IS_STATIC = 'isStatic';

/**
 * @param {Class} originalClass The original class checked against (eg. a derived class for an inherited method)
 * @param {Class} classObject The class the method is actually defined on (may be an ancestor)
 * @param {string} methodName
 * @param {Function} method
 * @constructor
 */
function MethodSpec(originalClass, classObject, methodName, method) {
    /**
     * @type {Class}
     */
    this.classObject = classObject;
    /**
     * @type {Function}
     */
    this.method = method;
    /**
     * @type {string}
     */
    this.methodName = methodName;
    /**
     * @type {Class}
     */
    this.originalClass = originalClass;
}

_.extend(MethodSpec.prototype, {
    /**
     * Fetches the name of the method this spec is for
     * 
     * @returns {string}
     */
    getMethodName: function () {
        return this.methodName;
    },

    /**
     * Determines whether this method is static (or an instance method)
     *
     * @returns {boolean}
     */
    isStatic: function () {
        return !!this.method[IS_STATIC];
    }
});

module.exports = MethodSpec;


/***/ }),

/***/ "./node_modules/phpcore/src/Module.js":
/*!********************************************!*\
  !*** ./node_modules/phpcore/src/Module.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {string|null} filePath
 * @constructor
 */
function Module(filePath) {
    /**
     * @type {string|null}
     */
    this.filePath = filePath || null;
}

_.extend(Module.prototype, {
    /**
     * Fetches the path to the file this module is defined in, or null if none
     *
     * @returns {string|null}
     */
    getFilePath: function () {
        return this.filePath;
    }
});

module.exports = Module;


/***/ }),

/***/ "./node_modules/phpcore/src/ModuleFactory.js":
/*!***************************************************!*\
  !*** ./node_modules/phpcore/src/ModuleFactory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {class} Module
 * @constructor
 */
function ModuleFactory(Module) {
    /**
     * @type {class}
     */
    this.Module = Module;
}

_.extend(ModuleFactory.prototype, {
    /**
     * Creates a new Module
     *
     * @param {string|null} filePath Path to the PHP file this module is defined in, or null if none
     * @returns {Module}
     */
    create: function (filePath) {
        return new this.Module(filePath);
    }
});

module.exports = ModuleFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Namespace.js":
/*!***********************************************!*\
  !*** ./node_modules/phpcore/src/Namespace.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ./Class */ "./node_modules/phpcore/src/Class.js")
], function (
    _,
    phpCommon,
    Class
) {
    var CALL_TO_UNDEFINED_FUNCTION = 'core.call_to_undefined_function',
        CANNOT_DECLARE_CLASS_AS_NAME_ALREADY_IN_USE = 'core.cannot_declare_class_as_name_already_in_use',
        CANNOT_IMPLEMENT_THROWABLE = 'core.cannot_implement_throwable',
        CANNOT_REDECLARE_CLASS_AS_NAME_ALREADY_IN_USE = 'core.cannot_redeclare_class_as_name_already_in_use',
        CLASS_NOT_FOUND = 'core.class_not_found',
        CONSTANT_ALREADY_DEFINED = 'core.constant_already_defined',
        UNDEFINED_CONSTANT = 'core.undefined_constant',

        IS_METHOD = 'isMethod',
        IS_STATIC = 'isStatic',
        MAGIC_CONSTRUCT = '__construct',
        hasOwn = {}.hasOwnProperty,
        PHPError = phpCommon.PHPError;

    /**
     * Represents a single namespace within the namespace hierarchy.
     * For example, the class path `My\Lib\SubNs\MyClass` defines the namespace `My`
     * under the global namespace, with a single Namespace instance for `My`.
     * `SubNs` is another instance, with `My\Lib` as its parent and `My` as its grandparent.
     *
     * The special global namespace has the empty string as its unique name,
     * along with null as its parent namespace.
     *
     * @param {CallStack} callStack
     * @param {ValueFactory} valueFactory
     * @param {NamespaceFactory} namespaceFactory
     * @param {FunctionFactory} functionFactory
     * @param {FunctionSpecFactory} functionSpecFactory
     * @param {ClassAutoloader} classAutoloader
     * @param {ExportRepository} exportRepository
     * @param {FFIFactory} ffiFactory
     * @param {Namespace|null} parent
     * @param {string} name
     * @constructor
     */
    function Namespace(
        callStack,
        valueFactory,
        namespaceFactory,
        functionFactory,
        functionSpecFactory,
        classAutoloader,
        exportRepository,
        ffiFactory,
        parent,
        name
    ) {
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {Object.<string, Namespace>}
         */
        this.children = {};
        /**
         * @type {ClassAutoloader}
         */
        this.classAutoloader = classAutoloader;
        /**
         * @type {Object.<string, Class>}
         */
        this.classes = {};
        /**
         * @type {Object.<string, {caseInsensitive: boolean, name: string, value: Value}>}
         */
        this.constants = {};
        /**
         * @type {ExportRepository}
         */
        this.exportRepository = exportRepository;
        /**
         * @type {FFIFactory}
         */
        this.ffiFactory = ffiFactory;
        /**
         * @type {FunctionFactory}
         */
        this.functionFactory = functionFactory;
        /**
         * @type {FunctionSpecFactory}
         */
        this.functionSpecFactory = functionSpecFactory;
        /**
         * @type {Object.<string, Function>}
         */
        this.functions = {};
        /**
         * @type {string}
         */
        this.name = name;
        /**
         * @type {NamespaceFactory}
         */
        this.namespaceFactory = namespaceFactory;
        /**
         * @type {Namespace|null}
         */
        this.parent = parent;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(Namespace.prototype, {
        /**
         * Defines the given alias for the given function
         *
         * @param {string} originalName
         * @param {string} aliasName
         * @throws {Error} Throws when the specified original function does not exist
         */
        aliasFunction: function (originalName, aliasName) {
            var existingFunction,
                namespace = this;

            if (!namespace.hasFunction(originalName)) {
                throw new Error('Cannot alias undefined function "' + originalName + '"');
            }

            existingFunction = namespace.getFunction(originalName);

            namespace.functions[aliasName.toLowerCase()] = existingFunction.functionSpec.createAliasFunction(
                aliasName,
                existingFunction.originalFunc,
                namespace.functionSpecFactory,
                namespace.functionFactory
            );
        },

        /**
         * Defines a class in the current namespace, either from a JS class/function or from a transpiled PHP class,
         * where PHPToJS has generated an object containing all the information related to the class
         *
         * @TODO: Consider moving this to NamespaceScope.defineClass(...) rather than having that injected
         *        as a required argument to this method?
         *
         * @param {string} name
         * @param {Function|object} definition Either a Function for a native JS class or a transpiled definition object
         * @param {NamespaceScope} namespaceScope
         * @param {boolean=} autoCoercionEnabled Whether the class should be auto-coercing
         * @returns {Class} Returns the internal Class instance created
         */
        defineClass: function (
            name,
            definition,
            namespaceScope,
            autoCoercionEnabled
        ) {
            var classObject,
                constants,
                constructorName = null,
                methodData = {},
                methods = {},
                namespace = this,
                proxyConstructor,
                rootInternalPrototype,
                staticProperties,
                InternalClass;

            autoCoercionEnabled = Boolean(autoCoercionEnabled);

            if (namespaceScope.hasClass(name)) {
                namespace.callStack.raiseUncatchableFatalError(
                    namespace.hasClass(name) ?
                        CANNOT_REDECLARE_CLASS_AS_NAME_ALREADY_IN_USE :
                        CANNOT_DECLARE_CLASS_AS_NAME_ALREADY_IN_USE,
                    {
                        className: namespace.getPrefix() + name
                    }
                );
            }

            if (_.isFunction(definition)) {
                // Class is defined using native JavaScript, not PHP

                // Create a new, empty native constructor so that we can avoid calling
                // the original if the derived class does not call parent::__construct(...)
                // - Unless the class defines the special `shadowConstructor` property, which
                //   is always called regardless of whether the parent constructor is called explicitly
                InternalClass = function () {
                    var objectValue = this;

                    if (definition.shadowConstructor) {
                        definition.shadowConstructor.call(
                            // Use the native object as the `this` object inside the shadow constructor
                            // if auto-coercion is enabled, otherwise use the ObjectValue
                            classObject.isAutoCoercionEnabled() ? objectValue.getObject() : objectValue
                        );
                    }

                    if (definition.superClass) {
                        // Class has a parent, call the parent's internal constructor
                        definition.superClass.getInternalClass().call(objectValue);
                    }
                };
                InternalClass.prototype = Object.create(definition.prototype);
                proxyConstructor = function () {
                    var
                        objectValue = this,
                        // Will be the native object as the `this` object inside the (shadow) constructor
                        // if auto-coercion is enabled, otherwise use the ObjectValue
                        unwrappedThisObject = classObject.isAutoCoercionEnabled() ?
                            objectValue.getObject() :
                            objectValue,
                        unwrappedArgs = classObject.unwrapArguments(arguments);

                    // Call the original native constructor
                    definition.apply(unwrappedThisObject, unwrappedArgs);

                    // Call magic __construct method if defined for the original native class
                    if (definition.prototype[MAGIC_CONSTRUCT]) {
                        definition.prototype[MAGIC_CONSTRUCT].apply(unwrappedThisObject, unwrappedArgs);
                    }
                };
                proxyConstructor.neverCoerce = true;
                proxyConstructor.data = methodData;
                InternalClass.prototype[MAGIC_CONSTRUCT] = proxyConstructor;
                constructorName = MAGIC_CONSTRUCT;

                // Record the prototype object that we should stop at when walking up the chain
                rootInternalPrototype = definition.prototype;
            } else {
                // Class has a definition, so it was defined using PHP

                // Ensure the class does not attempt to implement Throwable directly
                _.each(definition.interfaces, function (interfaceName) {
                    var resolvedClass = namespaceScope.resolveClass(interfaceName);

                    if (resolvedClass.namespace.getName() === '' && resolvedClass.name.toLowerCase() === 'throwable') {
                        namespace.callStack.raiseUncatchableFatalError(
                            CANNOT_IMPLEMENT_THROWABLE,
                            {
                                className: namespace.getPrefix() + name
                            }
                        );
                    }
                });

                InternalClass = function () {
                    var objectValue = this,
                        properties = {};

                    // Go through and declare the properties and their default values
                    // on the object from the class definition
                    _.forOwn(definition.properties, function (propertyData, name) {
                        properties[name] = objectValue.declareProperty(name, classObject, propertyData.visibility);
                    });

                    if (definition.superClass) {
                        // Class has a parent, call the parent's internal constructor
                        definition.superClass.getInternalClass().call(objectValue);
                    }

                    // Go through and define the properties and their default values
                    // on the object from the class definition by initialising them
                    _.forOwn(definition.properties, function (propertyData, name) {
                        var instanceProperty = properties[name],
                            initialValue = propertyData.value();

                        if (initialValue === null) {
                            // If a property has no initialiser then its initial value is NULL
                            initialValue = namespace.valueFactory.createNull();
                        }

                        instanceProperty.initialise(initialValue);
                    });
                };

                // Prevent native 'constructor' property from erroneously being detected as PHP class method
                delete InternalClass.prototype.constructor;

                if (definition.superClass) {
                    InternalClass.prototype = Object.create(definition.superClass.getInternalClass().prototype);
                }

                _.each(definition.methods, function (data, methodName) {
                    // PHP5-style __construct magic method takes precedence
                    if (methodName === '__construct') {
                        if (constructorName) {
                            // TODO: Change for PHP 7 (see https://www.php.net/manual/en/migration70.incompatible.php)
                            namespace.callStack.raiseError(PHPError.E_STRICT, 'Redefining already defined constructor for class ' + name);
                        }

                        constructorName = methodName;
                    }

                    if (!constructorName && methodName === name) {
                        constructorName = methodName;
                    }

                    methods[methodName] = data;
                });

                staticProperties = definition.staticProperties;
                constants = definition.constants;

                // Record the prototype object that we should stop at when walking up the chain
                rootInternalPrototype = InternalClass.prototype;
            }

            classObject = new Class(
                namespace.valueFactory,
                namespace.functionFactory,
                namespace.callStack,
                namespace.getPrefix() + name,
                constructorName,
                InternalClass,
                rootInternalPrototype,
                staticProperties,
                constants,
                definition.superClass,
                definition.interfaces,
                namespaceScope,
                namespace.exportRepository,
                namespace.ffiFactory.createValueCoercer(autoCoercionEnabled),
                namespace.ffiFactory
            );

            _.forOwn(methods, function (data, methodName) {
                // TODO: For JS-defined functions, `methods` is always empty - see above.
                //       Consider building it up with processed methods/specs etc., indexed by lowercased name,
                //       to also solve the performance issue with the current method lookup logic.
                var functionSpec,
                    lineNumber = data.line,
                    method,
                    methodIsStatic = data[IS_STATIC],
                    // Parameter spec data may only be provided for PHP-transpiled functions
                    parametersSpecData = data.args;

                functionSpec = namespace.functionSpecFactory.createMethodSpec(
                    namespaceScope,
                    classObject,
                    methodName,
                    parametersSpecData || [],
                    namespace.callStack.getLastFilePath(),
                    lineNumber || null
                );

                method = namespace.functionFactory.create(
                    namespaceScope,
                    classObject,
                    data.method,
                    methodName,
                    null,
                    null, // NB: No need to override the class for a method
                    functionSpec
                );

                method[IS_METHOD] = true;
                method[IS_STATIC] = methodIsStatic;
                method.data = methodData;

                InternalClass.prototype[methodName] = method;
            });

            methodData.classObject = classObject;

            namespace.classes[name.toLowerCase()] = classObject;

            return classObject;
        },

        /**
         * Defines a constant for the current namespace, optionally making it case-insensitive
         *
         * @param {string} name
         * @param {Value} value
         * @param {object=} options
         */
        defineConstant: function (name, value, options) {
            var caseInsensitive,
                effectiveName,
                existingDefinition,
                namespace = this;

            options = options || {};
            caseInsensitive = !!options.caseInsensitive;
            existingDefinition = namespace.getConstantDefinition(name);

            if (existingDefinition !== null) {
                namespace.callStack.raiseTranslatedError(PHPError.E_NOTICE, CONSTANT_ALREADY_DEFINED, {
                    // Use original name in the error message rather than the effective one
                    name: namespace.getPrefix().toLowerCase() + existingDefinition.name
                });

                return; // Do not redefine the existing constant
            }

            effectiveName = caseInsensitive ? name.toLowerCase() : name;

            namespace.constants[effectiveName] = {
                caseInsensitive: caseInsensitive,
                // Store the original name for reference (as the effective one may be lower-cased)
                name: name,
                value: value
            };
        },

        /**
         * Defines a new function within this namespace
         *
         * @param {string} name
         * @param {Function} func
         * @param {NamespaceScope} namespaceScope
         * @param {Array=} parametersSpecData
         * @param {number=} lineNumber
         */
        defineFunction: function (name, func, namespaceScope, parametersSpecData, lineNumber) {
            var functionSpec,
                namespace = this;

            // Parameter spec data may only be provided for PHP-transpiled functions
            functionSpec = namespace.functionSpecFactory.createFunctionSpec(
                namespaceScope,
                name,
                parametersSpecData || [],
                namespace.callStack.getLastFilePath(),
                lineNumber || null
            );

            namespace.functions[name.toLowerCase()] = namespace.functionFactory.create(
                namespaceScope,
                // Class will always be null for 'normal' functions
                // as defining a function inside a class will define it
                // inside the current namespace instead.
                null,
                func,
                name,
                null,
                null,
                functionSpec
            );
        },

        /**
         * Fetches a class definition from within this namespace or a descendant.
         * If applicable, the class autoloader will be invoked.
         *
         * @param {string} name
         * @returns {Class}
         */
        getClass: function (name) {
            var namespace = this,
                parsed = namespace.parseName(name),
                lowerName = parsed.name.toLowerCase();

            if (!hasOwn.call(parsed.namespace.classes, lowerName)) {
                // Try to autoload the class
                namespace.classAutoloader.autoloadClass(parsed.namespace.getPrefix() + parsed.name);

                // Raise an error if it is still not defined
                if (!hasOwn.call(parsed.namespace.classes, lowerName)) {
                    namespace.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NOT_FOUND, {
                        name: parsed.namespace.getPrefix() + parsed.name
                    });
                }
            }

            return parsed.namespace.classes[lowerName];
        },

        /**
         * Fetches the value of a constant if it is defined. If it is not defined,
         * then it will either raise a notice and return the name of the constant as a string,
         * or throw an exception, depending on whether it is a namespaced constant
         *
         * @param {string} name
         * @param {boolean} usesNamespace
         * @returns {Value}
         */
        getConstant: function (name, usesNamespace) {
            var namespace = this,
                constant = namespace.getConstantDefinition(name);

            if (constant) {
                return constant.value;
            }

            if (usesNamespace) {
                namespace.callStack.raiseTranslatedError(PHPError.E_ERROR, UNDEFINED_CONSTANT, {
                    name: namespace.getPrefix() + name
                });
            }

            namespace.callStack.raiseError(
                PHPError.E_WARNING,
                'Use of undefined constant ' + name + ' - assumed \'' + name + '\' ' +
                '(this will throw an Error in a future version of PHP)'
            );

            return this.valueFactory.createString(name);
        },

        /**
         * Fetches a sub-namespace within this one, by its name. Any namespaces in the hierarchy
         * that do not exist will be created and then cached on-demand
         *
         * @param {string} name
         * @returns {Namespace}
         */
        getDescendant: function (name) {
            var namespace = this,
                subNamespace = namespace;

            if (name === '') {
                throw new Error('Namespace.getDescendant() :: Name cannot be empty');
            }

            _.each(name.split('\\'), function (part) {
                if (!hasOwn.call(subNamespace.children, part.toLowerCase())) {
                    subNamespace.children[part.toLowerCase()] = namespace.namespaceFactory.create(
                        subNamespace,
                        part
                    );
                }

                subNamespace = subNamespace.children[part.toLowerCase()];
            });

            return subNamespace;
        },

        /**
         * Fetches a function from the current namespace if defined, otherwise falls back
         * to the global namespace. Raises an error if the function is not defined at all
         *
         * @param {string|Function} name
         * @returns {Function}
         */
        getFunction: function (name) {
            var globalNamespace,
                match,
                namespace = this,
                path,
                subNamespace;

            if (_.isFunction(name)) {
                return name;
            }

            match = name.match(/^(.*?)\\([^\\]+)$/);

            if (match) {
                path = match[1];
                name = match[2];

                subNamespace = namespace.getDescendant(path);

                return subNamespace.getFunction(name);
            }

            if (hasOwn.call(namespace.functions, name.toLowerCase())) {
                return namespace.functions[name.toLowerCase()];
            }

            globalNamespace = namespace.getGlobal();

            if (hasOwn.call(globalNamespace.functions, name.toLowerCase())) {
                return globalNamespace.functions[name.toLowerCase()];
            }

            namespace.callStack.raiseTranslatedError(PHPError.E_ERROR, CALL_TO_UNDEFINED_FUNCTION, {
                name: namespace.getPrefix() + name
            });
        },

        getGlobal: function () {
            var namespace = this;

            return namespace.name === '' ? namespace : namespace.getParent().getGlobal();
        },

        getGlobalNamespace: function () {
            return this.getGlobal();
        },

        getName: function () {
            var namespace = this;

            if (namespace.name === '') {
                return '';
            }

            return (namespace.parent ? namespace.parent.getPrefix() : '') + namespace.name;
        },

        getOwnFunction: function (name) {
            var namespace = this;

            if (hasOwn.call(namespace.functions, name.toLowerCase())) {
                return namespace.functions[name.toLowerCase()];
            }

            return null;
        },

        getParent: function () {
            return this.parent;
        },

        getPrefix: function () {
            var name = this.getName();

            if (name !== '') {
                name += '\\';
            }

            return name;
        },

        /**
         * Fetches the definition object for a constant, or null if it is not defined
         *
         * @param {string} name
         * @returns {object|null}
         */
        getConstantDefinition: function (name) {
            var globalNamespace,
                lowercaseName,
                namespace = this;

            if (hasOwn.call(namespace.constants, name)) {
                return namespace.constants[name];
            }

            lowercaseName = name.toLowerCase();

            if (
                hasOwn.call(namespace.constants, lowercaseName) &&
                namespace.constants[lowercaseName].caseInsensitive
            ) {
                return namespace.constants[lowercaseName];
            }

            globalNamespace = namespace.getGlobal();

            if (hasOwn.call(globalNamespace.constants, name)) {
                return globalNamespace.constants[name];
            }

            if (
                hasOwn.call(globalNamespace.constants, lowercaseName) &&
                globalNamespace.constants[lowercaseName].caseInsensitive
            ) {
                return globalNamespace.constants[lowercaseName];
            }

            return null;
        },

        /**
         * Determines whether or not the given class exists in this namespace (or a descendant of it)
         * without invoking the autoloader if it does not
         *
         * @param {string} name
         * @returns {boolean}
         */
        hasClass: function (name) {
            var namespace = this,
                parsed = namespace.parseName(name),
                lowerName = parsed.name.toLowerCase();

            return hasOwn.call(parsed.namespace.classes, lowerName);
        },

        /**
         * Returns true if this namespace defines the specified constant, and false otherwise.
         * If the constant is case-insensitive, then it will be returned for any case
         *
         * @param {string} name
         * @returns {boolean}
         */
        hasConstant: function (name) {
            return this.getConstantDefinition(name) !== null;
        },

        /**
         * Returns true if this namespace defines the specified function, and false otherwise.
         * Note that function names are case-insensitive
         *
         * @param {string} name
         * @returns {boolean}
         */
        hasFunction: function (name) {
            var namespace = this,
                parsed = namespace.parseName(name),
                lowerName = parsed.name.toLowerCase();

            return hasOwn.call(parsed.namespace.functions, lowerName);
        },

        /**
         * Parses a class, function or constant name to its namespace and name
         *
         * @param {string} name
         * @returns {{namespace: (Namespace), name: string}}
         */
        parseName: function (name) {
            var match = name.match(/^(\\?)(.*?)\\?([^\\]+)$/),
                namespace = this,
                path,
                relativeToGlobalNamespace,
                subNamespace;

            if (match) {
                // Name was fully-qualified: return the resolved namespace it was inside

                relativeToGlobalNamespace = (match[1] === '\\');

                path = match[2];
                name = match[3];

                subNamespace = relativeToGlobalNamespace ? namespace.getGlobalNamespace() : namespace;

                if (path !== '') {
                    subNamespace = subNamespace.getDescendant(path);
                }

                return {
                    namespace: subNamespace,
                    name: name
                };
            }

            return {
                namespace: namespace,
                name: name
            };
        },

        resolveClass: function (name) {
            return name;
        }
    });

    return Namespace;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/NamespaceFactory.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcore/src/NamespaceFactory.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates objects related to Namespaces
 *
 * @param {class} Namespace
 * @param {CallStack} callStack
 * @param {FunctionFactory} functionFactory
 * @param {FunctionSpecFactory} functionSpecFactory
 * @param {ValueFactory} valueFactory
 * @param {ClassAutoloader} classAutoloader
 * @param {ExportRepository} exportRepository
 * @param {FFIFactory} ffiFactory
 * @constructor
 */
function NamespaceFactory(
    Namespace,
    callStack,
    functionFactory,
    functionSpecFactory,
    valueFactory,
    classAutoloader,
    exportRepository,
    ffiFactory
) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {ClassAutoloader}
     */
    this.classAutoloader = classAutoloader;
    /**
     * @type {ExportRepository}
     */
    this.exportRepository = exportRepository;
    /**
     * @type {FFIFactory}
     */
    this.ffiFactory = ffiFactory;
    /**
     * @type {FunctionFactory}
     */
    this.functionFactory = functionFactory;
    /**
     * @type {FunctionSpecFactory}
     */
    this.functionSpecFactory = functionSpecFactory;
    /**
     * @type {class}
     */
    this.Namespace = Namespace;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

_.extend(NamespaceFactory.prototype, {
    create: function (parentNamespace, name) {
        var factory = this;

        return new factory.Namespace(
            factory.callStack,
            factory.valueFactory,
            factory,
            factory.functionFactory,
            factory.functionSpecFactory,
            factory.classAutoloader,
            factory.exportRepository,
            factory.ffiFactory,
            parentNamespace || null,
            name || ''
        );
    }
});

module.exports = NamespaceFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/NamespaceScope.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/NamespaceScope.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    var hasOwn = {}.hasOwnProperty,
        NAMESPACE = 'namespace',

        CANNOT_USE_AS_NAME_ALREADY_IN_USE = 'core.cannot_use_as_name_already_in_use';

    /**
     * Represents a block within a PHP module that is inside a namespace statement,
     * containing classes imported with `use` statements etc.
     *
     * @param {Namespace} globalNamespace
     * @param {ValueFactory} valueFactory
     * @param {CallStack} callStack
     * @param {Module} module
     * @param {Namespace} namespace
     * @param {boolean} global Whether this namespace scope is the special "invisible" global one
     * @constructor
     */
    function NamespaceScope(globalNamespace, valueFactory, callStack, module, namespace, global) {
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {Namespace}
         */
        this.globalNamespace = globalNamespace;
        /**
         * Imports from `use` statements
         *
         * @type {object}
         */
        this.imports = {};
        /**
         * @type {boolean}
         */
        this.global = global;
        /**
         * @type {Module}
         */
        this.module = module;
        /**
         * @type {Namespace}
         */
        this.namespace = namespace;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(NamespaceScope.prototype, {
        getClass: function (name) {
            var resolvedClass = this.resolveClass(name);

            return resolvedClass.namespace.getClass(resolvedClass.name);
        },

        getConstant: function (name) {
            var match,
                scope = this,
                namespace = scope.namespace,
                path,
                prefix,
                usesNamespace = false;

            // Check whether the constant path is absolute, so no 'use's apply
            if (name.charAt(0) === '\\') {
                usesNamespace = true;
                match = name.match(/^\\(.*?)\\([^\\]+)$/);

                if (match) {
                    path = match[1];
                    name = match[2];
                    namespace = scope.globalNamespace.getDescendant(path);
                } else {
                    name = name.substr(1);
                }
                // Check whether the namespace prefix is an alias
            } else {
                match = name.match(/^([^\\]+)(.*?)\\([^\\]+)$/);

                if (match) {
                    usesNamespace = true;
                    prefix = match[1];
                    path = match[2];
                    name = match[3];

                    if (hasOwn.call(scope.imports, prefix.toLowerCase())) {
                        namespace = scope.globalNamespace.getDescendant(scope.imports[prefix.toLowerCase()].substr(1) + path);
                    } else {
                        // Not an alias: look up the namespace path relative to this namespace
                        // (ie. 'namespace Test { echo Our\CONSTANT; }' -> 'echo \Test\Our\CONSTANT;')
                        namespace = scope.globalNamespace.getDescendant(namespace.getPrefix() + prefix + path);
                    }
                }
            }

            return namespace.getConstant(name, usesNamespace);
        },

        /**
         * Fetches the path to the file this scope's parent module originates from
         *
         * @returns {string|null}
         */
        getFilePath: function () {
            return this.module.getFilePath();
        },

        getFunction: function (name) {
            var match,
                scope = this,
                namespace = scope.namespace,
                path,
                prefix;

            // Check whether the function path is absolute, so no 'use's apply
            if (name.charAt(0) === '\\') {
                match = name.match(/^\\(.*?)\\([^\\]+)$/);

                if (match) {
                    path = match[1];
                    name = match[2];
                    namespace = scope.globalNamespace.getDescendant(path);
                } else {
                    name = name.substr(1);
                    namespace = scope.globalNamespace;
                }
                // Check whether the namespace prefix is an alias
            } else {
                match = name.match(/^([^\\]+)(.*?)\\([^\\]+)$/);

                if (match) {
                    prefix = match[1];
                    path = match[2];
                    name = match[3];

                    if (hasOwn.call(scope.imports, prefix.toLowerCase())) {
                        namespace = scope.globalNamespace.getDescendant(scope.imports[prefix.toLowerCase()].substr(1) + path);
                    } else {
                        // Not an alias: look up the namespace path relative to this namespace
                        // (ie. 'namespace Test { Our\Func(); }' -> '\Test\Our\Func();')
                        namespace = scope.globalNamespace.getDescendant(namespace.getPrefix() + prefix + path);
                    }
                }
            }

            return namespace.getFunction(name);
        },

        getGlobalNamespace: function () {
            return this.globalNamespace;
        },

        getNamespaceName: function () {
            var scope = this;

            return scope.valueFactory.createString(scope.namespace.getName());
        },

        /**
         * Fetches the backslash-delimited prefix string for this scope's namespace
         *
         * @returns {string}
         */
        getNamespacePrefix: function () {
            return this.namespace.getPrefix();
        },

        /**
         * Determines whether the specified class is defined for this namespace scope,
         * taking any imports/aliases via `use` into account
         *
         * @param {string} name
         * @returns {boolean}
         */
        hasClass: function (name) {
            var scope = this,
                resolvedClass = scope.resolveClass(name);

            // Check whether the entire class name is aliased
            if (hasOwn.call(scope.imports, name.toLowerCase())) {
                return true;
            }

            return resolvedClass.namespace.hasClass(resolvedClass.name);
        },

        /**
         * Determines whether this namespace scope is the special "invisible" global one
         *
         * @returns {boolean}
         */
        isGlobal: function () {
            return this.global;
        },

        /**
         * Resolves a potentially relatively- or fully-qualified class path
         * to the Namespace instance it should be defined by and its name
         *
         * @param {string} name
         * @returns {{namespace: Namespace, name: string}}
         */
        resolveClass: function (name) {
            var loweredPrefix,
                match,
                scope = this,
                namespace = scope.namespace,
                path,
                prefix;

            // Check whether the entire class name is aliased
            if (hasOwn.call(scope.imports, name.toLowerCase())) {
                name = scope.imports[name.toLowerCase()];
                namespace = scope.globalNamespace;
            }

            // Check whether the class path is absolute, so no 'use's apply
            if (name.charAt(0) === '\\') {
                match = name.match(/^\\(.*?)\\([^\\]+)$/);

                if (match) {
                    path = match[1];
                    name = match[2];
                    namespace = scope.globalNamespace.getDescendant(path);
                } else {
                    // A class in the global namespace with explicit absolute path, eg. `\MyClass`
                    name = name.substr(1);
                    namespace = scope.globalNamespace;
                }
            // Check whether the namespace prefix is an alias
            } else {
                match = name.match(/^([^\\]+)(.*?)\\([^\\]+)$/);

                if (match) {
                    prefix = match[1];
                    path = match[2];
                    name = match[3];
                    loweredPrefix = prefix.toLowerCase();

                    if (loweredPrefix === NAMESPACE) {
                        // Reference uses the special "namespace" keyword as a prefix:
                        // resolve relative to the current namespace
                        namespace = namespace.getDescendant(path.replace(/^\\/, ''));
                    } else if (hasOwn.call(scope.imports, loweredPrefix)) {
                        namespace = scope.globalNamespace.getDescendant(scope.imports[loweredPrefix].substr(1) + path);
                    } else {
                        // Not an alias: look up the namespace path relative to this namespace
                        // (ie. 'namespace Test { Our\Func(); }' -> '\Test\Our\Func();')
                        namespace = namespace.getDescendant(prefix + path);
                    }
                }
            }

            return {namespace: namespace, name: name};
        },

        /**
         * Imports a class into the current namespace scope, eg. from a PHP `use ...` statement
         *
         * @param {string} source
         * @param {string} alias
         */
        use: function (source, alias) {
            var scope = this,
                normalizedSource = source;

            if (!alias) {
                alias = source.replace(/^.*?([^\\]+)$/, '$1');
            }

            if (normalizedSource.charAt(0) !== '\\') {
                normalizedSource = '\\' + normalizedSource;
            }

            if (scope.hasClass(alias.toLowerCase())) {
                scope.callStack.raiseUncatchableFatalError(CANNOT_USE_AS_NAME_ALREADY_IN_USE, {
                    alias: alias,
                    source: source
                });
            }

            scope.imports[alias.toLowerCase()] = normalizedSource;
        }
    });

    return NamespaceScope;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/OptionSet.js":
/*!***********************************************!*\
  !*** ./node_modules/phpcore/src/OptionSet.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    hasOwn = {}.hasOwnProperty;

/**
 * Represents a set of options for a running PHP application
 *
 * @param {object} options
 * @constructor
 */
function OptionSet(options) {
    /**
     * @type {Object}
     */
    this.options = options;
}

_.extend(OptionSet.prototype, {
    /**
     * Fetches the value of a single option by its name
     *
     * @param {string} name
     * @returns {*}
     */
    getOption: function (name) {
        var optionSet = this;

        return hasOwn.call(optionSet.options, name) ? optionSet.options[name] : null;
    },

    /**
     * Fetches all defined options
     *
     * @returns {Object}
     */
    getOptions: function () {
        return this.options;
    }
});

module.exports = OptionSet;


/***/ }),

/***/ "./node_modules/phpcore/src/Output/Output.js":
/*!***************************************************!*\
  !*** ./node_modules/phpcore/src/Output/Output.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    NoActiveOutputBufferException = __webpack_require__(/*! ../Exception/NoActiveOutputBufferException */ "./node_modules/phpcore/src/Exception/NoActiveOutputBufferException.js");

/**
 * @param {OutputFactory} factory
 * @param {StdoutBuffer} stdoutBuffer
 * @constructor
 */
function Output(factory, stdoutBuffer) {
    /**
     * @type {OutputBufferInterface}
     */
    this.currentOutputBuffer = stdoutBuffer;
    /**
     * @type {OutputFactory}
     */
    this.factory = factory;
    /**
     * @type {OutputBufferInterface[]}
     */
    this.outputBufferStack = [];
}

_.extend(Output.prototype, {
    /**
     * Discards the contents of the current buffer without flushing it through
     *
     * @returns {bool} Returns true on success, false otherwise
     */
    cleanCurrentBuffer: function () {
        return this.currentOutputBuffer.clean();
    },

    /**
     * Writes the contents of the current buffer through to the next buffer
     * and then discards them from this buffer
     *
     * @returns {bool} Returns true on success, false otherwise
     */
    flushCurrentBuffer: function () {
        return this.currentOutputBuffer.flush();
    },

    /**
     * Fetches the current contents of the current buffer if it is actually a buffering one
     *
     * @returns {string|null}
     */
    getCurrentBufferContents: function () {
        return this.currentOutputBuffer.getContents();
    },

    /**
     * Fetches the number of nested buffers that are currently active
     *
     * @returns {number}
     */
    getDepth: function () {
        return this.currentOutputBuffer.getDepth();
    },

    /**
     * Pops the current buffer off of the stack, returning to using the previous one
     */
    popBuffer: function () {
        var output = this;

        if (output.outputBufferStack.length === 0) {
            throw new NoActiveOutputBufferException();
        }

        output.currentOutputBuffer = output.outputBufferStack.pop();
    },

    /**
     * Pushes a new output buffer onto the stack
     *
     * @returns {OutputBuffer}
     */
    pushBuffer: function () {
        var output = this,
            newOutputBuffer = output.factory.createOutputBuffer(output.currentOutputBuffer);

        output.outputBufferStack.push(output.currentOutputBuffer);
        output.currentOutputBuffer = newOutputBuffer;

        return newOutputBuffer;
    },

    /**
     * Writes data to the current output buffer
     *
     * @param {string} data
     */
    write: function (data) {
        this.currentOutputBuffer.write(data);
    }
});

module.exports = Output;


/***/ }),

/***/ "./node_modules/phpcore/src/Output/OutputBuffer.js":
/*!*********************************************************!*\
  !*** ./node_modules/phpcore/src/Output/OutputBuffer.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    OutputBufferInterface = __webpack_require__(/*! ./OutputBufferInterface */ "./node_modules/phpcore/src/Output/OutputBufferInterface.js");

/**
 * @param {OutputBufferInterface} previousBuffer
 * @constructor
 */
function OutputBuffer(previousBuffer) {
    /**
     * @type {string}
     */
    this.bufferedData = '';
    /**
     * @type {OutputBufferInterface}
     */
    this.previousBuffer = previousBuffer;
}

util.inherits(OutputBuffer, OutputBufferInterface);

_.extend(OutputBuffer.prototype, {
    /**
     * {@inheritdoc}
     */
    clean: function () {
        this.bufferedData = '';

        return true; // Success
    },

    /**
     * {@inheritdoc}
     */
    flush: function () {
        var buffer = this;

        buffer.previousBuffer.write(buffer.bufferedData);
        buffer.bufferedData = '';

        return true; // Success
    },

    /**
     * {@inheritdoc}
     */
    getContents: function () {
        return this.bufferedData;
    },

    /**
     * {@inheritdoc}
     */
    getDepth: function () {
        return this.previousBuffer.getDepth() + 1;
    },

    /**
     * {@inheritdoc}
     */
    write: function (data) {
        this.bufferedData += data;
    }
});

module.exports = OutputBuffer;


/***/ }),

/***/ "./node_modules/phpcore/src/Output/OutputBufferInterface.js":
/*!******************************************************************!*\
  !*** ./node_modules/phpcore/src/Output/OutputBufferInterface.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    throwUnimplemented = function (functionName) {
        return function () {
            throw new Error(functionName + '() :: Not implemented');
        };
    };

/**
 * @interface
 */
function OutputBufferInterface() {
    throw new Error('OutputBufferInterface cannot be instantiated');
}

_.extend(OutputBufferInterface.prototype, {
    /**
     * Discards the contents of this buffer without flushing it through
     *
     * @returns {bool} Returns true on success, false otherwise
     */
    clean: throwUnimplemented('clean'),

    /**
     * Writes the contents of this buffer through to the next buffer and then discards them from this buffer
     *
     * @returns {bool} Returns true on success, false otherwise
     */
    flush: throwUnimplemented('flush'),

    /**
     * Fetches the current contents of this buffer if it is actually a buffering one
     *
     * @returns {string|null}
     */
    getContents: throwUnimplemented('getContents'),

    /**
     * Fetches the depth of this buffer
     *
     * @returns {number}
     */
    getDepth: throwUnimplemented('getDepth'),

    /**
     * Writes data to this buffer, storing it for future use
     *
     * @param {string} data
     */
    write: throwUnimplemented('write')
});

module.exports = OutputBufferInterface;


/***/ }),

/***/ "./node_modules/phpcore/src/Output/OutputFactory.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/Output/OutputFactory.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {class} OutputBuffer
 * @constructor
 */
function OutputFactory(OutputBuffer) {
    /**
     * @type {class}
     */
    this.OutputBuffer = OutputBuffer;
}

_.extend(OutputFactory.prototype, {
    /**
     * Creates a new OutputBuffer
     *
     * @param {OutputBufferInterface} previousBuffer
     * @returns {OutputBuffer}
     */
    createOutputBuffer: function (previousBuffer) {
        return new this.OutputBuffer(previousBuffer);
    }
});

module.exports = OutputFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Output/StdoutBuffer.js":
/*!*********************************************************!*\
  !*** ./node_modules/phpcore/src/Output/StdoutBuffer.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    OutputBufferInterface = __webpack_require__(/*! ./OutputBufferInterface */ "./node_modules/phpcore/src/Output/OutputBufferInterface.js");

/**
 * @param {Stream} stdout
 * @constructor
 */
function StdoutBuffer(stdout) {
    /**
     * @type {Stream}
     */
    this.stdout = stdout;
}

util.inherits(StdoutBuffer, OutputBufferInterface);

_.extend(StdoutBuffer.prototype, {
    /**
     * {@inheritdoc}
     */
    clean: function () {
        return false; // This buffer does not actually buffer
    },

    /**
     * {@inheritdoc}
     */
    flush: function () {
        return false; // This buffer does not actually buffer
    },

    /**
     * {@inheritdoc}
     */
    getContents: function () {
        return null; // This buffer does not actually buffer
    },

    /**
     * {@inheritdoc}
     */
    getDepth: function () {
        return 0; // This buffer does not actually buffer
    },

    /**
     * {@inheritdoc}
     */
    write: function (data) {
        this.stdout.write(data);
    }
});

module.exports = StdoutBuffer;


/***/ }),

/***/ "./node_modules/phpcore/src/PHPState.js":
/*!**********************************************!*\
  !*** ./node_modules/phpcore/src/PHPState.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! ./builtin/builtins */ "./node_modules/phpcore/src/builtin/builtins.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ./Reference/AccessorReference */ "./node_modules/phpcore/src/Reference/AccessorReference.js"),
    __webpack_require__(/*! ./Call */ "./node_modules/phpcore/src/Call.js"),
    __webpack_require__(/*! ./CallFactory */ "./node_modules/phpcore/src/CallFactory.js"),
    __webpack_require__(/*! ./CallStack */ "./node_modules/phpcore/src/CallStack.js"),
    __webpack_require__(/*! ./ClassAutoloader */ "./node_modules/phpcore/src/ClassAutoloader.js"),
    __webpack_require__(/*! ./Closure */ "./node_modules/phpcore/src/Closure.js"),
    __webpack_require__(/*! ./Function/ClosureContext */ "./node_modules/phpcore/src/Function/ClosureContext.js"),
    __webpack_require__(/*! ./ClosureFactory */ "./node_modules/phpcore/src/ClosureFactory.js"),
    __webpack_require__(/*! ./Reference/Element/ElementProviderFactory */ "./node_modules/phpcore/src/Reference/Element/ElementProviderFactory.js"),
    __webpack_require__(/*! ./Error/ErrorConfiguration */ "./node_modules/phpcore/src/Error/ErrorConfiguration.js"),
    __webpack_require__(/*! ./Error/ErrorConverter */ "./node_modules/phpcore/src/Error/ErrorConverter.js"),
    __webpack_require__(/*! ./Error/ErrorPromoter */ "./node_modules/phpcore/src/Error/ErrorPromoter.js"),
    __webpack_require__(/*! ./Error/ErrorReporting */ "./node_modules/phpcore/src/Error/ErrorReporting.js"),
    __webpack_require__(/*! ./FFI/Value/AsyncObjectValue */ "./node_modules/phpcore/src/FFI/Value/AsyncObjectValue.js"),
    __webpack_require__(/*! ./FFI/Call */ "./node_modules/phpcore/src/FFI/Call.js"),
    __webpack_require__(/*! ./FFI/Call/Caller */ "./node_modules/phpcore/src/FFI/Call/Caller.js"),
    __webpack_require__(/*! ./FFI/Internals/ClassInternalsClassFactory */ "./node_modules/phpcore/src/FFI/Internals/ClassInternalsClassFactory.js"),
    __webpack_require__(/*! ./FFI/Export/ExportFactory */ "./node_modules/phpcore/src/FFI/Export/ExportFactory.js"),
    __webpack_require__(/*! ./FFI/Export/ExportRepository */ "./node_modules/phpcore/src/FFI/Export/ExportRepository.js"),
    __webpack_require__(/*! ./FFI/FFIFactory */ "./node_modules/phpcore/src/FFI/FFIFactory.js"),
    __webpack_require__(/*! ./FFI/Internals/FunctionInternalsClassFactory */ "./node_modules/phpcore/src/FFI/Internals/FunctionInternalsClassFactory.js"),
    __webpack_require__(/*! ./FFI/Internals/Internals */ "./node_modules/phpcore/src/FFI/Internals/Internals.js"),
    __webpack_require__(/*! ./FFI/Call/NativeCaller */ "./node_modules/phpcore/src/FFI/Call/NativeCaller.js"),
    __webpack_require__(/*! ./FFI/Value/PHPObject */ "./node_modules/phpcore/src/FFI/Value/PHPObject.js"),
    __webpack_require__(/*! ./FFI/Value/Proxy/ProxyClassFactory */ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyClassFactory.js"),
    __webpack_require__(/*! ./FFI/Value/Proxy/ProxyClassRepository */ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyClassRepository.js"),
    __webpack_require__(/*! ./FFI/Value/Proxy/ProxyFactory */ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyFactory.js"),
    __webpack_require__(/*! ./FFI/Value/Proxy/ProxyMemberFactory */ "./node_modules/phpcore/src/FFI/Value/Proxy/ProxyMemberFactory.js"),
    __webpack_require__(/*! ./FFI/Result */ "./node_modules/phpcore/src/FFI/Result.js"),
    __webpack_require__(/*! ./FFI/Stack/StackHooker */ "./node_modules/phpcore/src/FFI/Stack/StackHooker.js"),
    __webpack_require__(/*! ./FFI/Export/UnwrapperRepository */ "./node_modules/phpcore/src/FFI/Export/UnwrapperRepository.js"),
    __webpack_require__(/*! ./FFI/Call/ValueCaller */ "./node_modules/phpcore/src/FFI/Call/ValueCaller.js"),
    __webpack_require__(/*! ./FFI/Value/ValueCoercer */ "./node_modules/phpcore/src/FFI/Value/ValueCoercer.js"),
    __webpack_require__(/*! ./FFI/Value/ValueHelper */ "./node_modules/phpcore/src/FFI/Value/ValueHelper.js"),
    __webpack_require__(/*! ./FFI/Value/ValueStorage */ "./node_modules/phpcore/src/FFI/Value/ValueStorage.js"),
    __webpack_require__(/*! ./Function/FunctionContext */ "./node_modules/phpcore/src/Function/FunctionContext.js"),
    __webpack_require__(/*! ./FunctionFactory */ "./node_modules/phpcore/src/FunctionFactory.js"),
    __webpack_require__(/*! ./Function/FunctionSpec */ "./node_modules/phpcore/src/Function/FunctionSpec.js"),
    __webpack_require__(/*! ./Function/FunctionSpecFactory */ "./node_modules/phpcore/src/Function/FunctionSpecFactory.js"),
    __webpack_require__(/*! ./INIState */ "./node_modules/phpcore/src/INIState.js"),
    __webpack_require__(/*! ./Loader */ "./node_modules/phpcore/src/Loader.js"),
    __webpack_require__(/*! ./LoadScope */ "./node_modules/phpcore/src/LoadScope.js"),
    __webpack_require__(/*! ./Function/MethodContext */ "./node_modules/phpcore/src/Function/MethodContext.js"),
    __webpack_require__(/*! ./MethodSpec */ "./node_modules/phpcore/src/MethodSpec.js"),
    __webpack_require__(/*! ./Module */ "./node_modules/phpcore/src/Module.js"),
    __webpack_require__(/*! ./ModuleFactory */ "./node_modules/phpcore/src/ModuleFactory.js"),
    __webpack_require__(/*! ./Namespace */ "./node_modules/phpcore/src/Namespace.js"),
    __webpack_require__(/*! ./NamespaceFactory */ "./node_modules/phpcore/src/NamespaceFactory.js"),
    __webpack_require__(/*! ./NamespaceScope */ "./node_modules/phpcore/src/NamespaceScope.js"),
    __webpack_require__(/*! ./Reference/Null */ "./node_modules/phpcore/src/Reference/Null.js"),
    __webpack_require__(/*! ./OptionSet */ "./node_modules/phpcore/src/OptionSet.js"),
    __webpack_require__(/*! ./Output/Output */ "./node_modules/phpcore/src/Output/Output.js"),
    __webpack_require__(/*! ./Output/OutputBuffer */ "./node_modules/phpcore/src/Output/OutputBuffer.js"),
    __webpack_require__(/*! ./Output/OutputFactory */ "./node_modules/phpcore/src/Output/OutputFactory.js"),
    __webpack_require__(/*! ./Function/Parameter */ "./node_modules/phpcore/src/Function/Parameter.js"),
    __webpack_require__(/*! ./Function/ParameterFactory */ "./node_modules/phpcore/src/Function/ParameterFactory.js"),
    __webpack_require__(/*! ./Function/ParameterListFactory */ "./node_modules/phpcore/src/Function/ParameterListFactory.js"),
    __webpack_require__(/*! ./Function/ParameterTypeFactory */ "./node_modules/phpcore/src/Function/ParameterTypeFactory.js"),
    __webpack_require__(/*! ./ReferenceFactory */ "./node_modules/phpcore/src/ReferenceFactory.js"),
    __webpack_require__(/*! ./Scope */ "./node_modules/phpcore/src/Scope.js"),
    __webpack_require__(/*! ./ScopeFactory */ "./node_modules/phpcore/src/ScopeFactory.js"),
    __webpack_require__(/*! ./Output/StdoutBuffer */ "./node_modules/phpcore/src/Output/StdoutBuffer.js"),
    __webpack_require__(/*! ./SuperGlobalScope */ "./node_modules/phpcore/src/SuperGlobalScope.js"),
    __webpack_require__(/*! ./Error/TraceFormatter */ "./node_modules/phpcore/src/Error/TraceFormatter.js"),
    __webpack_require__(/*! ./Type/TypeFactory */ "./node_modules/phpcore/src/Type/TypeFactory.js"),
    __webpack_require__(/*! ./Value */ "./node_modules/phpcore/src/Value.js"),
    __webpack_require__(/*! ./ValueFactory */ "./node_modules/phpcore/src/ValueFactory.js"),
    __webpack_require__(/*! ./Variable */ "./node_modules/phpcore/src/Variable.js"),
    __webpack_require__(/*! ./VariableFactory */ "./node_modules/phpcore/src/VariableFactory.js")
], function (
    _,
    builtinTypes,
    phpCommon,
    util,
    AccessorReference,
    Call,
    CallFactory,
    CallStack,
    ClassAutoloader,
    Closure,
    ClosureContext,
    ClosureFactory,
    ElementProviderFactory,
    ErrorConfiguration,
    ErrorConverter,
    ErrorPromoter,
    ErrorReporting,
    FFIAsyncObjectValue,
    FFICall,
    FFICaller,
    FFIClassInternalsClassFactory,
    FFIExportFactory,
    FFIExportRepository,
    FFIFactory,
    FFIFunctionInternalsClassFactory,
    FFIInternals,
    FFINativeCaller,
    FFIPHPObject,
    FFIProxyClassFactory,
    FFIProxyClassRepository,
    FFIProxyFactory,
    FFIProxyMemberFactory,
    FFIResult,
    FFIStackHooker,
    FFIUnwrapperRepository,
    FFIValueCaller,
    FFIValueCoercer,
    FFIValueHelper,
    FFIValueStorage,
    FunctionContext,
    FunctionFactory,
    FunctionSpec,
    FunctionSpecFactory,
    INIState,
    Loader,
    LoadScope,
    MethodContext,
    MethodSpec,
    Module,
    ModuleFactory,
    Namespace,
    NamespaceFactory,
    NamespaceScope,
    NullReference,
    OptionSet,
    Output,
    OutputBuffer,
    OutputFactory,
    Parameter,
    ParameterFactory,
    ParameterListFactory,
    ParameterTypeFactory,
    ReferenceFactory,
    Scope,
    ScopeFactory,
    StdoutBuffer,
    SuperGlobalScope,
    TraceFormatter,
    TypeFactory,
    Value,
    ValueFactory,
    Variable,
    VariableFactory
) {
    var THROWABLE_INTERFACE = 'Throwable',
        hasOwn = {}.hasOwnProperty,
        setUpState = function (state, installedBuiltinTypes, optionGroups) {
            var globalNamespace = state.globalNamespace;

            /**
             * Bindings allow components of an addon to share data.
             *
             * @param {Function} groupFactory
             */
            function installBindingGroup(groupFactory) {
                var groupBindings = groupFactory(state.ffiInternals);

                _.each(groupBindings, function (bindingFactory, bindingName) {
                    var bindingOptions = state.optionSet.getOption(bindingName);

                    state.bindings[bindingName] = bindingFactory(bindingOptions);
                });
            }

            /**
             * Installs a set of related functions into PHP-land
             *
             * @param {Function} groupFactory
             */
            function installFunctionGroup(groupFactory) {
                var groupBuiltins = groupFactory(state.ffiInternals),
                    functionAliases = {};

                _.each(groupBuiltins, function (fn, name) {
                    if (typeof fn === 'function') {
                        state.defineNonCoercingFunction(name, fn);
                    } else {
                        // Gather function aliases (strings) and install the aliases at the end
                        // (see below), to ensure that the original functions exist first
                        // as an alias can only be installed using an existing function's FunctionSpec
                        functionAliases[name] = fn;
                    }
                });

                _.forOwn(functionAliases, function (originalName, aliasName) {
                    globalNamespace.aliasFunction(originalName, aliasName);
                });
            }

            /**
             * Installs a single class into PHP-land
             *
             * @param {Function} definitionFactory
             * @param {string} name
             */
            function installClass(definitionFactory, name) {
                state.defineClass(name, definitionFactory);
            }

            /**
             * Installs a set of related classes into PHP-land
             *
             * @param {Function} groupFactory
             */
            function installClassGroup(groupFactory) {
                var groupBuiltins = groupFactory(state.ffiInternals);

                _.each(groupBuiltins, function (definitionFactory, name) {
                    state.defineClass(name, definitionFactory);
                });
            }

            /**
             * Installs a set of related constants into PHP-land
             *
             * @param {Function} groupFactory
             */
            function installConstantGroup(groupFactory) {
                var groupBuiltins = groupFactory(state.ffiInternals);

                _.each(groupBuiltins, function (value, name) {
                    globalNamespace.defineConstant(name, state.valueFactory.coerce(value));
                });
            }

            /**
             * Installs a set of defaults for INI options
             *
             * @param {Function} groupFactory
             */
            function installDefaultINIOptionGroup(groupFactory) {
                var groupBuiltins = groupFactory(state.ffiInternals);

                _.each(groupBuiltins, function (value, name) {
                    state.iniState.set(name, value);
                });
            }

            /**
             * Installs a set of related runtime options
             *
             * @param {Function} groupFactory
             */
            function installOptionGroup(groupFactory) {
                var groupOptions = groupFactory(state.ffiInternals);

                _.extend(state.options, groupOptions);
            }

            /**
             * Installs a set of translations for one or more locales
             *
             * @param {object} cataloguesByLocale
             */
            function installTranslationCatalogues(cataloguesByLocale) {
                state.translator.addTranslations(cataloguesByLocale);
            }

            // Core builtins
            _.each(builtinTypes.translationCatalogues, installTranslationCatalogues);
            _.each(builtinTypes.constantGroups, installConstantGroup);
            _.each(builtinTypes.defaultINIGroups, installDefaultINIOptionGroup);
            _.each(builtinTypes.functionGroups, installFunctionGroup);
            _.each(builtinTypes.classGroups, installClassGroup);

            if (_.isArray(builtinTypes.classes)) {
                // Allow the class set to be an array, for grouping classes
                // so that they will load in a specific order (ie. when handling dependencies between them)
                _.each(builtinTypes.classes, function (classes) {
                    _.forOwn(classes, installClass);
                });
            } else {
                _.forOwn(builtinTypes.classes, installClass);
            }

            // Optional installed builtins
            _.each(optionGroups, installOptionGroup);
            state.bindings = {};
            _.each(installedBuiltinTypes.translationCatalogues, installTranslationCatalogues);
            _.each(installedBuiltinTypes.constantGroups, installConstantGroup);
            _.each(installedBuiltinTypes.defaultINIGroups, installDefaultINIOptionGroup);
            _.each(installedBuiltinTypes.bindingGroups, installBindingGroup);
            // TODO: Add "exposures" for addons to expose things to transpiled code
            // TODO: Add "externals" for addons to expose things to external code (eg. engine.getExternal(...))?
            _.each(installedBuiltinTypes.functionGroups, installFunctionGroup);
            _.each(installedBuiltinTypes.classGroups, installClassGroup);
            _.forOwn(installedBuiltinTypes.classes, installClass);
        },
        Exception = phpCommon.Exception,
        Translator = phpCommon.Translator;

    /**
     * Encapsulates an internal PHP state, defining classes, functions, global variables etc.
     *
     * For now this class also serves as the main dependency injection container for all services
     * that relate to a specific internal PHP environment's state.
     *
     * @param {Runtime} runtime
     * @param {GlobalStackHooker} globalStackHooker
     * @param {Object} installedBuiltinTypes
     * @param {Stream} stdin
     * @param {Stream} stdout
     * @param {Stream} stderr
     * @param {Resumable|null} pausable
     * @param {string} mode
     * @param {Function[]} optionGroups
     * @param {Object} options
     * @constructor
     */
    function PHPState(
        runtime,
        globalStackHooker,
        installedBuiltinTypes,
        stdin,
        stdout,
        stderr,
        pausable,
        mode,
        optionGroups,
        options
    ) {
        var callFactory = new CallFactory(Call, FFICall),
            elementProviderFactory = new ElementProviderFactory(),
            elementProvider = elementProviderFactory.createProvider(),
            moduleFactory = new ModuleFactory(Module),
            translator = new Translator(),
            iniState = new INIState(),
            getConstant = this.getConstant.bind(this),
            errorConfiguration = new ErrorConfiguration(iniState),
            errorConverter = new ErrorConverter(getConstant),
            traceFormatter = new TraceFormatter(translator),
            errorReporting = new ErrorReporting(
                errorConfiguration,
                errorConverter,
                traceFormatter,
                translator,
                stdout,
                stderr
            ),
            errorPromoter = new ErrorPromoter(errorReporting),
            ffiValueStorage = new FFIValueStorage(),
            valueFactory = new ValueFactory(
                pausable,
                mode,
                elementProvider,
                translator,
                callFactory,
                errorPromoter,
                ffiValueStorage
            ),
            callStack = new CallStack(valueFactory, translator, errorReporting, stderr),
            referenceFactory = new ReferenceFactory(
                AccessorReference,
                NullReference,
                valueFactory
            ),
            classAutoloader = new ClassAutoloader(valueFactory),
            superGlobalScope = new SuperGlobalScope(callStack, valueFactory),

            ffiCaller = new FFICaller(
                callFactory,
                callStack,
                errorPromoter,
                pausable,
                mode
            ),
            ffiNativeCaller = new FFINativeCaller(ffiCaller, mode),
            ffiValueCaller = new FFIValueCaller(ffiCaller, mode),
            ffiFactory = new FFIFactory(
                FFIAsyncObjectValue,
                FFIPHPObject,
                FFIValueCoercer,
                valueFactory,
                callStack,
                ffiNativeCaller,
                ffiValueCaller
            ),
            ffiProxyMemberFactory = new FFIProxyMemberFactory(
                valueFactory,
                ffiValueStorage,
                ffiNativeCaller
            ),
            ffiProxyClassFactory = new FFIProxyClassFactory(ffiValueStorage, ffiProxyMemberFactory),
            ffiProxyClassRepository = new FFIProxyClassRepository(ffiProxyClassFactory),
            ffiProxyFactory = new FFIProxyFactory(ffiProxyClassRepository, mode),
            ffiUnwrapperRepository = new FFIUnwrapperRepository(),
            ffiExportFactory = new FFIExportFactory(ffiUnwrapperRepository, ffiProxyFactory),
            ffiExportRepository = new FFIExportRepository(ffiExportFactory, ffiValueStorage),
            ffiValueHelper = new FFIValueHelper(ffiProxyFactory, ffiFactory, ffiValueStorage, mode),

            variableFactory = new VariableFactory(Variable, callStack, valueFactory),
            typeFactory = new TypeFactory(),
            parameterFactory = new ParameterFactory(Parameter, callStack, translator),
            parameterTypeFactory = new ParameterTypeFactory(typeFactory),
            parameterListFactory = new ParameterListFactory(parameterFactory, parameterTypeFactory),
            functionSpecFactory = new FunctionSpecFactory(
                FunctionSpec,
                FunctionContext,
                MethodContext,
                ClosureContext,
                callStack,
                parameterListFactory,
                valueFactory
            ),
            scopeFactory = new ScopeFactory(
                LoadScope,
                Scope,
                NamespaceScope,
                callStack,
                translator,
                superGlobalScope,
                functionSpecFactory,
                valueFactory,
                variableFactory,
                referenceFactory
            ),
            functionFactory = new FunctionFactory(
                MethodSpec,
                scopeFactory,
                callFactory,
                valueFactory,
                callStack
            ),
            closureFactory = new ClosureFactory(functionFactory, valueFactory, callStack, Closure),
            namespaceFactory = new NamespaceFactory(
                Namespace,
                callStack,
                functionFactory,
                functionSpecFactory,
                valueFactory,
                classAutoloader,
                ffiExportRepository,
                ffiFactory
            ),
            globalNamespace = namespaceFactory.create(),
            // The global/default module (not eg. the same as the command line module)
            globalModule = moduleFactory.create(null),
            // "Invisible" global namespace scope, not defined by any code
            globalNamespaceScope = new NamespaceScope(
                globalNamespace,
                valueFactory,
                callStack,
                globalModule,
                globalNamespace,
                true
            ),
            globalScope,
            ffiInternals,
            ffiClassInternalsClassFactory,
            ffiFunctionInternalsClassFactory,
            globalsSuperGlobal = superGlobalScope.defineVariable('GLOBALS'),
            optionSet,
            output = new Output(new OutputFactory(OutputBuffer), new StdoutBuffer(stdout)),
            state = this;

        scopeFactory.setClosureFactory(closureFactory);
        globalScope = scopeFactory.create();
        scopeFactory.setGlobalScope(globalScope);
        classAutoloader.setGlobalNamespace(globalNamespace);
        valueFactory.setCallStack(callStack);
        valueFactory.setGlobalNamespace(globalNamespace);

        // Make a copy of the options object so we don't mutate it
        options = _.extend({}, options || {});

        optionSet = new OptionSet(options);

        ffiInternals = new FFIInternals(
            mode,
            pausable,
            valueFactory,
            callFactory,
            callStack,
            ffiValueHelper,
            classAutoloader,
            errorConfiguration,
            errorPromoter,
            errorReporting,
            globalNamespace,
            globalScope,
            iniState,
            optionSet,
            output,
            runtime,
            stdout,
            traceFormatter,
            translator,
            state
        );
        ffiClassInternalsClassFactory = new FFIClassInternalsClassFactory(
            ffiInternals,
            ffiUnwrapperRepository,
            valueFactory,
            globalNamespace,
            globalNamespaceScope
        );
        ffiFunctionInternalsClassFactory = new FFIFunctionInternalsClassFactory(
            ffiInternals,
            valueFactory,
            ffiFactory,
            globalNamespace,
            globalNamespaceScope
        );

        // Set up the $GLOBALS superglobal
        globalsSuperGlobal.setReference(
            referenceFactory.createAccessor(
                function () {
                    var globalsArray,
                        globalValues = globalScope.exportVariables(),
                        elementHookCollection = elementProviderFactory.createElementHookCollection(),
                        hookableElementProvider = elementProviderFactory.createHookableProvider(
                            elementProvider,
                            elementHookCollection
                        );

                    // Use a hookable array for $GLOBALS, so that we do not take a performance hit
                    // for normal non-$GLOBALS arrays, as we would if we added hooking to all of them
                    // without using the decorator pattern
                    globalsArray = valueFactory.createArray(globalValues, hookableElementProvider);

                    // $GLOBALS should have a recursive reference to itself
                    globalsArray.getElementByKey(valueFactory.createString('GLOBALS'))
                        .setReference(globalsSuperGlobal.getReference());

                    // Install hooks to ensure that modifications to the $GLOBALS array
                    // are reflected in the corresponding global variables
                    elementHookCollection.onElementReferenceSet(function (elementReference, referenceSet) {
                        var globalVariableName = elementReference.getKey().getNative();

                        globalScope.getVariable(globalVariableName).setReference(referenceSet);
                    });
                    elementHookCollection.onElementValueSet(function (elementReference, valueSet) {
                        var globalVariableName = elementReference.getKey().getNative();

                        globalScope.getVariable(globalVariableName).setValue(valueSet);
                    });
                    elementHookCollection.onElementUnset(function (elementReference) {
                        var globalVariableName = elementReference.getKey().getNative();

                        globalScope.getVariable(globalVariableName).unset();
                    });

                    return globalsArray;
                },
                function (newNative) {
                    // Clear these accessors first
                    globalsSuperGlobal.unset();

                    globalsSuperGlobal.setValue(valueFactory.coerce(newNative));
                }
            )
        );

        this.bindings = null;
        this.callFactory = callFactory;
        this.callStack = callStack;
        this.ClassInternals = ffiClassInternalsClassFactory.create();
        this.errorReporting = errorReporting;
        this.FunctionInternals = ffiFunctionInternalsClassFactory.create();
        this.globalNamespace = globalNamespace;
        this.globalNamespaceScope = globalNamespaceScope;
        this.globalScope = globalScope;
        this.iniState = iniState;
        this.options = options;
        this.optionSet = optionSet;
        this.ffiInternals = ffiInternals;
        this.ffiStackHooker = new FFIStackHooker(globalStackHooker, this.optionSet);
        this.ffiValueHelper = ffiValueHelper;
        this.output = output;

        this.loader = new Loader(valueFactory, pausable);
        this.moduleFactory = moduleFactory;
        this.referenceFactory = referenceFactory;
        this.scopeFactory = scopeFactory;
        this.callStack = callStack;
        this.classAutoloader = classAutoloader;
        this.pausable = pausable;
        this.stderr = stderr;
        this.stdin = stdin;
        this.stdout = stdout;
        this.superGlobalScope = superGlobalScope;
        this.throwableClassObject = null;
        this.translator = translator;
        this.valueFactory = valueFactory;

        setUpState(this, installedBuiltinTypes, optionGroups || []);

        // Install custom FFI JS engine stack trace handling, if enabled
        this.ffiStackHooker.hook();

        // Set any INI options provided
        _.forOwn(options.ini, function (value, name) {
            iniState.set(name, value);
        });
    }

    _.extend(PHPState.prototype, {
        /**
         * Defines the given alias for the given function
         *
         * @param {string} originalName
         * @param {string} aliasName
         */
        aliasFunction: function (originalName, aliasName) {
            this.globalNamespace.aliasFunction(originalName, aliasName);
        },

        /**
         * Creates a new FFI Result, to provide the result of a call to a JS function
         *
         * @param {Function} syncCallback
         * @param {Function|null} asyncCallback
         * @returns {FFIResult}
         */
        createFFIResult: function (syncCallback, asyncCallback) {
            return new FFIResult(syncCallback, asyncCallback, this.pausable);
        },

        /**
         * Defines a new class (in any namespace)
         *
         * @param {string} fqcn FQCN of the class to define
         * @param {function} definitionFactory Called with `internals` object, returns the class definition
         * @returns {Class} Returns the instance of Class that represents a PHP class
         */
        defineClass: function (fqcn, definitionFactory) {
            var state = this,
                classInternals = new state.ClassInternals(fqcn),
                classObject = classInternals.defineClass(definitionFactory);

            if (fqcn === THROWABLE_INTERFACE) {
                if (state.throwableClassObject) {
                    throw new Error('PHPState.defineClass(...) :: Throwable interface is already defined');
                }

                state.throwableClassObject = classObject;
            }

            return classObject;
        },

        /**
         * Defines a global function from a native JS one. If a fully-qualified name is provided
         * with a namespace prefix, eg. `My\Lib\MyFunc` then it will be defined in the specified namespace
         *
         * @param {string} name
         * @param {Function} fn
         */
        defineCoercingFunction: function (name, fn) {
            this.defineFunction(name, function () {
                return fn;
            });
        },

        /**
         * Defines a constant with the given native value
         *
         * @param {string} name
         * @param {*} nativeValue
         * @param {object} options
         */
        defineConstant: function (name, nativeValue, options) {
            var state = this,
                parsed = state.globalNamespace.parseName(name),
                value = state.valueFactory.coerce(nativeValue);

            parsed.namespace.defineConstant(parsed.name, value, options);
        },

        /**
         * Defines a global function from a native JS one. If a fully-qualified name is provided
         * with a namespace prefix, eg. `My\Lib\MyFunc` then it will be defined in the specified namespace
         *
         * @param {string} fqfn
         * @param {Function} definitionFactory
         */
        defineFunction: function (fqfn, definitionFactory) {
            var state = this,
                functionInternals = new state.FunctionInternals(fqfn);

            functionInternals.defineFunction(definitionFactory);
        },

        /**
         * Defines a global variable and gives it the provided value,
         * if not already defined. If the variable is already defined
         * in this scope then an error will be thrown
         *
         * @param {string} name
         * @param {Value|*} value Value object or native value to be coerced
         * @throws {Error} Throws when the global scope already defines the specified variable
         */
        defineGlobal: function (name, value) {
            var state = this;

            if (state.globalScope.hasVariable(name)) {
                throw new Error(
                    'PHPState.defineGlobal() :: Variable "' + name + '" is already defined in the global scope'
                );
            }

            state.globalScope.defineVariable(name).setValue(state.valueFactory.coerce(value));
        },

        /**
         * Defines a global variable using a getter/setter pair
         *
         * @param {string} name
         * @param {Function} valueGetter
         * @param {Function} valueSetter
         */
        defineGlobalAccessor: function (name, valueGetter, valueSetter) {
            var state = this,
                accessorReference = state.referenceFactory.createAccessor(valueGetter, valueSetter);

            state.globalScope.defineVariable(name).setReference(accessorReference);
        },

        /**
         * Defines a global function from a native JS one. If a fully-qualified name is provided
         * with a namespace prefix, eg. `My\Lib\MyFunc` then it will be defined in the specified namespace
         *
         * @param {string} name
         * @param {Function} fn
         */
        defineNonCoercingFunction: function (name, fn) {
            this.defineFunction(name, function (internals) {
                internals.disableAutoCoercion();

                return fn;
            });
        },

        /**
         * Defines a super global variable (available in all scopes implicitly,
         * unlike a normal global which is not available unless imported with a `global` statement)
         * and gives it the provided value. If a native value is given then it will be coerced to a PHP one.
         *
         * @param {string} name
         * @param {Value|*} value
         */
        defineSuperGlobal: function (name, value) {
            var state = this;

            state.superGlobalScope
                .defineVariable(name)
                .setValue(state.valueFactory.coerce(value));
        },

        /**
         * Defines a super global variable (see above) using a getter/setter pair
         *
         * @param {string} name
         * @param {Function} valueGetter
         * @param {Function} valueSetter
         */
        defineSuperGlobalAccessor: function (name, valueGetter, valueSetter) {
            var state = this,
                accessorReference = state.referenceFactory.createAccessor(valueGetter, valueSetter);

            state.superGlobalScope.defineVariable(name).setReference(accessorReference);
        },

        /**
         * Fetches the specified binding from an installed addon
         *
         * @param {string} bindingName
         * @returns {*}
         */
        getBinding: function (bindingName) {
            var state = this;

            if (state.bindings === null) {
                // Option groups are loaded before bindings, so if any of them attempt to access a binding
                // too early then throw a meaningful error message
                throw new Exception('Option groups cannot access bindings too early');
            }

            if (!hasOwn.call(state.bindings, bindingName)) {
                throw new Exception('No binding is defined with name "' + bindingName + '"');
            }

            return state.bindings[bindingName];
        },

        getCallFactory: function () {
            return this.callFactory;
        },

        getCallStack: function () {
            return this.callStack;
        },

        getConstant: function (name) {
            var value;

            try {
                value = this.globalNamespace.getConstant(name, true);
            } catch (error) {
                return null;
            }

            return value.getNative();
        },

        /**
         * Fetches the ErrorReporting service
         *
         * @returns {ErrorReporting}
         */
        getErrorReporting: function () {
            return this.errorReporting;
        },

        /**
         * Fetches the FFI value helper service
         *
         * @returns {ValueHelper}
         */
        getFFIValueHelper: function () {
            return this.ffiValueHelper;
        },

        /**
         * Fetches either a global function or one in a namespace
         *
         * @param {string} name FQCN of the function to fetch
         * @return {Function}
         */
        getFunction: function (name) {
            var parsed = this.globalNamespace.parseName(name);

            return parsed.namespace.getFunction(parsed.name);
        },

        /**
         * Fetches the value of a global variable, if defined.
         * If the variable is not defined then a NULL value will be returned.
         *
         * @param {string} name
         * @return {Value}
         */
        getGlobal: function (name) {
            return this.globalScope.getVariable(name).getValueOrNull();
        },

        getGlobalNamespace: function () {
            return this.globalNamespace;
        },

        getGlobalScope: function () {
            return this.globalScope;
        },

        /**
         * Fetches the native value of an INI option
         *
         * @param {string} name
         * @returns {*}
         */
        getINIOption: function (name) {
            return this.iniState.get(name);
        },

        /**
         * Fetches the Loader for the runtime state, used for include/require and eval(...)
         *
         * @returns {Loader}
         */
        getLoader: function () {
            return this.loader;
        },

        getModuleFactory: function () {
            return this.moduleFactory;
        },

        getOptions: function () {
            return this.optionSet.getOptions();
        },

        /**
         * Fetches the Output service for the runtime state, used for handling buffering and writing to standard out
         *
         * @returns {Output}
         */
        getOutput: function () {
            return this.output;
        },

        /**
         * Fetches the ReferenceFactory service
         *
         * @returns {ReferenceFactory}
         */
        getReferenceFactory: function () {
            return this.referenceFactory;
        },

        /**
         * Fetches the ScopeFactory for the runtime state
         *
         * @returns {ScopeFactory}
         */
        getScopeFactory: function () {
            return this.scopeFactory;
        },

        getStderr: function () {
            return this.stderr;
        },

        getStdin: function () {
            return this.stdin;
        },

        getStdout: function () {
            return this.stdout;
        },

        getSuperGlobalScope: function () {
            return this.superGlobalScope;
        },

        /**
         * Fetches the Translator service
         *
         * @returns {Translator}
         */
        getTranslator: function () {
            return this.translator;
        },

        getValueFactory: function () {
            return this.valueFactory;
        },

        /**
         * Sets the value of an existing PHP global. If a native value is given
         * then it will be coerced to a PHP one.
         * If the global is not defined than an error will be thrown -
         * use .defineGlobal(...) when defining a new variable
         *
         * @param {string} name
         * @param {Value|*} value Value object or native value to be coerced
         * @throws {Error} Throws if the variable is not defined in the global scope
         */
        setGlobal: function (name, value) {
            var state = this;

            if (!state.globalScope.hasVariable(name)) {
                throw new Error(
                    'PHPState.setGlobal() :: Variable "' + name + '" is not defined in the global scope'
                );
            }

            state.globalScope.getVariable(name).setValue(state.valueFactory.coerce(value));
        }
    });

    return PHPState;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/AccessorReference.js":
/*!*****************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/AccessorReference.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js");

function AccessorReference(valueFactory, valueGetter, valueSetter) {
    this.valueFactory = valueFactory;
    this.valueGetter = valueGetter;
    this.valueSetter = valueSetter;
}

util.inherits(AccessorReference, Reference);

_.extend(AccessorReference.prototype, {
    getReference: function () {
        return this;
    },

    getValue: function () {
        var reference = this;

        return reference.valueFactory.coerce(reference.valueGetter());
    },

    /**
     * Determines whether this reference is defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        return true;
    },

    setValue: function (value) {
        this.valueSetter(value.getNative());

        return value;
    }
});

module.exports = AccessorReference;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Element.js":
/*!*******************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Element.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    KeyReferencePair = __webpack_require__(/*! ../KeyReferencePair */ "./node_modules/phpcore/src/KeyReferencePair.js"),
    KeyValuePair = __webpack_require__(/*! ../KeyValuePair */ "./node_modules/phpcore/src/KeyValuePair.js"),
    PHPError = phpCommon.PHPError,
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js"),
    ReferenceSlot = __webpack_require__(/*! ./ReferenceSlot */ "./node_modules/phpcore/src/Reference/ReferenceSlot.js");

function ElementReference(valueFactory, callStack, arrayValue, key, value, reference) {
    if (value && reference) {
        throw new Error('Array elements can only have a value or be a reference, not both');
    }

    this.arrayValue = arrayValue;
    this.key = key;
    this.reference = reference || null;
    this.callStack = callStack;
    this.value = value || null;
    this.valueFactory = valueFactory;
}

util.inherits(ElementReference, Reference);

_.extend(ElementReference.prototype, {
    getKey: function () {
        return this.key;
    },

    /**
     * Fetches the relevant type of Pair class to represent this array element.
     * If the element is a reference (to a variable, another array element or object property)
     * then a KeyReferencePair will be returned.
     * Otherwise the element simply holds a value, in which case a KeyValuePair will be returned.
     *
     * @param {Value|undefined} overrideKey Optional key to use rather than this element's
     * @returns {KeyReferencePair|KeyValuePair}
     * @throws {Error} Throws when the element is neither defined as a reference nor with a value
     */
    getPairForAssignment: function (overrideKey) {
        var element = this;

        if (!overrideKey) {
            overrideKey = element.key;
        }

        if (element.value) {
            return new KeyValuePair(overrideKey, element.value.getForAssignment());
        }

        if (element.reference) {
            return new KeyReferencePair(overrideKey, element.reference);
        }

        throw new Error('Element is not defined');
    },

    /**
     * Fetches a reference to this element's value
     *
     * @returns {Reference}
     */
    getReference: function () {
        var element = this;

        if (element.reference) {
            // This element already refers to something else, so return its target
            return element.reference;
        }

        // Implicitly define a "slot" to contain this element's value
        element.reference = new ReferenceSlot(element.valueFactory);

        if (element.value) {
            element.reference.setValue(element.value);
            element.value = null; // This element now has a reference (to the slot) and not a value
        }

        return element.reference;
    },

    getValue: function () {
        var element = this;

        // Special value of native null (vs. NullValue) represents undefined
        if (!element.value && !element.reference) {
            element.callStack.raiseError(PHPError.E_NOTICE, 'Undefined ' + element.arrayValue.referToElement(element.key.getNative()));
            return element.valueFactory.createNull();
        }

        return element.value ? element.value : element.reference.getValue();
    },

    getValueReference: function () {
        var element = this;

        return element.reference || element.value || null;
    },

    /**
     * Determines whether this reference is defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        var element = this;

        return !!(element.value || element.reference);
    },

    /**
     * Determines whether the specified array element is "empty" or not
     *
     * @returns {boolean}
     */
    isEmpty: function () {
        var element = this;

        if (element.value) {
            return element.value.isEmpty();
        }

        if (element.reference) {
            return element.reference.getValue().isEmpty();
        }

        return true; // Undefined elements are empty
    },

    isReference: function () {
        return !!this.reference;
    },

    isSet: function () {
        var element = this;

        if (element.value) {
            return element.value.isSet();
        }

        if (element.reference) {
            return element.reference.getValue().isSet();
        }

        return false;
    },

    /**
     * Sets the key for this element
     *
     * @param {Value} keyValue
     */
    setKey: function (keyValue) {
        this.key = keyValue;
    },

    setReference: function (reference) {
        var element = this;

        element.reference = reference;
        element.value = null;

        element.arrayValue.defineElement(element);

        return reference;
    },

    setValue: function (value) {
        var element = this,
            isFirstElement = (element.arrayValue.getLength() === 0);

        if (element.key === null) {
            // This reference refers to a new element to push onto the end of an array
            element.arrayValue.pushElement(element);
        }

        if (element.reference) {
            element.reference.setValue(value);
        } else {
            element.arrayValue.defineElement(element);
            element.value = value.getForAssignment();
        }

        if (isFirstElement) {
            element.arrayValue.pointToElement(element);
        }

        return value;
    },

    unset: function () {
        var element = this;

        element.value = element.reference = null;
    }
});

module.exports = ElementReference;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Element/ElementHookCollection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Element/ElementHookCollection.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Contains a set of hooks to be called when various operations are performed on a hookable array's elements
 *
 * @constructor
 */
function ElementHookCollection() {
    /**
     * @type {Function[]}
     */
    this.onElementReferenceSetCallbacks = [];
    /**
     * @type {Function[]}
     */
    this.onElementValueSetCallbacks = [];
    /**
     * @type {Function[]}
     */
    this.onElementUnsetCallbacks = [];
}

_.extend(ElementHookCollection.prototype, {
    /**
     * Handles the setting of a hookable element's reference by invoking all relevant callbacks
     *
     * @param {HookableElement} element
     * @param {Reference} referenceSet
     */
    handleElementReferenceSet: function (element, referenceSet) {
        _.each(this.onElementReferenceSetCallbacks, function (callback) {
            callback(element, referenceSet);
        });
    },

    /**
     * Handles the setting of a hookable element's value by invoking all relevant callbacks
     *
     * @param {HookableElement} element
     * @param {Value} valueSet
     */
    handleElementValueSet: function (element, valueSet) {
        _.each(this.onElementValueSetCallbacks, function (callback) {
            callback(element, valueSet);
        });
    },

    /**
     * Handles the unsetting of a hookable element by invoking all relevant callbacks
     *
     * @param {HookableElement} element
     */
    handleElementUnset: function (element) {
        _.each(this.onElementUnsetCallbacks, function (callback) {
            callback(element);
        });
    },

    /**
     * Installs a new hook callback to be called when a hookable element's reference is set
     *
     * @param {Function} callback
     */
    onElementReferenceSet: function (callback) {
        this.onElementReferenceSetCallbacks.push(callback);
    },

    /**
     * Installs a new hook callback to be called when a hookable element's value is set
     *
     * @param {Function} callback
     */
    onElementValueSet: function (callback) {
        this.onElementValueSetCallbacks.push(callback);
    },

    /**
     * Installs a new hook callback to be called when a hookable element is unset
     *
     * @param {Function} callback
     */
    onElementUnset: function (callback) {
        this.onElementUnsetCallbacks.push(callback);
    }
});

module.exports = ElementHookCollection;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Element/ElementProvider.js":
/*!***********************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Element/ElementProvider.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    ElementReference = __webpack_require__(/*! ../Element */ "./node_modules/phpcore/src/Reference/Element.js");

/**
 * Creates standard (unhooked) array elements
 *
 * @constructor
 */
function ElementProvider() {

}

_.extend(ElementProvider.prototype, {
    /**
     * Creates a standard (unhooked) array element
     *
     * @param {ValueFactory} valueFactory
     * @param {CallStack} callStack
     * @param {ArrayValue} arrayValue
     * @param {Value} key
     * @param {Value|null} value
     * @param {Reference|null} reference
     * @returns {ElementReference}
     */
    createElement: function (valueFactory, callStack, arrayValue, key, value, reference) {
        return new ElementReference(valueFactory, callStack, arrayValue, key, value, reference);
    }
});

module.exports = ElementProvider;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Element/ElementProviderFactory.js":
/*!******************************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Element/ElementProviderFactory.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    ElementHookCollection = __webpack_require__(/*! ./ElementHookCollection */ "./node_modules/phpcore/src/Reference/Element/ElementHookCollection.js"),
    ElementProvider = __webpack_require__(/*! ./ElementProvider */ "./node_modules/phpcore/src/Reference/Element/ElementProvider.js"),
    HookableElementProvider = __webpack_require__(/*! ./HookableElementProvider */ "./node_modules/phpcore/src/Reference/Element/HookableElementProvider.js");

/**
 * Creates element providers and objects related to them
 *
 * @constructor
 */
function ElementProviderFactory() {

}

_.extend(ElementProviderFactory.prototype, {
    /**
     * Creates a new ElementHookCollection to be passed to a HookableElementProvider
     *
     * @returns {ElementHookCollection}
     */
    createElementHookCollection: function () {
        return new ElementHookCollection();
    },

    /**
     * Creates a new HookableElementProvider
     *
     * @param {ElementProvider} baseElementProvider
     * @param {ElementHookCollection} elementHookCollection
     * @returns {HookableElementProvider}
     */
    createHookableProvider: function (baseElementProvider, elementHookCollection) {
        return new HookableElementProvider(baseElementProvider, elementHookCollection);
    },

    /**
     * Creates a new ElementProvider
     *
     * @returns {ElementProvider}
     */
    createProvider: function () {
        return new ElementProvider();
    }
});

module.exports = ElementProviderFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Element/HookableElement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Element/HookableElement.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Reference = __webpack_require__(/*! ../Reference */ "./node_modules/phpcore/src/Reference/Reference.js");

/**
 * Decorates an ElementReference to allow it to be hooked into
 *
 * @param {ElementReference} decoratedElement
 * @param {ElementHookCollection} elementHookCollection
 * @constructor
 */
function HookableElementReference(decoratedElement, elementHookCollection) {
    /**
     * @type {ElementReference}
     */
    this.decoratedElement = decoratedElement;
    /**
     * @type {ElementHookCollection}
     */
    this.elementHookCollection = elementHookCollection;
}

util.inherits(HookableElementReference, Reference);

_.extend(HookableElementReference.prototype, {
    /**
     * Fetches an instance property of this element (assuming it contains an object) by its name
     *
     * @param {string} name
     * @returns {PropertyReference}
     */
    getInstancePropertyByName: function (name) {
        return this.decoratedElement.getInstancePropertyByName(name);
    },

    /**
     * Fetches this element's key value
     *
     * @returns {Value}
     */
    getKey: function () {
        return this.decoratedElement.getKey();
    },

    /**
     * Fetches the relevant type of Pair class to represent this array element.
     * If the element is a reference (to a variable, another array element or object property)
     * then a KeyReferencePair will be returned.
     * Otherwise the element simply holds a value, in which case a KeyValuePair will be returned.
     *
     * @param {Value|undefined} overrideKey Optional key to use rather than this element's
     * @returns {KeyReferencePair|KeyValuePair}
     */
    getPairForAssignment: function (overrideKey) {
        return this.decoratedElement.getPairForAssignment(overrideKey);
    },

    /**
     * Fetches a reference to this element
     *
     * @returns {HookableElementReference}
     */
    getReference: function () {
        return this;
    },

    /**
     * Fetches the value of this element (or the value of its reference, if set)
     *
     * @returns {Value}
     */
    getValue: function () {
        return this.decoratedElement.getValue();
    },

    /**
     * Fetches either the value or the reference of this element, depending on which (if any) is set
     *
     * @returns {Reference|Value}
     */
    getValueReference: function () {
        return this.decoratedElement.getValueReference();
    },

    /**
     * Determines whether this element is "defined" (whether it has either a value or reference set)
     *
     * @returns {boolean}
     */
    isDefined: function () {
        return this.decoratedElement.isDefined();
    },

    /**
     * Determines whether the specified array element is "empty" or not
     *
     * @returns {boolean}
     */
    isEmpty: function () {
        return this.decoratedElement.isEmpty();
    },

    /**
     * Determines whether this element has a reference set rather than a value
     *
     * @returns {boolean}
     */
    isReference: function () {
        return this.decoratedElement.isReference();
    },

    /**
     * Determines whether this element is defined and if so, whether its value or reference is "set"
     *
     * @returns {boolean}
     */
    isSet: function () {
        return this.decoratedElement.isSet();
    },

    /**
     * Sets the key for this element
     *
     * @param {Value} keyValue
     */
    setKey: function (keyValue) {
        this.decoratedElement.setKey(keyValue);
    },

    /**
     * Sets a reference for this element to refer to, clearing any value it may currently have
     *
     * @param {Reference} reference
     */
    setReference: function (reference) {
        var element = this;

        element.decoratedElement.setReference(reference);
        element.elementHookCollection.handleElementReferenceSet(element, reference);
    },

    /**
     * Sets a value for this element to have, clearing any reference it may currently have
     *
     * @param {Value} value
     */
    setValue: function (value) {
        var element = this;

        element.decoratedElement.setValue(value);
        element.elementHookCollection.handleElementValueSet(element, value);
    },

    /**
     * Unsets this element, so that it no longer refers to a reference or holds a value
     */
    unset: function () {
        var element = this;

        element.decoratedElement.unset();
        element.elementHookCollection.handleElementUnset(element);
    }
});

module.exports = HookableElementReference;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Element/HookableElementProvider.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Element/HookableElementProvider.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    HookableElement = __webpack_require__(/*! ./HookableElement */ "./node_modules/phpcore/src/Reference/Element/HookableElement.js");

/**
 * Creates hookable array elements, which will invoke hooks in the given collection where applicable
 *
 * @param {ElementProvider} baseElementProvider
 * @param {ElementHookCollection} elementHookCollection
 * @constructor
 */
function HookableElementProvider(baseElementProvider, elementHookCollection) {
    /**
     * @type {ElementProvider}
     */
    this.baseElementProvider = baseElementProvider;
    /**
     * @type {ElementHookCollection}
     */
    this.elementHookCollection = elementHookCollection;
}

_.extend(HookableElementProvider.prototype, {
    /**
     * Creates a new HookableElement
     *
     * @param {ValueFactory} valueFactory
     * @param {CallStack} callStack
     * @param {ArrayValue} arrayValue
     * @param {Value} key
     * @param {Value|null }value
     * @param {Reference|null} reference
     * @returns {HookableElementReference}
     */
    createElement: function (valueFactory, callStack, arrayValue, key, value, reference) {
        var provider = this,
            decoratedElement = provider.baseElementProvider.createElement(
                valueFactory,
                callStack,
                arrayValue,
                key,
                value,
                reference
            );

        return new HookableElement(decoratedElement, provider.elementHookCollection);
    }
});

module.exports = HookableElementProvider;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Null.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Null.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js");

function NullReference(valueFactory, options) {
    options = options || {};

    this.onSet = options.onSet;
    this.valueFactory = valueFactory;
}

util.inherits(NullReference, Reference);

_.extend(NullReference.prototype, {
    getReference: function () {
        return this;
    },

    getValue: function () {
        return this.valueFactory.createNull();
    },

    /**
     * Determines whether this reference is defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        return false;
    },

    /**
     * Determines whether this reference is empty or not
     * (NULL references are always empty)
     *
     * @returns {boolean}
     */
    isEmpty: function () {
        return true; // PHP NULL is classed as empty
    },

    isSet: function () {
        return false;
    },

    setValue: function () {
        var reference = this;

        if (reference.onSet) {
            reference.onSet();
        }
    }
});

module.exports = NullReference;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/ObjectElement.js":
/*!*************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/ObjectElement.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js");

function ObjectElement(valueFactory, objectValue, keyValue) {
    this.keyValue = keyValue;
    this.objectValue = objectValue;
    this.valueFactory = valueFactory;
}

util.inherits(ObjectElement, Reference);

_.extend(ObjectElement.prototype, {
    getReference: function () {
        return this;
    },

    getValue: function () {
        var element = this;

        return element.objectValue.callMethod('offsetGet', [element.keyValue]);
    },

    /**
     * Determines whether this reference is defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        var element = this;

        return element.objectValue.callMethod('offsetExists', [element.keyValue]).getNative();
    },

    /**
     * Determines whether an element of an object is classed as empty.
     * Objects may only have an element fetched if they can be treated as an array,
     * by implementing ArrayAccess
     *
     * @returns {boolean}
     */
    isEmpty: function () {
        var element = this;

        // When using empty() ArrayAccess::offsetGet() will be called and checked
        // if empty only if ArrayAccess::offsetExists() returns TRUE.
        return !element.objectValue.callMethod('offsetExists', [element.keyValue]).getNative() ||
            element.objectValue.callMethod('offsetGet', [element.keyValue]).isEmpty();
    },

    /**
     * Determines whether an element of an object is classed as set.
     * Objects may only have an element fetched if they can be treated as an array,
     * by implementing ArrayAccess
     *
     * @returns {boolean}
     */
    isSet: function () {
        var element = this;

        return element.objectValue.callMethod('offsetExists', [element.keyValue]).getNative() &&
            element.objectValue.callMethod('offsetGet', [element.keyValue]).isSet();
    },

    setValue: function (value) {
        var element = this;

        element.objectValue.callMethod('offsetSet', [element.keyValue, value]);
    },

    unset: function () {
        var element = this;

        element.objectValue.callMethod('offsetUnset', [element.keyValue]);
    }
});

module.exports = ObjectElement;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Property.js":
/*!********************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Property.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    MAGIC_GET = '__get',
    MAGIC_SET = '__set',
    MAGIC_UNSET = '__unset',
    PHPError = phpCommon.PHPError,
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js"),
    ReferenceSlot = __webpack_require__(/*! ./ReferenceSlot */ "./node_modules/phpcore/src/Reference/ReferenceSlot.js");

/**
 * @param {ValueFactory} valueFactory
 * @param {CallStack} callStack
 * @param {ObjectValue} objectValue
 * @param {Value} key
 * @param {Class} classObject Class in the hierarchy that defines the property - may be an ancestor
 * @param {string} visibility "private", "protected" or "public"
 * @param {number} index
 * @constructor
 */
function PropertyReference(valueFactory, callStack, objectValue, key, classObject, visibility, index) {
    /**
     * @type {Class}
     */
    this.classObject = classObject;
    /**
     * @type {number}
     */
    this.index = index;
    /**
     * @type {ObjectValue}
     */
    this.objectValue = objectValue;
    /**
     * @type {Value}
     */
    this.key = key;
    /**
     * @type {Reference|null}
     */
    this.reference = null;
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * Value of this property - a native null value indicates that the property is not defined
     *
     * @type {Value|null}
     */
    this.value = null;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
    /**
     * @type {string}
     */
    this.visibility = visibility;
}

util.inherits(PropertyReference, Reference);

_.extend(PropertyReference.prototype, {
    /**
     * Fetches the unique name of this property as viewed from outside the class (eg. when casting to array)
     *
     * @returns {*}
     */
    getExternalName: function () {
        var property = this;

        switch (property.visibility) {
            case 'private':
                return '\0' + property.classObject.getName() + '\0' + property.key.getNative();
            case 'protected':
                return '\0*\0' + property.key.getNative();
            default:
                return property.key.getNative();
        }
    },

    /**
     * Fetches the index of this property within its object
     *
     * @returns {number}
     */
    getIndex: function () {
        return this.index;
    },

    getKey: function () {
        return this.key;
    },

    /**
     * Fetches a reference to this property's value
     *
     * @returns {Reference}
     */
    getReference: function () {
        var property = this;

        if (property.reference) {
            // This property already refers to something else, so return its target
            return property.reference;
        }

        // Implicitly define a "slot" to contain this property's value
        property.reference = new ReferenceSlot(property.valueFactory);

        if (property.value) {
            property.reference.setValue(property.value);
            property.value = null; // This property now has a reference (to the slot) and not a value
        }

        return property.reference;
    },

    /**
     * Fetches the value of this property on its object. If it is not defined,
     * and a magic __get getter method is defined, it will be called,
     * otherwise a notice will be raised and NULL returned
     *
     * @returns {Value}
     */
    getValue: function () {
        var property = this;

        // Special value of native null (vs. NullValue) represents undefined
        if (!property.isDefined()) {
            if (property.objectValue.isMethodDefined(MAGIC_GET)) {
                // Magic getter method is defined, so use it
                return property.objectValue.callMethod(MAGIC_GET, [property.key]);
            }

            property.callStack.raiseError(
                PHPError.E_NOTICE,
                'Undefined ' + property.objectValue.referToElement(
                    property.key.getNative()
                )
            );

            return property.valueFactory.createNull();
        }

        if (property.value) {
            return property.value;
        }

        if (property.reference) {
            return property.reference.getValue();
        }

        throw new Error('Defined properties should have a value or reference assigned');
    },

    /**
     * Fetches the visibility of this property
     *
     * @returns {string}
     */
    getVisibility: function () {
        return this.visibility;
    },

    /**
     * Sets the initial value for this property, ignoring any magic setter
     *
     * @param {Value} value
     */
    initialise: function (value) {
        this.value = value.getForAssignment();
    },

    /**
     * Determines whether this property is defined. If assigned a value of NULL,
     * the property will still be considered defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        var property = this;

        if (property.reference) {
            return true;
        }

        // This property is defined if it has a non-native null value -
        // if it is defined but with a value of PHP NULL, `.value` will be an instance of NullValue
        return property.value !== null;
    },

    /**
     * Determines whether this object property is "empty" or not
     *
     * @returns {boolean}
     */
    isEmpty: function () {
        var property = this;

        if (property.isDefined()) {
            return property.getValue().isEmpty();
        }

        if (property.objectValue.isMethodDefined(MAGIC_GET)) {
            // Magic getter method is defined, so use it to determine the property's value
            // and then check _that_ for being "empty"
            return property.objectValue.callMethod(MAGIC_GET, [property.key]).isEmpty();
        }

        // Property is not defined and there is no magic getter,
        // so the property must be empty as it is unset and undefined
        return true;
    },

    isReference: function () {
        return !!this.reference;
    },

    /**
     * Determines whether this property is "set".
     * A set property must be both defined and have a non-NULL value
     *
     * @returns {boolean}
     */
    isSet: function () {
        var property = this,
            defined = property.isDefined();

        if (!defined) {
            return false;
        }

        // Check that the property resolves to something other than null,
        // otherwise it is not set
        // (no need to check for a value of native null - meaning an undefined property -
        //  as the check for that is done just above)
        return property.value.getType() !== 'null';
    },

    /**
     * Determines whether this property is visible from the calling scope
     * - for a private property, the calling scope must be inside that class
     * - for a protected property, the calling scope must be inside that class or an ancestor or descendant of it
     * - public properties are visible from everywhere
     *
     * @returns {boolean}
     */
    isVisible: function () {
        var property = this,
            // Fetch the class that the current line of PHP code is executing inside (if any)
            callingClass = property.callStack.getCurrentClass();

        if (property.getVisibility() === 'private') {
            // Private properties are only accessible by the class that defines them
            return callingClass &&
                property.classObject.getName() === callingClass.getName();
        }

        if (property.getVisibility() === 'protected') {
            // Protected properties may be accessed by the class that defines them
            // or an ancestor or descendant of it
            return callingClass &&
                callingClass.isInFamilyOf(property.classObject);
        }

        // Public visibility - public properties are always visible
        return true;
    },

    setReference: function (reference) {
        var property = this;

        property.reference = reference;

        return reference;
    },

    /**
     * Sets the value of this property on its object. If it is not defined,
     * and a magic __set setter method is defined, it will be called,
     * otherwise the property will be dynamically defined on the object
     *
     * @param {Value} value
     * @returns {Value}
     */
    setValue: function (value) {
        var property = this,
            isFirstProperty = (property.objectValue.getLength() === 0),
            valueForAssignment;

        function pointIfFirstProperty() {
            if (isFirstProperty) {
                property.objectValue.pointToProperty(property);
            }
        }

        if (property.reference) {
            property.reference.setValue(value);

            pointIfFirstProperty();

            return value;
        }

        valueForAssignment = value.getForAssignment();

        if (!property.isDefined()) {
            // Property is not defined - attempt to call magic setter method first,
            // otherwise just dynamically define the new property by setting its value below
            if (property.objectValue.isMethodDefined(MAGIC_SET)) {
                property.objectValue.callMethod(MAGIC_SET, [property.key, valueForAssignment]);

                return value;
            }
        }

        // No magic setter is defined - store the value of this property directly on itself
        property.value = valueForAssignment;

        pointIfFirstProperty();

        return value;
    },

    /**
     * Marks this property as unset and undefined
     */
    unset: function () {
        var property = this;

        if (!property.isDefined()) {
            // Property is not defined - call magic unsetter method if defined
            if (property.objectValue.isMethodDefined(MAGIC_UNSET)) {
                property.objectValue.callMethod(MAGIC_UNSET, [property.key]);
            }
        }

        // Clear value and/or reference to mark as unset
        property.value = property.reference = null;
    }
});

module.exports = PropertyReference;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/Reference.js":
/*!*********************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/Reference.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    throwUnimplemented = function (functionName) {
        return function () {
            throw new Error('Reference.' + functionName + '() :: Not implemented');
        };
    };

/**
 * Interface for references to extend to allow instanceof checking
 *
 * @constructor
 */
function Reference() {
    throw new Error('Reference is abstract, no need to instantiate it');
}

_.extend(Reference.prototype, {
    /**
     * Coerces the value from this reference and the specified one to strings,
     * concatenates them together and then assigns the result back to this reference.
     *
     * Used by the `.=` operator
     *
     * @param {Value} rightValue
     */
    concatWith: function (rightValue) {
        var reference = this;

        reference.setValue(reference.getValue().concat(rightValue));
    },

    /**
     * Subtracts the specified value from the value from this reference
     * and then assigns the result back to this reference
     *
     * Used by the `-=` operator
     *
     * @param {Value} rightValue
     */
    decrementBy: function (rightValue) {
        var reference = this;

        reference.setValue(reference.getValue().subtract(rightValue));
    },

    /**
     * Divides the value from this reference by the specified value
     * and then assigns the result back to this reference
     *
     * Used by the `/=` operator
     *
     * @param {Value} rightValue
     */
    divideBy: function (rightValue) {
        var reference = this;

        reference.setValue(reference.getValue().divide(rightValue));
    },

    /**
     * Formats the reference (which may not be defined) for display in stack traces etc.
     *
     * @returns {string}
     */
    formatAsString: function () {
        var reference = this;

        return reference.isDefined() ?
            reference.getValue().formatAsString() :
            'NULL';
    },

    /**
     * Fetches the value of this reference when it is being assigned to a variable or another reference.
     * This is used to implement the copy-on-assignment behaviour of PHP arrays
     *
     * @returns {Value}
     */
    getForAssignment: throwUnimplemented('getForAssignment'),

    /**
     * Fetches an instance property of this reference's value (assuming it contains an object) by its name
     *
     * @param {string} name
     * @returns {PropertyReference}
     */
    getInstancePropertyByName: function (name) {
        return this.getValue().getInstancePropertyByName(name);
    },

    /**
     * Fetches the native value of the PHP value being referred to
     *
     * @returns {*}
     */
    getNative: function () {
        return this.getValue().getNative();
    },

    /**
     * Fetches this reference
     *
     * @returns {Reference}
     */
    getReference: function () {
        return this;
    },

    /**
     * Fetches the value this reference stores, if any
     *
     * @returns {Value|null}
     */
    getValue: throwUnimplemented('getValue'),

    /**
     * Returns this reference's value if defined, NULL otherwise.
     * No notice/warning will be raised if the reference has no value defined.
     *
     * @return {Value}
     */
    getValueOrNull: function () {
        var reference = this;

        return reference.isDefined() ?
            reference.getValue() :
            reference.valueFactory.createNull();
    },

    /**
     * Adds the specified value to the value from this reference
     * and then assigns the result back to this reference
     *
     * Used by the `+=` operator
     *
     * @param {Value} rightValue
     */
    incrementBy: function (rightValue) {
        var reference = this;

        reference.setValue(reference.getValue().add(rightValue));
    },

    /**
     * Determines whether this reference is defined
     *
     * @returns {boolean}
     */
    isDefined: throwUnimplemented('isDefined'),

    /**
     * Determines whether the reference is classed as "empty" or not
     *
     * @returns {boolean}
     */
    isEmpty: throwUnimplemented('isEmpty'),

    /**
     * Determines whether the reference is classed as "set" or not
     *
     * @returns {boolean}
     */
    isSet: throwUnimplemented('isSet'),

    /**
     * Multiplies the specified value by the value from this reference
     * and then assigns the result back to this reference
     *
     * Used by the `*=` operator
     *
     * @param {Value} rightValue
     */
    multiplyBy: function (rightValue) {
        var reference = this;

        reference.setValue(reference.getValue().multiply(rightValue));
    },

    /**
     * Decrements the stored value, returning its original value
     *
     * @returns {Value}
     */
    postDecrement: function () {
        var reference = this,
            originalValue = reference.getValue(),
            decrementedValue = originalValue.decrement();

        reference.setValue(decrementedValue);

        return originalValue;
    },

    /**
     * Increments the stored value, returning its original value
     *
     * @returns {Value}
     */
    postIncrement: function () {
        var reference = this,
            originalValue = reference.getValue(),
            incrementedValue = originalValue.increment();

        reference.setValue(incrementedValue);

        return originalValue;
    },

    /**
     * Decrements the stored value, returning its new value
     *
     * @returns {Value}
     */
    preDecrement: function () {
        var reference = this,
            decrementedValue = reference.getValue().decrement();

        reference.setValue(decrementedValue);

        return decrementedValue;
    },

    /**
     * Increments the stored value, returning its new value
     *
     * @returns {Value}
     */
    preIncrement: function () {
        var reference = this,
            incrementedValue = reference.getValue().increment();

        reference.setValue(incrementedValue);

        return incrementedValue;
    },

    /**
     * Sets the value of this reference. If it was already assigned a value it will be overwritten,
     * otherwise if it was already assigned a sub-reference then that reference will be assigned the value
     *
     * @param {Value} value
     * @returns {Value} Returns the value that was set
     */
    setValue: throwUnimplemented('setValue')
});

module.exports = Reference;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/ReferenceSlot.js":
/*!*************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/ReferenceSlot.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js");

/**
 * Stores a value that may be referred to by multiple variables or references
 *
 * @param {ValueFactory} valueFactory
 * @constructor
 */
function ReferenceSlot(valueFactory) {
    /**
     * Implicitly define this slot with a value of NULL
     *
     * @type {Value}
     */
    this.value = valueFactory.createNull();
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

util.inherits(ReferenceSlot, Reference);

_.extend(ReferenceSlot.prototype, {
    /**
     * {@inheritdoc}
     */
    getForAssignment: function () {
        return this.getValue();
    },

    /**
     * {@inheritdoc}
     */
    getValue: function () {
        return this.value;
    },

    /**
     * {@inheritdoc}
     */
    isDefined: function () {
        return true;
    },

    /**
     * {@inheritdoc}
     */
    setValue: function (value) {
        this.value = value;

        return value;
    }
});

module.exports = ReferenceSlot;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/StaticProperty.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/StaticProperty.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    PHPError = phpCommon.PHPError,
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js"),
    ReferenceSlot = __webpack_require__(/*! ./ReferenceSlot */ "./node_modules/phpcore/src/Reference/ReferenceSlot.js"),

    CANNOT_UNSET_STATIC_PROPERTY = 'core.cannot_unset_static_property';

/**
 * @param {ValueFactory} valueFactory
 * @param {CallStack} callStack
 * @param {Class} classObject
 * @param {string} name
 * @param {string} visibility "private", "protected" or "public"
 * @param {Value} value
 * @constructor
 */
function StaticPropertyReference(
    valueFactory,
    callStack,
    classObject,
    name,
    visibility,
    value
) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {Class}
     */
    this.classObject = classObject;
    /**
     * @type {string}
     */
    this.name = name;
    /**
     * @type {Reference|null}
     */
    this.reference = null;
    /**
     * @type {Value}
     */
    this.value = value;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
    /**
     * @type {string}
     */
    this.visibility = visibility;
}

util.inherits(StaticPropertyReference, Reference);

_.extend(StaticPropertyReference.prototype, {
    getName: function () {
        return this.name;
    },

    /**
     * Fetches a reference to this property's value
     *
     * @returns {Reference}
     */
    getReference: function () {
        var property = this;

        if (property.reference) {
            // This property already refers to something else, so return its target
            return property.reference;
        }

        // Implicitly define a "slot" to contain this property's value
        property.reference = new ReferenceSlot(property.valueFactory);

        if (property.value) {
            property.reference.setValue(property.value);
            property.value = null; // This property now has a reference (to the slot) and not a value
        }

        return property.reference;
    },

    getValue: function () {
        var property = this;

        return property.value ? property.value : property.reference.getValue();
    },

    getVisibility: function () {
        return this.visibility;
    },

    /**
     * Determines whether this property is defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        return true;
    },

    /**
     * Determines whether this class property is "empty" or not
     *
     * @returns {boolean}
     */
    isEmpty: function () {
        return this.getValue().isEmpty();
    },

    isReference: function () {
        return !!this.reference;
    },

    /**
     * Determines whether this class property is "set" (assigned a non-NULL value) or not
     *
     * @returns {boolean}
     */
    isSet: function () {
        return this.getValue().isSet();
    },

    setReference: function (reference) {
        var property = this;

        property.reference = reference;
        property.value = null;
    },

    setValue: function (value) {
        var property = this;

        if (property.reference) {
            property.reference.setValue(value);
        } else {
            property.value = value.getForAssignment();
        }
    },

    /**
     * Static properties cannot be unset, so this always raises an error
     *
     * @throws {PHPFatalError}
     */
    unset: function () {
        var property = this;

        property.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_UNSET_STATIC_PROPERTY, {
            className: property.classObject.getName(),
            propertyName: property.name
        });
    }
});

module.exports = StaticPropertyReference;


/***/ }),

/***/ "./node_modules/phpcore/src/Reference/UndeclaredStaticProperty.js":
/*!************************************************************************!*\
  !*** ./node_modules/phpcore/src/Reference/UndeclaredStaticProperty.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    PHPError = phpCommon.PHPError,
    Reference = __webpack_require__(/*! ./Reference */ "./node_modules/phpcore/src/Reference/Reference.js"),

    UNDECLARED_STATIC_PROPERTY = 'core.undeclared_static_property',

    throwUndeclaredStaticPropertyAccessFatalError = function (reference) {
        reference.callStack.raiseTranslatedError(PHPError.E_ERROR, UNDECLARED_STATIC_PROPERTY, {
            className: reference.classObject.name,
            propertyName: reference.name
        });
    };

/**
 * @param {ValueFactory} valueFactory
 * @param {CallStack} callStack
 * @param {Class} classObject
 * @param {string} name Name of the static property
 * @constructor
 */
function UndeclaredStaticPropertyReference(valueFactory, callStack, classObject, name) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {Class}
     */
    this.classObject = classObject;
    /**
     * @type {string}
     */
    this.name = name;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
}

util.inherits(UndeclaredStaticPropertyReference, Reference);

_.extend(UndeclaredStaticPropertyReference.prototype, {
    /**
     * Undeclared properties cannot be accessed, only checked for empty or set state
     *
     * @throws (PHPFatalError}
     */
    getReference: function () {
        throwUndeclaredStaticPropertyAccessFatalError(this);
    },

    /**
     * Undeclared properties cannot be accessed, only checked for empty or set state
     *
     * @throws (PHPFatalError}
     */
    getValue: function () {
        throwUndeclaredStaticPropertyAccessFatalError(this);
    },

    /**
     * Determines whether this reference is defined
     *
     * @returns {boolean}
     */
    isDefined: function () {
        return false;
    },

    /**
     * Undeclared properties are classed as empty
     *
     * @returns {boolean}
     */
    isEmpty: function () {
        return true;
    },

    /**
     * Undeclared properties are classed as unset
     *
     * @returns {boolean}
     */
    isSet: function () {
        return false;
    },

    /**
     * Undeclared properties cannot be accessed, only checked for empty or set state
     *
     * @throws (PHPFatalError}
     */
    setValue: function () {
        throwUndeclaredStaticPropertyAccessFatalError(this);
    }
});

module.exports = UndeclaredStaticPropertyReference;


/***/ }),

/***/ "./node_modules/phpcore/src/ReferenceFactory.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcore/src/ReferenceFactory.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    /**
     * @param {class} AccessorReference
     * @param {class} NullReference
     * @param {ValueFactory} valueFactory
     * @constructor
     */
    function ReferenceFactory(
        AccessorReference,
        NullReference,
        valueFactory
    ) {
        /**
         * @type {class}
         */
        this.AccessorReference = AccessorReference;
        /**
         * @type {class}
         */
        this.NullReference = NullReference;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(ReferenceFactory.prototype, {
        /**
         * Creates an AccessorReference
         *
         * @param {function} valueGetter
         * @param {function} valueSetter
         * @returns {AccessorReference}
         */
        createAccessor: function (valueGetter, valueSetter) {
            var factory = this;

            return new factory.AccessorReference(factory.valueFactory, valueGetter, valueSetter);
        },

        /**
         * Creates a NullReference
         *
         * @returns {NullReference}
         */
        createNull: function () {
            var factory = this;

            return new factory.NullReference(factory.valueFactory);
        }
    });

    return ReferenceFactory;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Runtime.js":
/*!*********************************************!*\
  !*** ./node_modules/phpcore/src/Runtime.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! ./PHPState */ "./node_modules/phpcore/src/PHPState.js"),
    __webpack_require__(/*! ./Stream */ "./node_modules/phpcore/src/Stream.js")
], function (
    _,
    PHPState,
    Stream
) {
    var hasOwn = {}.hasOwnProperty;

    /**
     * PHPCore API encapsulator.
     *
     * @param {class} Environment
     * @param {class} Engine
     * @param {class} PHPState
     * @param {object} phpCommon
     * @param {GlobalStackHooker} globalStackHooker
     * @param {Resumable|null} pausable
     * @param {string} mode
     * @constructor
     */
    function Runtime(
        Environment,
        Engine,
        PHPState,
        phpCommon,
        globalStackHooker,
        pausable,
        mode
    ) {
        // Check the mode given is valid
        if (mode !== 'async' && mode !== 'psync' && mode !== 'sync') {
            throw new Error('Invalid mode "' + mode + '" given - must be one of "async", "psync" or "sync"');
        }

        // For async mode we require the Pausable library to be available
        if (mode === 'async' && !pausable) {
            throw new Error('Pausable library must be provided for async mode');
        }

        /**
         * @type {{classes: {}, constantGroups: Array, functionGroups: Array}}
         */
        this.builtins = {
            bindingGroups: [],
            classGroups: [],
            classes: {},
            constantGroups: [],
            defaultINIGroups: [],
            functionGroups: [],
            translationCatalogues: []
        };
        /**
         * @type {class}
         */
        this.Engine = Engine;
        /**
         * @type {class}
         */
        this.Environment = Environment;
        /**
         * @type {GlobalStackHooker}
         */
        this.globalStackHooker = globalStackHooker;
        /**
         * @type {string} One of: "async", "psync" or "sync"
         */
        this.mode = mode;
        /**
         * @type {Function[]}
         */
        this.optionGroups = [];
        /**
         * @type {Resumable|null}
         */
        this.pausable = pausable;
        /**
         * @type {Object}
         */
        this.phpCommon = phpCommon;
        /**
         * @type {class}
         */
        this.PHPState = PHPState;
    }

    _.extend(Runtime.prototype, {
        /**
         * Creates a factory function that can be called to create
         * a new Engine instance using this runtime's context.
         *
         * @param {Function} wrapper
         * @returns {Function}
         */
        compile: function (wrapper) {
            var runtime = this,
                mode = runtime.mode,
                pausable = runtime.pausable,
                phpCommon = runtime.phpCommon;

            /**
             * Extends an existing option set with a new set of options,
             * with special handling for the "path" option as once that option
             * has been set, its value cannot be overridden. This is because
             * the include transport configured may set a path on the returned
             * module factory (via .using(...)) but that would otherwise
             * be overridden by the default path provided by Loader (where the
             * default path is just a normalised version of the requested path,
             * rather than a resolved real path)
             *
             * @param {Object|null} existingOptions
             * @param {Object|null} newOptions
             * @return {Object}
             */
            function extendOptions(existingOptions, newOptions) {
                if (
                    existingOptions &&
                    newOptions &&
                    hasOwn.call(existingOptions, 'path') &&
                    hasOwn.call(newOptions, 'path')
                ) {
                    newOptions = _.extend({}, newOptions);
                    delete newOptions.path;
                }

                return _.extend({}, existingOptions, newOptions);
            }

            /**
             * Creates a new Engine instance using this runtime's context.
             *
             * @param {object} options
             * @param {Environment|null} environment
             * @param {Scope|null} topLevelScope
             * @returns {Engine}
             */
            function factory(options, environment, topLevelScope) {
                if (environment) {
                    options = _.extend({}, environment.getOptions(), options);
                } else {
                    environment = runtime.createEnvironment(options);
                    options = environment.getOptions();
                }

                return new runtime.Engine(
                    environment,
                    topLevelScope || null,
                    phpCommon,
                    options,
                    wrapper,
                    pausable,
                    mode
                );
            }

            /**
             * Creates a function to be exposed as .using(...) on the module factory,
             * allowing the new module factory returned when .using(...) is called
             * to itself expose a .using(...) method recursively
             *
             * @param {Function} factory
             * @return {Function}
             */
            function createSubFactory(factory) {
                /**
                 * Creates a new factory function with some optional default options,
                 * environment and top-level Scope
                 *
                 * @param {object=} defaultOptions
                 * @param {Environment=} defaultEnvironment
                 * @param {Scope=} defaultTopLevelScope
                 * @returns {Function}
                 */
                return function subFactory(defaultOptions, defaultEnvironment, defaultTopLevelScope) {
                    /**
                     * A proxying factory function that applies these defaults
                     * and then forwards onto the original factory function
                     *
                     * @param {object=} options
                     * @param {Environment=} environment
                     * @param {Scope=} topLevelScope
                     * @returns {Engine}
                     */
                    function proxy(options, environment, topLevelScope) {
                        options = extendOptions(defaultOptions, options);
                        environment = environment || defaultEnvironment;
                        topLevelScope = topLevelScope || defaultTopLevelScope;

                        return factory(options, environment, topLevelScope);
                    }

                    /**
                     * Creates a new factory function with some optional default options,
                     * environment and top-level Scope
                     */
                    proxy.using = createSubFactory(proxy);

                    return proxy;
                };
            }

            /**
             * Creates a new factory function with some optional default options,
             * environment and top-level Scope
             */
            factory.using = createSubFactory(factory);

            return factory;
        },

        /**
         * Sets one or more configuration options
         *
         * @param {object} options
         */
        configure: function (options) {
            // Configuration options are likely to be used by other option groups/bindings etc.,
            // so set those first
            this.optionGroups.unshift(function () {
                return options;
            });
        },

        /**
         * Creates a new Environment instance, useful for sharing a runtime
         * context between modules.
         * A factory function returned from `.compile(...)` may be called
         * passing an Environment instance in order to reuse it, eg.
         * to make classes, functions and global variables from one module
         * available in another outside the use of includes.
         *
         * @param {object} options
         * @param {Array=} addons
         * @returns {Environment}
         */
        createEnvironment: function (options, addons) {
            var runtime = this,
                allBuiltins = _.extend({}, runtime.builtins),
                allOptionGroups = runtime.optionGroups,
                stdin = new Stream(),
                stdout = new Stream(),
                stderr = new Stream(),
                state;

            _.each(addons, function (addon) {
                if (typeof addon === 'function') {
                    // Allow an addon to be defined as a function, to allow testing
                    addon = addon();
                }

                allBuiltins.translationCatalogues = allBuiltins.translationCatalogues.concat(addon.translationCatalogues || []);
                allBuiltins.functionGroups = allBuiltins.functionGroups.concat(addon.functionGroups || []);
                allBuiltins.classGroups = allBuiltins.classGroups.concat(addon.classGroups || []);
                allBuiltins.classes = _.extend({}, allBuiltins.classes, addon.classes);
                allBuiltins.constantGroups = allBuiltins.constantGroups.concat(addon.constantGroups || []);
                allBuiltins.defaultINIGroups = allBuiltins.defaultINIGroups.concat(addon.defaultINIGroups || []);
                allOptionGroups = allOptionGroups.concat(addon.optionGroups || []);
                allBuiltins.bindingGroups = allBuiltins.bindingGroups.concat(addon.bindingGroups || []);
            });

            state = new runtime.PHPState(
                runtime,
                runtime.globalStackHooker,
                allBuiltins,
                stdin,
                stdout,
                stderr,
                runtime.pausable,
                runtime.mode,
                allOptionGroups,
                options
            );

            return new runtime.Environment(state);
        },

        /**
         * Installs a new set of builtins, to be available to all modules
         * compiled and executed by this runtime.
         * All fields are optional - for example, this method can be used
         * to only define a new class without also defining any constants or functions.
         *
         * @param {Function|{classes: {}, constantGroups: Array, functionGroups: Array}} newBuiltins
         */
        install: function (newBuiltins) {
            var builtins = this.builtins;

            if (typeof newBuiltins === 'function') {
                // Allow an addon to be defined as a function, to allow testing
                newBuiltins = newBuiltins();
            }

            [].push.apply(builtins.translationCatalogues, newBuiltins.translationCatalogues);
            [].push.apply(builtins.functionGroups, newBuiltins.functionGroups);
            [].push.apply(builtins.classGroups, newBuiltins.classGroups);
            _.extend(builtins.classes, newBuiltins.classes);
            [].push.apply(builtins.constantGroups, newBuiltins.constantGroups);
            [].push.apply(builtins.defaultINIGroups, newBuiltins.defaultINIGroups);
            [].push.apply(this.optionGroups, newBuiltins.optionGroups);
            [].push.apply(builtins.bindingGroups, newBuiltins.bindingGroups);
        }
    });

    return Runtime;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/RuntimeFactory.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/RuntimeFactory.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    /**
     * Fetches either the sync-mode class (for sync & psync modes) or async-mode class
     *
     * @param {Wrapper} wrapper
     * @param {Resumable=} pausable
     * @returns {Function}
     */
    unwrap = function (wrapper, pausable) {
        return pausable ? wrapper.async(pausable) : wrapper.sync();
    };

/**
 * Instantiates the shared Runtime
 *
 * @param {class} Environment
 * @param {class} Engine
 * @param {Wrapper} PHPStateWrapper
 * @param {Wrapper} RuntimeWrapper
 * @param {PHPCommon} phpCommon
 * @param {GlobalStackHooker} globalStackHooker
 * @constructor
 */
function RuntimeFactory(
    Environment,
    Engine,
    PHPStateWrapper,
    RuntimeWrapper,
    phpCommon,
    globalStackHooker
) {
    /**
     * @type {class}
     */
    this.Engine = Engine;
    /**
     * @type {class}
     */
    this.Environment = Environment;
    /**
     * @type {GlobalStackHooker}
     */
    this.globalStackHooker = globalStackHooker;
    /**
     * @type {PHPCommon}
     */
    this.phpCommon = phpCommon;
    /**
     * @type {Wrapper}
     */
    this.PHPStateWrapper = PHPStateWrapper;
    /**
     * @type {Wrapper}
     */
    this.RuntimeWrapper = RuntimeWrapper;
}

_.extend(RuntimeFactory.prototype, {
    /**
     * Creates a new Runtime instance
     *
     * @param {string} mode
     * @param {Resumable=} pausable
     * @returns {Runtime}
     */
    create: function (mode, pausable) {
        var factory = this,
            PHPState = unwrap(factory.PHPStateWrapper, pausable),
            Runtime = unwrap(factory.RuntimeWrapper, pausable);

        return new Runtime(
            factory.Environment,
            factory.Engine,
            PHPState,
            factory.phpCommon,
            factory.globalStackHooker,
            pausable || null,
            mode
        );
    }
});

module.exports = RuntimeFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Scope.js":
/*!*******************************************!*\
  !*** ./node_modules/phpcore/src/Scope.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js")
], function (
    _,
    phpCommon
) {
    var hasOwn = {}.hasOwnProperty,
        IS_STATIC = 'isStatic',
        PHPError = phpCommon.PHPError,

        CANNOT_ACCESS_WHEN_NO_ACTIVE_CLASS = 'core.cannot_access_when_no_active_class',
        NO_PARENT_CLASS = 'core.no_parent_class',
        SCOPED_ERROR = 'core.scoped_error';

    /**
     * @param {CallStack} callStack
     * @param {Translator} translator
     * @param {Scope} globalScope
     * @param {SuperGlobalScope} superGlobalScope
     * @param {ClosureFactory} closureFactory
     * @param {FunctionSpecFactory} functionSpecFactory
     * @param {ValueFactory} valueFactory
     * @param {VariableFactory} variableFactory
     * @param {ReferenceFactory} referenceFactory
     * @param {Class|null} currentClass
     * @param {Function|null} currentFunction
     * @param {ObjectValue|null} thisObject
     * @constructor
     */
    function Scope(
        callStack,
        translator,
        globalScope,
        superGlobalScope,
        closureFactory,
        functionSpecFactory,
        valueFactory,
        variableFactory,
        referenceFactory,
        currentClass,
        currentFunction,
        thisObject
    ) {
        var thisObjectVariable = variableFactory.createVariable('this');

        this.callStack = callStack;
        this.closureFactory = closureFactory;
        /**
         * @type {Class|null}
         */
        this.currentClass = currentClass;
        this.currentFunction = currentFunction;
        this.errorsSuppressed = false;
        this.functionSpecFactory = functionSpecFactory;
        this.globalScope = globalScope || this;
        this.referenceFactory = referenceFactory;
        this.superGlobalScope = superGlobalScope;
        this.thisObject = currentFunction && currentFunction[IS_STATIC] ? null : thisObject;
        /**
         * @type {Translator}
         */
        this.translator = translator;
        this.valueFactory = valueFactory;
        this.variableFactory = variableFactory;
        this.variables = {
            'this': thisObjectVariable
        };

        if (thisObject && (!currentFunction || !currentFunction[IS_STATIC])) {
            thisObjectVariable.setValue(thisObject);
        }
    }

    _.extend(Scope.prototype, {
        /**
         * Creates a closure, either static (with no `$this` object bound) or non-static
         *
         * @param {NamespaceScope} namespaceScope
         * @param {Function} func
         * @param {Array=} parametersSpecData
         * @param {boolean=} isStatic
         * @param {number|null=} lineNumber
         * @returns {Closure}
         */
        createClosure: function (namespaceScope, func, parametersSpecData, isStatic, lineNumber) {
            var functionSpec,
                scope = this,
                thisObject = null;

            // Fetch the `$this` object to bind to the closure from the current scope,
            // if the closure is a normal (non-static) one. Otherwise, if the closure is static
            // then it will have no `$this` object bound to it
            if (!isStatic) {
                thisObject = scope.thisObject;
            }

            functionSpec = scope.functionSpecFactory.createClosureSpec(
                namespaceScope,
                scope.currentClass,
                parametersSpecData || [],
                namespaceScope.getFilePath(),
                lineNumber
            );

            return scope.closureFactory.create(
                scope,
                func,
                namespaceScope,
                scope.currentClass,
                thisObject,
                functionSpec
            );
        },

        /**
         * Defines a variable with the given name in this scope. If it is already defined,
         * in this scope (not including the superglobal scope) then an error will be thrown
         *
         * @param {string} name
         * @returns {Variable}
         * @throws {Error} Throws when the variable is already defined in this scope
         */
        defineVariable: function (name) {
            var scope = this,
                variable;

            if (hasOwn.call(scope.variables, name)) {
                // Variable is already defined, just return
                throw new Error('Variable "' + name + '" is already defined in this scope');
            }

            variable = scope.variableFactory.createVariable(name);

            scope.variables[name] = variable;

            return variable;
        },

        /**
         * Defines one or more variables with the given names in this scope
         *
         * @param {string[]} names
         */
        defineVariables: function (names) {
            var scope = this;

            _.each(names, function (name) {
                scope.defineVariable(name);
            });
        },

        /**
         * Returns a hash with the values of all variables defined
         * for this scope, including all superglobals
         *
         * @returns {Object.<string, Value>}
         */
        exportVariables: function () {
            var scope = this,
                values = scope.superGlobalScope.exportVariables();

            _.forOwn(scope.variables, function (variable, variableName) {
                if (variable.isDefined()) {
                    values[variableName] = variable.getValue();
                }
            });

            return values;
        },

        /**
         * Defines a variable in the current scope with the given native value
         *
         * @param {Value|*} value
         * @param {string} name
         */
        expose: function (value, name) {
            var scope = this,
                valueFactory = scope.valueFactory;

            scope.defineVariable(name).setValue(valueFactory.coerce(value));
        },

        /**
         * Fetches the name of the current class, or an empty string if there is none
         *
         * @returns {StringValue}
         */
        getClassName: function () {
            var scope = this;

            return scope.valueFactory.createString(
                scope.currentClass ? scope.currentClass.getName() : ''
            );
        },

        /**
         * Fetches the name of the class in which this scope's function is defined
         *
         * @returns {StringValue}
         * @throws {PHPFatalError} When there is no current class scope
         */
        getClassNameOrThrow: function () {
            var scope = this;

            if (!scope.currentClass) {
                // PHP Fatal error: Uncaught Error: Cannot access self:: when no class scope is active
                scope.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_ACCESS_WHEN_NO_ACTIVE_CLASS, {
                    className: 'self'
                });
            }

            return scope.valueFactory.createString(scope.currentClass.getName());
        },

        /**
         * Fetches the current class, if any
         *
         * @returns {Class|null}
         */
        getCurrentClass: function () {
            return this.currentClass;
        },

        /**
         * Fetches the current file path, taking eval into account
         *
         * @param {string|null} filePath
         * @returns {string|null}
         */
        getFilePath: function (filePath) {
            return filePath; // Passes through unaltered: see LoadScope for where a change is made
        },

        /**
         * Fetches the current function name (used by eg. the magic __FUNCTION__ constant)
         *
         * @returns {StringValue}
         */
        getFunctionName: function () {
            var scope = this,
                functionName = '';

            if (scope.currentFunction) {
                // NB: Method functions have no special treatment here -
                //     the owning namespace and/or class will be omitted
                functionName = scope.currentFunction.functionSpec.getUnprefixedFunctionName();
            }

            return scope.valueFactory.createString(functionName);
        },

        /**
         * Fetches the current method name (used by eg. the magic __METHOD__ constant)
         *
         * Note that this differs from .getFunctionName() when the current function is a method
         *
         * @param {boolean=} isStaticCall
         * @returns {StringValue}
         */
        getMethodName: function (isStaticCall) {
            var scope = this,
                functionName = '';

            if (scope.currentFunction) {
                // NB: Methods are prefixed with namespace, class and `::`
                functionName = scope.currentFunction.functionSpec.getFunctionName(isStaticCall !== false);
            }

            return scope.valueFactory.createString(functionName);
        },

        /**
         * Fetches the name of the parent of the current class in scope
         *
         * @returns {StringValue}
         * @throws {PHPFatalError} When there is no current class scope or current class has no parent
         */
        getParentClassNameOrThrow: function () {
            var scope = this,
                superClass;

            if (!scope.currentClass) {
                // PHP Fatal error: Uncaught Error: Cannot access parent:: when no class scope is active
                scope.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_ACCESS_WHEN_NO_ACTIVE_CLASS, {
                    className: 'parent'
                });
            }

            superClass = scope.currentClass.getSuperClass();

            if (!superClass) {
                // PHP Fatal error: Uncaught Error: Cannot access parent:: when current class scope has no parent
                scope.callStack.raiseTranslatedError(PHPError.E_ERROR, NO_PARENT_CLASS);
            }

            return scope.valueFactory.createString(superClass.getName());
        },

        /**
         * Fetches the name of the current static class scope, which may be different
         * from the class in which its function is defined (eg. after a forward_static_call(...))
         *
         * @returns {StringValue}
         * @throws {PHPFatalError} When there is no static class scope
         */
        getStaticClassNameOrThrow: function () {
            var scope = this,
                staticClass = scope.callStack.getStaticClass();

            if (!staticClass) {
                // PHP Fatal error: Uncaught Error: Cannot access static:: when no class scope is active
                scope.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_ACCESS_WHEN_NO_ACTIVE_CLASS, {
                    className: 'static'
                });
            }

            return scope.valueFactory.createString(staticClass.getName());
        },

        /**
         * Fetches the current object (the value of $this) if any
         *
         * @returns {ObjectValue|null}
         */
        getThisObject: function () {
            return this.thisObject;
        },

        /**
         * Fetches the current function or method name as used in stack traces
         *
         * Note that this differs from .getFunctionName() and .getMethodName()
         *
         * @returns {string}
         */
        getTraceFrameName: function () {
            var scope = this,
                functionName = '';

            if (scope.currentFunction) {
                // NB: Methods are prefixed with namespace, class and `::`
                functionName = scope.currentFunction.functionSpec.getFunctionTraceFrameName(scope.isStatic());
            }

            return functionName;
        },

        /**
         * Fetches a variable for the current or super global scope,
         * implicitly defining it if needed
         *
         * @param {string} name
         * @returns {Variable}
         */
        getVariable: function (name) {
            var scope = this,
                variable;

            // Look in the current scope for the variable first
            if (hasOwn.call(scope.variables, name)) {
                return scope.variables[name];
            }

            // If not found, look in the super global scope
            variable = scope.superGlobalScope.getVariable(name);

            if (!variable) {
                // Variable is not local or a super-global: implicitly define it
                variable = scope.variableFactory.createVariable(name);
                scope.variables[name] = variable;

                if (scope.errorsSuppressed) {
                    variable.setValue(scope.valueFactory.createNull());
                }
            }

            return variable;
        },

        /**
         * Determines whether this scope defines the specified variable or not
         * (not including the superglobal scope)
         *
         * @param {string} name
         * @returns {boolean}
         */
        hasVariable: function (name) {
            return hasOwn.call(this.variables, name);
        },

        /**
         * Imports a global variable into this scope by defining the variable
         * in this scope and setting its reference to point to the global one.
         *
         * @param {string} variableName
         */
        importGlobal: function (variableName) {
            var scope = this;

            if (scope.globalScope === scope) {
                // Nothing to do; we're trying to import a global into the global scope
                return;
            }

            scope.getVariable(variableName).setReference(
                scope.globalScope.getVariable(variableName).getReference()
            );
        },

        /**
         * Imports a static variable into this scope by defining the variable
         * in this scope and setting its reference to point to the "static" one,
         * stored against the current function/method. The first time the variable
         * is declared, it will be assigned the initial value (if any).
         *
         * @param {string} variableName
         * @param {Value|null} initialValue
         */
        importStatic: function (variableName, initialValue) {
            var scope = this,
                staticVariables,
                staticVariable;

            if (scope.currentFunction) {
                if (scope.currentFunction.staticVariables) {
                    staticVariables = scope.currentFunction.staticVariables;
                } else {
                    staticVariables = {};
                    scope.currentFunction.staticVariables = staticVariables;
                }

                if (!hasOwn.call(staticVariables, variableName)) {
                    staticVariables[variableName] = scope.variableFactory.createVariable(variableName);

                    if (initialValue) {
                        // Initialiser is optional
                        staticVariables[variableName].setValue(initialValue);
                    }
                }

                staticVariable = staticVariables[variableName];

                // Define a variable in the current scope that is a reference
                // to the static variable stored against either the current function or the global scope if none
                scope.getVariable(variableName).setReference(staticVariable.getReference());
            } else {
                scope.getVariable(variableName).setValue(initialValue);
            }
        },

        /**
         * Whether this call scope is in a static context or not
         *
         * @returns {boolean}
         */
        isStatic: function () {
            return !this.thisObject;
        },

        /**
         * Raises a catchable Error or a notice/warning with the specified level, message translation key and variables,
         * scoped to the current function scope
         *
         * @param {string} level One of the PHPError.E_* constants, eg. `PHPError.E_WARNING`
         * @param {string} translationKey
         * @param {Object.<string, string>=} placeholderVariables
         * @param {string=} errorClass
         * @param {boolean=} reportsOwnContext Whether the error handles reporting its own file/line context
         * @param {string=} filePath
         * @param {number=} lineNumber
         * @throws {ObjectValue} Throws an ObjectValue-wrapped Throwable if not a notice or warning
         */
        raiseScopedTranslatedError: function (
            level,
            translationKey,
            placeholderVariables,
            errorClass,
            reportsOwnContext,
            filePath,
            lineNumber
        ) {
            var scope = this,
                message = scope.translator.translate(SCOPED_ERROR, {
                    function: scope.getFunctionName().getNative(),
                    message: scope.translator.translate(translationKey, placeholderVariables)
                });

            if (level === PHPError.E_ERROR) {
                // Non-warning/non-notice errors need to actually stop execution
                // NB: The Error class' constructor will fetch file and line number info
                throw scope.valueFactory.createErrorObject(
                    errorClass || 'Error',
                    message,
                    null,
                    null,
                    filePath,
                    lineNumber,
                    reportsOwnContext
                );
            }

            scope.callStack.raiseError(level, message, errorClass, reportsOwnContext);
        },

        /**
         * Suppresses errors for this and any descendant scopes
         */
        suppressErrors: function () {
            this.errorsSuppressed = true;
        },

        /**
         * Suppresses errors for only this and not any descendant scopes
         */
        suppressOwnErrors: function () {
            this.ownErrorsSuppressed = true;
        },

        /**
         * Determines whether errors have been suppressed for this and any descendant scopes
         *
         * @returns {boolean}
         */
        suppressesErrors: function () {
            return this.errorsSuppressed;
        },

        /**
         * Determines whether errors have been suppressed for this but not any descendant scopes
         *
         * @returns {boolean}
         */
        suppressesOwnErrors: function () {
            return this.ownErrorsSuppressed;
        },

        /**
         * Unsuppresses errors for this and any descendant scopes
         */
        unsuppressErrors: function () {
            this.errorsSuppressed = false;
        },

        /**
         * Unsuppresses errors for this but not any descendant scopes
         */
        unsuppressOwnErrors: function () {
            this.ownErrorsSuppressed = false;
        }
    });

    return Scope;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/ScopeFactory.js":
/*!**************************************************!*\
  !*** ./node_modules/phpcore/src/ScopeFactory.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * @param {class} LoadScope
 * @param {class} Scope
 * @param {class} NamespaceScope
 * @param {CallStack} callStack
 * @param {Translator} translator
 * @param {SuperGlobalScope} superGlobalScope
 * @param {FunctionSpecFactory} functionSpecFactory
 * @param {ValueFactory} valueFactory
 * @param {VariableFactory} variableFactory
 * @param {ReferenceFactory} referenceFactory
 * @constructor
 */
function ScopeFactory(
    LoadScope,
    Scope,
    NamespaceScope,
    callStack,
    translator,
    superGlobalScope,
    functionSpecFactory,
    valueFactory,
    variableFactory,
    referenceFactory
) {
    /**
     * @type {CallStack}
     */
    this.callStack = callStack;
    /**
     * @type {ClosureFactory}
     */
    this.closureFactory = null;
    /**
     * @type {class}
     */
    this.LoadScope = LoadScope;
    /**
     * @type {FunctionSpecFactory}
     */
    this.functionSpecFactory = functionSpecFactory;
    /**
     * @type {Scope}
     */
    this.globalScope = null;
    /**
     * @type {class}
     */
    this.NamespaceScope = NamespaceScope;
    /**
     * @type {ReferenceFactory}
     */
    this.referenceFactory = referenceFactory;
    /**
     * @type {class}
     */
    this.Scope = Scope;
    /**
     * @type {SuperGlobalScope}
     */
    this.superGlobalScope = superGlobalScope;
    /**
     * @type {Translator}
     */
    this.translator = translator;
    /**
     * @type {ValueFactory}
     */
    this.valueFactory = valueFactory;
    /**
     * @type {VariableFactory}
     */
    this.variableFactory = variableFactory;
}

_.extend(ScopeFactory.prototype, {
    /**
     * Creates a new Scope
     *
     * @param {Class|null=} currentClass
     * @param {Function|null=} currentFunction
     * @param {ObjectValue|null=} thisObject
     * @returns {Scope}
     */
    create: function (currentClass, currentFunction, thisObject) {
        var factory = this;

        return new factory.Scope(
            factory.callStack,
            factory.translator,
            factory.globalScope,
            factory.superGlobalScope,
            factory.closureFactory,
            factory.functionSpecFactory,
            factory.valueFactory,
            factory.variableFactory,
            factory.referenceFactory,
            currentClass || null,
            currentFunction || null,
            thisObject || null
        );
    },

    /**
     * Creates a new LoadScope
     *
     * @param {Scope} effectiveScope
     * @param {string} callerFilePath
     * @param {string} type The type of load, eg. `eval` or `include`
     * @returns {LoadScope}
     */
    createLoadScope: function (effectiveScope, callerFilePath, type) {
        var factory = this;

        return new factory.LoadScope(factory.valueFactory, effectiveScope, callerFilePath, type);
    },

    /**
     * Creates a new NamespaceScope
     *
     * @param {Namespace} namespace
     * @param {Namespace} globalNamespace
     * @param {Module} module
     * @returns {NamespaceScope}
     */
    createNamespaceScope: function (namespace, globalNamespace, module) {
        var factory = this;

        return new factory.NamespaceScope(globalNamespace, factory.valueFactory, factory.callStack, module, namespace);
    },

    /**
     * Sets the ClosureFactory service to pass to Scopes created by this factory
     *
     * @param {ClosureFactory} closureFactory
     */
    setClosureFactory: function (closureFactory) {
        this.closureFactory = closureFactory;
    },

    /**
     * Sets the global Scope to pass to Scopes created by this factory
     *
     * @param {Scope} globalScope
     */
    setGlobalScope: function (globalScope) {
        this.globalScope = globalScope;
    }
});

module.exports = ScopeFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Stream.js":
/*!********************************************!*\
  !*** ./node_modules/phpcore/src/Stream.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

function Stream() {
    EventEmitter.call(this);

    this.data = '';
}

util.inherits(Stream, EventEmitter);

_.extend(Stream.prototype, {
    read: function (length) {
        var data,
            stream = this;

        if (!length && length !== 0) {
            data = stream.data;
            stream.data = '';
        } else {
            data = stream.data.substr(0, length);
            stream.data = stream.data.substr(length);
        }

        return data;
    },

    readAll: function () {
        var stream = this;

        return stream.read(stream.data.length);
    },

    write: function (data) {
        var stream = this;

        stream.data += data;
        stream.emit('data', data);
    }
});

module.exports = Stream;


/***/ }),

/***/ "./node_modules/phpcore/src/SuperGlobalScope.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcore/src/SuperGlobalScope.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! ./Variable */ "./node_modules/phpcore/src/Variable.js")
], function (
    _,
    Variable
) {
    var hasOwn = {}.hasOwnProperty;

    /**
     * @param {CallStack} callStack
     * @param {ValueFactory} valueFactory
     * @constructor
     */
    function SuperGlobalScope(callStack, valueFactory) {
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
        /**
         * @type {Object.<string, Variable>}
         */
        this.variables = {};
    }

    _.extend(SuperGlobalScope.prototype, {
        /**
         * Defines a new variable in the super global scope and returns it
         *
         * @param {string} name
         * @returns {Variable}
         */
        defineVariable: function (name) {
            var scope = this,
                variable = new Variable(scope.callStack, scope.valueFactory, name);

            scope.variables[name] = variable;

            return variable;
        },

        /**
         * Returns a hash with the values of all variables defined
         * for the super global scope. The $GLOBALS superglobal is excluded
         *
         * @returns {Object.<string, Value>}
         */
        exportVariables: function () {
            var values = {};

            _.forOwn(this.variables, function (variable, variableName) {
                // Avoid infinite recursion by not attempting to export GLOBALS itself
                if (variableName === 'GLOBALS') {
                    return;
                }

                values[variableName] = variable.getValue();
            });

            return values;
        },

        /**
         * Fetches an existing variable from the super global scope
         *
         * @param {string} name
         * @returns {Variable|null}
         */
        getVariable: function (name) {
            var scope = this;

            return hasOwn.call(scope.variables, name) ? scope.variables[name] : null;
        }
    });

    return SuperGlobalScope;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Tools.js":
/*!*******************************************!*\
  !*** ./node_modules/phpcore/src/Tools.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ./Debug/DebugVariable */ "./node_modules/phpcore/src/Debug/DebugVariable.js"),
    __webpack_require__(/*! ./KeyReferencePair */ "./node_modules/phpcore/src/KeyReferencePair.js"),
    __webpack_require__(/*! ./KeyValuePair */ "./node_modules/phpcore/src/KeyValuePair.js"),
    __webpack_require__(/*! ./List */ "./node_modules/phpcore/src/List.js"),
    __webpack_require__(/*! ./Exception/LoadFailedException */ "./node_modules/phpcore/src/Exception/LoadFailedException.js")
], function (
    _,
    phpCommon,
    DebugVariable,
    KeyReferencePair,
    KeyValuePair,
    List,
    LoadFailedException
) {
    var Exception = phpCommon.Exception,
        hasOwn = {}.hasOwnProperty,

        EVAL_PATH = 'core.eval_path',
        NO_PARENT_CLASS = 'core.no_parent_class',
        UNKNOWN = 'core.unknown',

        EVAL_OPTION = 'eval',
        INCLUDE_OPTION = 'include',
        TICK_OPTION = 'tick',
        PHPError = phpCommon.PHPError;

    /**
     * @param {CallStack} callStack
     * @param {Environment} environment
     * @param {Translator} translator
     * @param {Namespace} globalNamespace
     * @param {Loader} loader
     * @param {Module} module
     * @param {Object} options
     * @param {ReferenceFactory} referenceFactory
     * @param {ScopeFactory} scopeFactory
     * @param {NamespaceScope} topLevelNamespaceScope
     * @param {Scope} topLevelScope
     * @param {ValueFactory} valueFactory
     * @constructor
     */
    function Tools(
        callStack,
        environment,
        translator,
        globalNamespace,
        loader,
        module,
        options,
        referenceFactory,
        scopeFactory,
        topLevelNamespaceScope,
        topLevelScope,
        valueFactory
    ) {
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {Environment}
         */
        this.environment = environment;
        /**
         * @type {Namespace}
         */
        this.globalNamespace = globalNamespace;
        /**
         * @type {Object.<string, boolean>}
         */
        this.includedPaths = {};
        /**
         * @type {Loader}
         */
        this.loader = loader;
        /**
         * @type {Module}
         */
        this.module = module;
        /**
         * @type {Object}
         */
        this.options = options;
        /**
         * @type {ReferenceFactory}
         * @public Referenced from transpiled code
         */
        this.referenceFactory = referenceFactory;
        /**
         * @type {ScopeFactory}
         */
        this.scopeFactory = scopeFactory;
        /**
         * @type {NamespaceScope}
         * @public Referenced from transpiled code
         */
        this.topLevelNamespaceScope = topLevelNamespaceScope;
        /**
         * @type {Scope}
         * @public Referenced from transpiled code
         */
        this.topLevelScope = topLevelScope;
        /**
         * @type {Translator}
         */
        this.translator = translator;
        /**
         * @type {ValueFactory}
         * @public Referenced from transpiled code
         */
        this.valueFactory = valueFactory;
    }

    _.extend(Tools.prototype, {
        /**
         * Creates an ObjectValue that wraps an instance of the builtin PHP Closure class
         * whose behaviour is defined by the provided function
         *
         * @param {Function} func
         * @param {Scope} scope
         * @param {NamespaceScope} namespaceScope
         * @param {Array=} parametersSpecData
         * @param {boolean=} isStatic
         * @param {number=} lineNumber
         * @returns {ObjectValue}
         */
        createClosure: function (func, scope, namespaceScope, parametersSpecData, isStatic, lineNumber) {
            var tools = this;

            return tools.valueFactory.createClosureObject(
                scope.createClosure(
                    namespaceScope,
                    func,
                    parametersSpecData || [],
                    !!isStatic,
                    lineNumber || null
                )
            );
        },

        /**
         * Creates a DebugVariable, for showing the value of a variable in the scope
         * inside Google Chrome's developer tools
         *
         * @param {Scope} scope
         * @param {string} variableName
         * @returns {DebugVariable}
         */
        createDebugVar: function (scope, variableName) {
            return new DebugVariable(scope, variableName);
        },

        /**
         * Used by transpiled PHP `new MyClass(<args>)` expressions
         *
         * @param {NamespaceScope} namespaceScope
         * @param {Value} classNameValue
         * @param {Value[]} args Arguments to pass to the constructor
         * @returns {ObjectValue}
         */
        createInstance: function (namespaceScope, classNameValue, args) {
            return classNameValue.instantiate(args, namespaceScope);
        },

        /**
         * Creates a new KeyReferencePair
         *
         * @param {Value} key
         * @param {Reference|Variable} reference
         * @returns {KeyReferencePair}
         */
        createKeyReferencePair: function (key, reference) {
            return new KeyReferencePair(key, reference);
        },

        /**
         * Creates a new KeyValuePair
         *
         * @param {Value} key
         * @param {Value} value
         * @returns {KeyValuePair}
         */
        createKeyValuePair: function (key, value) {
            return new KeyValuePair(key, value);
        },

        /**
         * Creates a new List, which is a list of references that may be assigned to
         * by assigning them an array, where each list element gets the corresponding array element
         *
         * @param {Reference[]} elements
         * @returns {List}
         */
        createList: function (elements) {
            return new List(this.valueFactory, elements);
        },

        /**
         * Creates a new NamespaceScope
         *
         * @param {Namespace} namespace
         * @returns {NamespaceScope}
         */
        createNamespaceScope: function (namespace) {
            var tools = this;

            return tools.scopeFactory.createNamespaceScope(namespace, tools.globalNamespace, tools.module);
        },

        /**
         * Evaluates the given PHP code using the configured `eval` option
         *
         * @param {string} code
         * @param {Scope} enclosingScope
         * @returns {Value}
         */
        eval: function (code, enclosingScope) {
            var evalScope,
                lineNumber,
                path,
                tools = this;

            if (!tools.options[EVAL_OPTION]) {
                throw new Exception(
                    'eval(...) :: No "eval" interpreter option is available.'
                );
            }

            path = tools.topLevelNamespaceScope.getFilePath();
            evalScope = tools.scopeFactory.createLoadScope(enclosingScope, path, 'eval');
            lineNumber = tools.callStack.getLastLine();

            if (lineNumber === null) {
                lineNumber = tools.translator.translate(UNKNOWN);
            }

            return tools.loader.load(
                'eval',
                // Use the path to the script that called eval() along with this suffix
                // as the path to the current file inside the eval
                tools.translator.translate(EVAL_PATH, {path: path, lineNumber: lineNumber}),
                tools.options,
                tools.environment,
                tools.module,
                evalScope,
                function (path, promise, parentPath, valueFactory) {
                    return tools.options[EVAL_OPTION]('<?php ' + code, path, promise, parentPath, valueFactory);
                }
            );
        },

        /**
         * Immediately exits the currently executing PHP script. This is achieved
         * by throwing a JS error that cannot be caught by any PHP-land try..catch statement.
         * If the program was run from a command-line, any exit status provided will be used
         * as the exit code for the process.
         *
         * @param {Value|null} statusValue
         * @throws {ExitValue}
         */
        exit: function (statusValue) {
            throw this.valueFactory.createExit(statusValue);
        },

        /**
         * Fetches the name of the specified class, wrapped as a StringValue
         *
         * @param {Class} classObject
         * @returns {StringValue}
         */
        getClassName: function (classObject) {
            return this.valueFactory.createString(classObject.getName());
        },

        /**
         * Fetches a human-readable string representing the path to the current script file
         *
         * @returns {string}
         */
        getNormalizedPath: function () {
            var tools = this,
                path = tools.topLevelNamespaceScope.getFilePath();

            return path !== null ? path : '(program)';
        },

        /**
         * Fetches the name of the parent of the specified class, wrapped as a StringValue
         *
         * @param {Class} classObject
         * @returns {StringValue}
         */
        getParentClassName: function (classObject) {
            var superClass = classObject.getSuperClass(),
                tools = this;

            if (!superClass) {
                // Fatal error: Uncaught Error: Cannot access parent:: when current class scope has no parent
                tools.callStack.raiseTranslatedError(PHPError.E_ERROR, NO_PARENT_CLASS);
            }

            return tools.valueFactory.createString(superClass.getName());
        },

        /**
         * Fetches the path to the current script, wrapped as a StringValue
         *
         * @returns {StringValue}
         */
        getPath: function () {
            var tools = this;

            return tools.valueFactory.createString(tools.getNormalizedPath());
        },

        /**
         * Fetches the path to the directory containing the current script, wrapped as a StringValue
         *
         * @returns {StringValue}
         */
        getPathDirectory: function () {
            var tools = this,
                path = tools.topLevelNamespaceScope.getFilePath(),
                directory = (path || '').replace(/(^|\/)[^\/]+$/, '');

            return tools.valueFactory.createString(directory || '');
        },

        /**
         * Assigns the provided variable a new array value if it is not currently defined
         * or defined with a value of NULL, then returns its current value
         *
         * @param {Reference|Variable} variable
         * @returns {Value}
         */
        implyArray: function (variable) {
            // Undefined variables and variables containing null may be implicitly converted to arrays
            if (!variable.isDefined() || variable.getValue().getType() === 'null') {
                variable.setValue(this.valueFactory.createArray([]));
            }

            return variable.getValue();
        },

        /**
         * Assigns the provided variable a new stdClass instance value if it is not currently defined
         * or defined with a value of NULL, then returns its current value
         *
         * @param {Reference|Variable} variable
         * @returns {Reference|Variable}
         */
        implyObject: function (variable) {
            // FIXME: If the given variable/reference does not have an object as its value:
            //  `PHP Warning: Creating default object from empty value`
            return variable.getValue();
        },

        /**
         * Includes the specified module if it has not been included yet.
         * If it has not already been included, the module's return value is returned,
         * otherwise boolean true will be returned.
         * Throws if no include transport has been configured.
         *
         * @param {string} includedPath
         * @param {Scope} includeScope
         * @returns {Value}
         */
        includeOnce: function (includedPath, includeScope) {
            var tools = this;

            if (hasOwn.call(tools.includedPaths, includedPath)) {
                return tools.valueFactory.createBoolean(true);
            }

            tools.includedPaths[includedPath] = true;

            return tools.include(includedPath, includeScope);
        },

        /**
         * Includes the specified module, returning its return value.
         * Throws if no include transport has been configured.
         *
         * @param {string} includedPath
         * @param {Scope} enclosingScope
         * @returns {Value}
         * @throws {Exception} When no include transport has been configured
         * @throws {Error} When the loader throws a generic error
         */
        include: function (includedPath, enclosingScope) {
            var includeScope,
                tools = this;

            if (!tools.options[INCLUDE_OPTION]) {
                throw new Exception(
                    'include(' + includedPath + ') :: No "include" transport option is available for loading the module.'
                );
            }

            includeScope = tools.scopeFactory.createLoadScope(
                enclosingScope,
                tools.topLevelNamespaceScope.getFilePath(),
                'include'
            );

            try {
                return tools.loader.load(
                    'include',
                    includedPath,
                    tools.options,
                    tools.environment,
                    tools.module,
                    includeScope,
                    function (path, promise, parentPath, valueFactory) {
                        return tools.options[INCLUDE_OPTION](path, promise, parentPath, valueFactory);
                    }
                );
            } catch (error) {
                if (!(error instanceof LoadFailedException)) {
                    // Rethrow for anything other than the expected possible exception(s) trying to load the module
                    throw error;
                }

                tools.callStack.raiseError(
                    PHPError.E_WARNING,
                    'include(' + includedPath + '): failed to open stream: No such file or directory'
                );
                tools.callStack.raiseError(
                    PHPError.E_WARNING,
                    'include(): Failed opening \'' + includedPath + '\' for inclusion'
                );

                return tools.valueFactory.createBoolean(false);
            }
        },

        /**
         * Used for providing a function for fetching the last line executed in the current scope
         *
         * @param {function} finder
         */
        instrument: function (finder) {
            this.callStack.instrumentCurrent(finder);
        },

        requireOnce: function () {
            // FIXME: This should not be identical to include() or require()

            return this.include.apply(this, arguments);
        },

        require: function () {
            // FIXME: This should not be identical to include()

            return this.include.apply(this, arguments);
        },

        /**
         * Calls the configured tick handler with the current statement's position data.
         * PHPToJS inserts calls to this method when ticking is enabled.
         *
         * @param {number} startLine
         * @param {number} startColumn
         * @param {number} endLine
         * @param {number} endColumn
         * @throws {Exception} When no tick handler has been configured
         */
        tick: function (startLine, startColumn, endLine, endColumn) {
            var tools = this;

            if (!tools.options[TICK_OPTION]) {
                throw new Exception('tick(...) :: No "tick" handler option is available.');
            }

            tools.options[TICK_OPTION].call(
                null,
                tools.getNormalizedPath(),
                startLine,
                startColumn,
                endLine,
                endColumn
            );
        }
    });

    return Tools;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Type/ArrayType.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/Type/ArrayType.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    OF_GENERIC_TYPE_EXPECTED = 'core.of_generic_type_expected',
    TypeInterface = __webpack_require__(/*! ./TypeInterface */ "./node_modules/phpcore/src/Type/TypeInterface.js");

/**
 * Represents a type that can only accept an array value
 *
 * @param {boolean} nullIsAllowed
 * @constructor
 */
function ArrayType(nullIsAllowed) {
    /**
     * @type {boolean}
     */
    this.nullIsAllowed = nullIsAllowed;
}

util.inherits(ArrayType, TypeInterface);

_.extend(ArrayType.prototype, {
    /**
     * {@inheritdoc}
     */
    allowsNull: function () {
        var typeObject = this;

        return typeObject.nullIsAllowed;
    },

    /**
     * {@inheritdoc}
     */
    allowsValue: function (value) {
        return value.getType() === 'array' ||
            (this.allowsNull() && value.getType() === 'null');
    },

    /**
     * {@inheritdoc}
     */
    getDisplayName: function () {
        return 'array';
    },

    /**
     * {@inheritdoc}
     */
    getExpectedMessage: function (translator) {
        return translator.translate(OF_GENERIC_TYPE_EXPECTED, {
            expectedType: this.getDisplayName()
        });
    },

    /**
     * {@inheritdoc}
     */
    isScalar: function () {
        return false; // This is not a scalar type hint
    }
});

module.exports = ArrayType;


/***/ }),

/***/ "./node_modules/phpcore/src/Type/CallableType.js":
/*!*******************************************************!*\
  !*** ./node_modules/phpcore/src/Type/CallableType.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    TypeInterface = __webpack_require__(/*! ./TypeInterface */ "./node_modules/phpcore/src/Type/TypeInterface.js");

/**
 * Represents a type that can only accept a callable value:
 * - An array callable for calling an instance object method (eg. `[$myInstance, 'myMethod']`)
 * - An array callable for calling a static method (eg. `['My\Lib\MyClass', 'myStaticMethod']`)
 * - A function name as a string
 * - A static method as a string (eg. `'My\Lib\MyClass::myStaticMethod'`)
 * - A Closure instance
 *
 * @param {NamespaceScope} namespaceScope
 * @param {boolean} nullIsAllowed
 * @constructor
 */
function CallableType(namespaceScope, nullIsAllowed) {
    /**
     * @type {NamespaceScope}
     */
    this.namespaceScope = namespaceScope;
    /**
     * @type {boolean}
     */
    this.nullIsAllowed = nullIsAllowed;
}

util.inherits(CallableType, TypeInterface);

_.extend(CallableType.prototype, {
    /**
     * {@inheritdoc}
     */
    allowsNull: function () {
        var typeObject = this;

        return typeObject.nullIsAllowed;
    },

    /**
     * {@inheritdoc}
     */
    allowsValue: function (value) {
        return value.isCallable(this.namespaceScope) ||
            (this.allowsNull() && value.getType() === 'null');
    },

    /**
     * {@inheritdoc}
     */
    getDisplayName: function () {
        return 'callable';
    },

    /**
     * {@inheritdoc}
     */
    getExpectedMessage: function () {
        return this.getDisplayName();
    },

    /**
     * {@inheritdoc}
     */
    isScalar: function () {
        return false; // This is not a scalar type hint
    }
});

module.exports = CallableType;


/***/ }),

/***/ "./node_modules/phpcore/src/Type/ClassType.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/Type/ClassType.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    INSTANCE_OF_TYPE_EXPECTED = 'core.instance_of_type_expected',
    TypeInterface = __webpack_require__(/*! ./TypeInterface */ "./node_modules/phpcore/src/Type/TypeInterface.js");

/**
 * Represents a type that can only accept an instance of the specified class or interface or null (if allowed)
 *
 * @param {string} className
 * @param {boolean} nullIsAllowed
 * @constructor
 */
function ClassType(className, nullIsAllowed) {
    /**
     * @type {string}
     */
    this.className = className;
    /**
     * @type {boolean}
     */
    this.nullIsAllowed = nullIsAllowed;
}

util.inherits(ClassType, TypeInterface);

_.extend(ClassType.prototype, {
    /**
     * {@inheritdoc}
     */
    allowsNull: function () {
        var typeObject = this;

        return typeObject.nullIsAllowed;
    },

    /**
     * {@inheritdoc}
     */
    allowsValue: function (value) {
        var typeObject = this;

        return (value.getType() === 'object' && value.classIs(typeObject.className)) ||
            (typeObject.allowsNull() && value.getType() === 'null');
    },

    /**
     * {@inheritdoc}
     */
    getDisplayName: function () {
        return this.className;
    },

    /**
     * {@inheritdoc}
     */
    getExpectedMessage: function (translator) {
        return translator.translate(INSTANCE_OF_TYPE_EXPECTED, {
            expectedType: this.getDisplayName()
        });
    },

    /**
     * {@inheritdoc}
     */
    isScalar: function () {
        return false; // This is not a scalar type hint
    }
});

module.exports = ClassType;


/***/ }),

/***/ "./node_modules/phpcore/src/Type/IterableType.js":
/*!*******************************************************!*\
  !*** ./node_modules/phpcore/src/Type/IterableType.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    TypeInterface = __webpack_require__(/*! ./TypeInterface */ "./node_modules/phpcore/src/Type/TypeInterface.js");

/**
 * Represents a type that can only accept an iterable value:
 * - An array
 * - An object implementing Traversable
 *
 * @param {boolean} nullIsAllowed
 * @constructor
 */
function IterableType(nullIsAllowed) {
    /**
     * @type {boolean}
     */
    this.nullIsAllowed = nullIsAllowed;
}

util.inherits(IterableType, TypeInterface);

_.extend(IterableType.prototype, {
    /**
     * {@inheritdoc}
     */
    allowsNull: function () {
        var typeObject = this;

        return typeObject.nullIsAllowed;
    },

    /**
     * {@inheritdoc}
     */
    allowsValue: function (value) {
        return value.isIterable() ||
            (this.allowsNull() && value.getType() === 'null');
    },

    /**
     * {@inheritdoc}
     */
    getDisplayName: function () {
        return 'iterable';
    },

    /**
     * {@inheritdoc}
     */
    getExpectedMessage: function () {
        return this.getDisplayName();
    },

    /**
     * {@inheritdoc}
     */
    isScalar: function () {
        return false; // This is not a scalar type hint
    }
});

module.exports = IterableType;


/***/ }),

/***/ "./node_modules/phpcore/src/Type/MixedType.js":
/*!****************************************************!*\
  !*** ./node_modules/phpcore/src/Type/MixedType.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    TypeInterface = __webpack_require__(/*! ./TypeInterface */ "./node_modules/phpcore/src/Type/TypeInterface.js");

/**
 * Represents an unspecified type, where any value is allowed,
 * such as a function parameter with no type specified
 *
 * @constructor
 */
function MixedType() {

}

util.inherits(MixedType, TypeInterface);

_.extend(MixedType.prototype, {
    /**
     * {@inheritdoc}
     */
    allowsNull: function () {
        return true; // When no type is specified, null is always allowed
    },

    /**
     * {@inheritdoc}
     */
    allowsValue: function () {
        return true; // When no type is specified, any value is allowed
    },

    /**
     * {@inheritdoc}
     */
    getDisplayName: function () {
        return 'mixed';
    },

    /**
     * {@inheritdoc}
     */
    getExpectedMessage: function () {
        return this.getDisplayName();
    },

    /**
     * {@inheritdoc}
     */
    isScalar: function () {
        return false; // This is not a scalar type hint
    }
});

module.exports = MixedType;


/***/ }),

/***/ "./node_modules/phpcore/src/Type/TypeFactory.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcore/src/Type/TypeFactory.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    ArrayType = __webpack_require__(/*! ./ArrayType */ "./node_modules/phpcore/src/Type/ArrayType.js"),
    CallableType = __webpack_require__(/*! ./CallableType */ "./node_modules/phpcore/src/Type/CallableType.js"),
    ClassType = __webpack_require__(/*! ./ClassType */ "./node_modules/phpcore/src/Type/ClassType.js"),
    IterableType = __webpack_require__(/*! ./IterableType */ "./node_modules/phpcore/src/Type/IterableType.js"),
    MixedType = __webpack_require__(/*! ./MixedType */ "./node_modules/phpcore/src/Type/MixedType.js");

/**
 * Creates objects related to Types
 *
 * @constructor
 */
function TypeFactory() {

}

_.extend(TypeFactory.prototype, {
    /**
     * Creates a new ArrayType
     *
     * @param {boolean=} nullIsAllowed
     * @returns {ArrayType}
     */
    createArrayType: function (nullIsAllowed) {
        return new ArrayType(nullIsAllowed);
    },

    /**
     * Creates a new CallableType
     *
     * @param {NamespaceScope} namespaceScope
     * @param {boolean=} nullIsAllowed
     * @returns {CallableType}
     */
    createCallableType: function (namespaceScope, nullIsAllowed) {
        return new CallableType(namespaceScope, nullIsAllowed);
    },

    /**
     * Creates a new ClassType
     *
     * @param {string} className
     * @param {boolean=} nullIsAllowed
     * @returns {ClassType}
     */
    createClassType: function (className, nullIsAllowed) {
        return new ClassType(className, nullIsAllowed);
    },

    /**
     * Creates a new IterableType
     *
     * @param {boolean=} nullIsAllowed
     * @returns {IterableType}
     */
    createIterableType: function (nullIsAllowed) {
        return new IterableType(nullIsAllowed);
    },

    /**
     * Creates a new MixedType
     *
     * @returns {MixedType}
     */
    createMixedType: function () {
        return new MixedType();
    }
});

module.exports = TypeFactory;


/***/ }),

/***/ "./node_modules/phpcore/src/Type/TypeInterface.js":
/*!********************************************************!*\
  !*** ./node_modules/phpcore/src/Type/TypeInterface.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    throwUnimplemented = function (functionName) {
        return function () {
            throw new Error(functionName + '() :: Not implemented');
        };
    };

/**
 * @interface
 */
function TypeInterface() {
    throw new Error('TypeInterface cannot be instantiated');
}

_.extend(TypeInterface.prototype, {
    /**
     * Determines whether a parameter defined with this type (for example)
     * would allow a null value
     *
     * @returns {bool}
     */
    allowsNull: throwUnimplemented('allowsNull'),

    /**
     * Determines whether a parameter defined with this type (for example)
     * would allow the given value
     *
     * @param {Value} value
     * @returns {bool}
     */
    allowsValue: throwUnimplemented('allowsValue'),

    /**
     * Fetches the display name for this type (eg. "string" or "My\Lib\MyClass")
     *
     * @returns {string}
     */
    getDisplayName: throwUnimplemented('getDisplayName'),

    /**
     * Fetches the message to display when this type is an expected type,
     * eg. in an error message where the given argument did not match
     *
     * @param {Translator} translator
     * @returns {string}
     */
    getExpectedMessage: throwUnimplemented('getExpectedMessage'),

    /**
     * Determines whether this type is for a scalar value (integer, string or boolean)
     *
     * @returns {bool}
     */
    isScalar: throwUnimplemented('isScalar')
});

module.exports = TypeInterface;


/***/ }),

/***/ "./node_modules/phpcore/src/Value.js":
/*!*******************************************!*\
  !*** ./node_modules/phpcore/src/Value.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ./Reference/Null */ "./node_modules/phpcore/src/Reference/Null.js")
], function (
    _,
    phpCommon,
    NullReference
) {
    var PHPError = phpCommon.PHPError,

        CLASS_NAME_NOT_VALID = 'core.class_name_not_valid',
        METHOD_CALLED_ON_NON_OBJECT = 'core.method_called_on_non_object',
        NON_OBJECT_METHOD_CALL = 'core.non_object_method_call',
        UNSUPPORTED_OPERAND_TYPES = 'core.unsupported_operand_types',

        createNullReference = function (value) {
            var callStack = value.callStack;

            return new NullReference(value.factory, {
                onSet: function () {
                    callStack.raiseError(PHPError.E_WARNING, 'Cannot use a scalar value as an array');
                }
            });
        },
        throwUnimplemented = function () {
            throw new Error('Unimplemented');
        };

    function Value(factory, callStack, type, value) {
        this.factory = factory;
        this.callStack = callStack;
        this.type = type;
        this.value = value;
    }

    _.extend(Value.prototype, {
        /**
         * Adds this value to an array
         */
        addToArray: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        addToFloat: function (floatValue) {
            var leftValue = this;

            // Coerce to float and return a float if either operand is a float
            return leftValue.factory.createFloat(leftValue.coerceToFloat().getNative() + floatValue.getNative());
        },

        addToNull: function () {
            return this;
        },

        addToString: function (stringValue) {
            return stringValue.coerceToNumber().add(this.coerceToNumber());
        },

        /**
         * Calculates the bitwise-AND of this and a right-operand
         *
         * @param {Value} rightValue
         * @returns {IntegerValue}
         */
        bitwiseAnd: function (rightValue) {
            var value = this;

            /*jshint bitwise:false */
            return value.factory.createInteger(
                (
                    value.coerceToInteger().getNative() & rightValue.coerceToInteger().getNative()
                ) >>> 0 // Force unsigned native JS number
            );
        },

        /**
         * Calculates the bitwise-OR of this and a right-operand
         *
         * @param {Value} rightValue
         * @returns {IntegerValue}
         */
        bitwiseOr: function (rightValue) {
            var value = this;

            /*jshint bitwise:false */
            return value.factory.createInteger(
                (
                    value.coerceToInteger().getNative() | rightValue.coerceToInteger().getNative()
                ) >>> 0 // Force unsigned native JS number
            );
        },

        /**
         * Calls a method on an object
         *
         * @param {string} name
         */
        callMethod: function (name) {
            var value = this;

            value.callStack.raiseTranslatedError(PHPError.E_ERROR, NON_OBJECT_METHOD_CALL, {
                name: name,
                type: value.type
            });
        },

        /**
         * Calls a static method of a given class or the class of a given object
         */
        callStaticMethod: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Returns a clone of this value, or throws an Error if not supported
         *
         * @throws {ObjectValue}
         */
        clone: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, METHOD_CALLED_ON_NON_OBJECT, {
                method: '__clone'
            });
        },

        /**
         * Coerces this value to an array. For all Value types except ArrayValue,
         * the result will be wrapped in an array using this default implementation
         *
         * @returns {FloatValue}
         */
        coerceToArray: function () {
            var value = this;

            return value.factory.createArray([value]);
        },

        /**
         * Coerces this value to a number as a FloatValue
         *
         * @returns {FloatValue}
         */
        coerceToFloat: function () {
            var value = this;

            return value.factory.createFloat(Number(value.value));
        },

        /**
         * Coerces this value to an IntegerValue
         *
         * @returns {IntegerValue}
         */
        coerceToInteger: function () {
            var value = this;

            /*jshint bitwise:false */
            return value.factory.createInteger(Number(value.value) >>> 0);
        },

        /**
         * Unwraps an instance of Throwable to a native JS error
         *
         * @throws {Error}
         */
        coerceToNativeError: function () {
            // NB: This is actually only implemented by ObjectValue
            throw new Error('Only instances of Throwable may be thrown: tried to throw a(n) ' + this.type);
        },

        /**
         * Coerces this value to a number as a FloatValue
         *
         * @returns {FloatValue}
         */
        coerceToNumber: function () {
            return this.coerceToFloat();
        },

        coerceToObject: function () {
            var value = this,
                object = value.factory.createStdClassObject();

            /**
             * Scalars are coerced to objects as follows:
             *
             * > var_dump((object)21);
             *
             * object(stdClass)#1 (1) {
             *   ["scalar"]=>
             *   int(21)
             * }
             */
            object.getInstancePropertyByName(value.factory.createString('scalar')).setValue(value);

            return object;
        },

        coerceToString: throwUnimplemented,

        /**
         * Concatenates this value's string representation with the provided other value's
         *
         * @param {StringValue} rightValue
         * @returns {StringValue}
         */
        concat: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createString(
                leftValue.coerceToString().getNative() + rightValue.coerceToString().getNative()
            );
        },

        decrement: throwUnimplemented,

        /**
         * Divides this value by another
         */
        divide: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Divides an array value by this one
         */
        divideByArray: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Divides a boolean value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByBoolean: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        /**
         * Divides a float value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByFloat: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        /**
         * Divides an integer value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByInteger: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        /**
         * Divides a non-array value by this value
         *
         * @throws {PHPFatalError}
         */
        divideByNonArray: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Divides a null value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByNull: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        /**
         * Divides an object value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByObject: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        /**
         * Divides a string value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByString: function (leftValue) {
            return this.divideByNonArray(leftValue);
        },

        /**
         * Formats the value for display in stack traces etc.
         *
         * @returns {string}
         */
        formatAsString: throwUnimplemented,

        getCallableName: throwUnimplemented,

        /**
         * Fetches a constant of a class by its name
         */
        getConstantByName: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Fetches the type of this value for display purposes, eg. "boolean"
         *
         * @returns {string}
         */
        getDisplayType: function () {
            return this.type;
        },

        getElementByKey: function () {
            return createNullReference(this);
        },

        getForAssignment: function () {
            return this;
        },

        getInstancePropertyByName: throwUnimplemented,

        getLength: function () {
            return this.coerceToString().getLength();
        },

        /**
         * Fetches a native representation of this value
         *
         * @returns {*}
         */
        getNative: function () {
            return this.value;
        },

        /**
         * Exports a "proxying" version of the native value. For normal primitive values
         * (string, boolean, int, float) this will just be the native value,
         * but for objects it will be an instance of PHPObject (see ObjectValue.prototype.getProxy())
         *
         * @returns {*}
         */
        getProxy: function () {
            return this.getNative();
        },

        getPushElement: function () {
            return createNullReference(this);
        },

        getReference: function () {
            throw new Error('Cannot get a reference to a value');
        },

        /**
         * Fetches a static property for a class by its name
         */
        getStaticPropertyByName: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        getType: function () {
            return this.type;
        },

        getValue: function () {
            return this;
        },

        /**
         * Returns this value if defined (this is for the Reference/Value interface -
         * values are always classed as defined)
         *
         * @return {Value}
         */
        getValueOrNull: function () {
            return this;
        },

        /**
         * Coerces this value to a number and adds one to it
         *
         * @returns {Value}
         */
        increment: throwUnimplemented,

        /**
         * Creates an instance of the class this value refers to
         *
         * @throws {PHPFatalError}
         */
        instantiate: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        isAnInstanceOf: throwUnimplemented,

        /**
         * Determines whether this value is callable
         *
         * @param {NamespaceScope} namespaceScope
         * @returns {boolean}
         */
        isCallable: throwUnimplemented,

        /**
         * Determines whether this value is iterable
         *
         * @returns {boolean}
         */
        isIterable: throwUnimplemented,

        /**
         * Determines whether this value is the class of another value
         */
        isTheClassOfArray: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Determines whether this value is the class of another value
         */
        isTheClassOfBoolean: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Determines whether this value is the class of another value
         */
        isTheClassOfFloat: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Determines whether this value is the class of another value
         */
        isTheClassOfInteger: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Determines whether this value is the class of another value
         */
        isTheClassOfNull: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Determines whether this value is the class of another value
         */
        isTheClassOfObject: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Determines whether this value is the class of another value
         */
        isTheClassOfString: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, CLASS_NAME_NOT_VALID);
        },

        /**
         * Determines whether the value is classed as "empty" or not
         *
         * @returns {boolean}
         */
        isEmpty: throwUnimplemented,

        /**
         * Determines whether this value is loosely equal to the provided other value
         *
         * @param {Reference|Value} rightValue
         * @returns {BooleanValue}
         */
        isEqualTo: function (rightValue) {
            /*jshint eqeqeq:false */
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.value == leftValue.value);
        },

        /**
         * Determines whether this value is loosely equal to the provided array value
         *
         * @param {ArrayValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToArray: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Determines whether this value is loosely equal to the provided boolean value
         *
         * @param {BooleanValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToBoolean: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Determines whether this value is loosely equal to the provided float value
         *
         * @param {FloatValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToFloat: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Determines whether this value is loosely equal to the provided integer value
         *
         * @param {IntegerValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToInteger: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Determines whether this value is loosely equal to the provided null value
         *
         * @param {NullValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToNull: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Determines whether this value is loosely equal to the provided object value
         *
         * @param {ObjectValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToObject: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Determines whether this value is loosely equal to the provided string value
         *
         * @param {StringValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToString: function (rightValue) {
            return this.isEqualTo(rightValue);
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is greater than the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isGreaterThan: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() > rightValue.coerceToNumber().getNative()
            );
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is greater than or equal to the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isGreaterThanOrEqual: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() >= rightValue.coerceToNumber().getNative()
            );
        },

        /**
         * Determines whether this value is strictly equal
         * to the provided other value
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isIdenticalTo: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(
                rightValue.type === leftValue.type &&
                rightValue.value === leftValue.value
            );
        },

        /**
         * Determines whether this value is strictly equal
         * to the provided array value
         *
         * @param {ArrayValue} rightValue
         * @returns {BooleanValue}
         */
        isIdenticalToArray: function (rightValue) {
            return this.isIdenticalTo(rightValue);
        },

        /**
         * Determines whether this value is strictly equal
         * to the provided object value
         *
         * @param {ObjectValue} rightValue
         * @returns {BooleanValue}
         */
        isIdenticalToObject: function (rightValue) {
            return this.isIdenticalTo(rightValue);
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is less than the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isLessThan: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() < rightValue.coerceToNumber().getNative()
            );
        },

        /**
         * Compares this value to another value, returning bool(true)
         * if this value is less than or equal to the other and false otherwise
         *
         * @param {Value} rightValue
         * @returns {BooleanValue}
         */
        isLessThanOrEqual: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(
                leftValue.coerceToNumber().getNative() <= rightValue.coerceToNumber().getNative()
            );
        },

        /**
         * Loosely compares this value to the provided other value,
         * returning true if they are not equal and false otherwise
         *
         * @param {Reference|Value} rightValue
         * @returns {BooleanValue}
         */
        isNotEqualTo: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(!leftValue.isEqualTo(rightValue).getNative());
        },

        /**
         * Strictly compares this value to the provided other value,
         * returning true if they are not of the same type
         * or of the same type but with a different value,
         * and false otherwise
         *
         * @param {Reference|Value} rightValue
         * @returns {BooleanValue}
         */
        isNotIdenticalTo: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(!leftValue.isIdenticalTo(rightValue).getNative());
        },

        /**
         * Returns true if this value is numeric and false otherwise
         *
         * @returns {boolean}
         */
        isNumeric: throwUnimplemented,

        /**
         * Determines whether this value is classed as "set" or not
         *
         * @returns {boolean}
         */
        isSet: function () {
            // All values except NULL are classed as 'set'
            return true;
        },

        /**
         * Performs a logical-AND of this value and the other value given
         *
         * @param {Reference|Value} rightValue
         * @returns {BooleanValue}
         */
        logicalAnd: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(
                leftValue.coerceToBoolean().getNative() &&
                rightValue.coerceToBoolean().getNative()
            );
        },

        /**
         * Performs a logical-NOT of this value.
         * If this value is truthy this will return false,
         * otherwise if falsy it will return true
         *
         * @returns {BooleanValue}
         */
        logicalNot: function () {
            var value = this;

            return value.factory.createBoolean(!value.coerceToBoolean().getNative());
        },

        /**
         * Calculates the modulo (remainder of an integer division) of this value with another
         *
         * @param {Value} rightValue
         * @returns {IntegerValue}
         */
        modulo: function (rightValue) {
            var value = this,
                // Coerce both operands to integers first, to ensure an integer division
                dividend = value.coerceToInteger().getNative(),
                divisor = rightValue.coerceToInteger().getNative();

            if (divisor === 0) {
                value.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return value.factory.createBoolean(false);
            }

            return value.factory.createInteger(dividend % divisor);
        },

        /**
         * Multiplies this value with another
         */
        multiply: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Multiplies an array value by this value
         *
         * @throws {PHPFatalError}
         */
        multiplyByArray: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Multiplies a boolean value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByBoolean: function (leftValue) {
            return this.multiplyByNonArray(leftValue);
        },

        /**
         * Multiplies a float value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByFloat: function (leftValue) {
            return this.multiplyByNonArray(leftValue);
        },

        /**
         * Multiplies an integer value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByInteger: function (leftValue) {
            return this.multiplyByNonArray(leftValue);
        },

        /**
         * Multiplies a non-array value by this value
         *
         * @throws {PHPFatalError}
         */
        multiplyByNonArray: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Multiplies a null value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByNull: function (leftValue) {
            return this.multiplyByNonArray(leftValue);
        },

        /**
         * Multiplies an object value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByObject: function (leftValue) {
            return this.multiplyByNonArray(leftValue);
        },

        /**
         * Multiplies a string value by this value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByString: function (leftValue) {
            return this.multiplyByNonArray(leftValue);
        },

        /**
         * Subtracts another value from this one
         *
         * @returns {Value}
         */
        subtract: throwUnimplemented,

        /**
         * Subtracts this value from null
         */
        subtractFromNull: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        }
    });

    return Value;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/Array.js":
/*!*************************************************!*\
  !*** ./node_modules/phpcore/src/Value/Array.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Reference/Element */ "./node_modules/phpcore/src/Reference/Element.js"),
    __webpack_require__(/*! ../KeyReferencePair */ "./node_modules/phpcore/src/KeyReferencePair.js"),
    __webpack_require__(/*! ../KeyValuePair */ "./node_modules/phpcore/src/KeyValuePair.js"),
    __webpack_require__(/*! ../Reference/Null */ "./node_modules/phpcore/src/Reference/Null.js"),
    __webpack_require__(/*! ../Reference/Reference */ "./node_modules/phpcore/src/Reference/Reference.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js"),
    __webpack_require__(/*! ../Variable */ "./node_modules/phpcore/src/Variable.js")
], function (
    _,
    phpCommon,
    util,
    ElementReference,
    KeyReferencePair,
    KeyValuePair,
    NullReference,
    Reference,
    Value,
    Variable
) {
    var FUNCTION_NAME_MUST_BE_STRING = 'core.function_name_must_be_string',
        UNSUPPORTED_OPERAND_TYPES = 'core.unsupported_operand_types',
        hasOwn = {}.hasOwnProperty,
        PHPError = phpCommon.PHPError,
        /**
         * Prefixes any key called `length` with an underscore to avoid collisions
         * with the native array `length` property (an array is used to maintain numeric indices).
         * Any key that is already `_length` must also be prefixed again to avoid collisions there too.
         *
         * @param {*} keyNative
         * @returns {*}
         */
        sanitiseKey = function (keyNative) {
            if (typeof keyNative === 'number') {
                return keyNative;
            }

            if (typeof keyNative === 'string') {
                return keyNative.replace(/^_*length/, '_$&');
            }

            return keyNative;
        };

    function ArrayValue(factory, callStack, orderedElements, type, elementProvider) {
        var elements = [],
            keysToElements = [],
            value = this;

        _.each(orderedElements, function (orderedElement, key) {
            var element,
                elementReference = null,
                elementValue = null;

            if (orderedElement instanceof KeyValuePair) {
                key = orderedElement.getKey();
                elementValue = orderedElement.getValue();
            } else if (orderedElement instanceof KeyReferencePair) {
                key = orderedElement.getKey();
                elementReference = orderedElement.getReference();
            } else {
                if (_.isNumber(key)) {
                    key = factory.createInteger(keysToElements.length);
                } else {
                    key = factory.createFromNative(key);
                }

                if (orderedElement instanceof Reference) {
                    elementReference = orderedElement;
                } else if (orderedElement instanceof Variable) {
                    // TODO: Prevent Variables ever being passed to the ArrayValue ctor, only References
                    elementValue = orderedElement.getValue();
                } else {
                    elementValue = factory.coerce(orderedElement);
                }
            }

            if (elementValue) {
                element = elementProvider.createElement(factory, callStack, value, key, elementValue);
            } else {
                element = elementProvider.createElement(factory, callStack, value, key, null, elementReference);
            }

            elements.push(element);
            keysToElements[sanitiseKey(key.getNative())] = element;
        });

        Value.call(this, factory, callStack, type || 'array', elements);

        this.elementProvider = elementProvider;
        this.keysToElements = keysToElements;
        this.pointer = 0;
    }

    util.inherits(ArrayValue, Value);

    _.extend(ArrayValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToArray(this);
        },

        addToArray: function (leftValue) {
            var rightValue = this,
                resultArray = leftValue.getForAssignment();

            _.forOwn(rightValue.keysToElements, function (element, key) {
                if (!hasOwn.call(resultArray.keysToElements, key)) {
                    resultArray.getElementByKey(element.getKey()).setValue(element.getValue());
                }
            });

            return resultArray;
        },

        /**
         * Adds this value to a boolean
         */
        addToBoolean: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Adds this value to a float
         */
        addToFloat: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Adds this value to an integer
         */
        addToInteger: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Adds this value to null
         */
        addToNull: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Adds this value to an object
         */
        addToObject: function (objectValue) {
            return objectValue.addToArray(this);
        },

        /**
         * Adds this value to a string
         */
        addToString: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Calls a static or instance method, referenced by the first two elements of this array
         *
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         * @throws {PHPFatalError} Throws when the given function name is not a string
         */
        call: function (args, namespaceOrNamespaceScope) {
            var methodNameValue,
                objectOrClassValue,
                arrayValue = this,
                value = arrayValue.value;

            if (value.length < 2) {
                arrayValue.callStack.raiseTranslatedError(PHPError.E_ERROR, FUNCTION_NAME_MUST_BE_STRING);
            }

            objectOrClassValue = value[0].getValue();
            methodNameValue = value[1].getValue();

            if (objectOrClassValue.getType() === 'string') {
                return objectOrClassValue.callStaticMethod(
                    methodNameValue,
                    args,
                    namespaceOrNamespaceScope
                );
            }

            return objectOrClassValue.callMethod(
                methodNameValue.getNative(),
                args,
                namespaceOrNamespaceScope
            );
        },

        coerceToArray: function () {
            return this;
        },

        coerceToBoolean: function () {
            var value = this;

            return value.factory.createBoolean(value.value.length > 0);
        },

        coerceToInteger: function () {
            var value = this;

            return value.factory.createInteger(value.value.length === 0 ? 0 : 1);
        },

        coerceToKey: function () {
            this.callStack.raiseError(PHPError.E_WARNING, 'Illegal offset type');
        },

        coerceToNumber: function () {
            return this.coerceToInteger();
        },

        coerceToObject: function () {
            var value = this,
                object = value.factory.createStdClassObject();

            _.each(value.value, function (element) {
                object.getInstancePropertyByName(element.getKey()).setValue(element.getValue());
            });

            return object;
        },

        coerceToString: function () {
            return this.factory.createString('Array');
        },

        defineElement: function (elementReference) {
            var value = this;

            if (value.value.indexOf(elementReference) === -1) {
                value.value.push(elementReference);
            }
        },

        formatAsString: function () {
            return 'Array';
        },

        /**
         * Fetches a copy of this array, as in PHP arrays are always passed by value
         * and not by reference
         *
         * @return {ArrayValue}
         */
        getForAssignment: function () {
            var arrayValue = this,
                orderedElements = [];

            _.each(arrayValue.value, function (element) {
                if (element.isDefined()) {
                    orderedElements.push(element.getPairForAssignment());
                }
            });

            return new ArrayValue(
                arrayValue.factory,
                arrayValue.callStack,
                orderedElements,
                arrayValue.type,
                arrayValue.elementProvider
            );
        },

        getKeys: function () {
            var keys = [];

            _.each(this.value, function (element) {
                keys.push(element.getKey());
            });

            return keys;
        },

        /**
         * Exports a wrapped PHP indexed array to a native array, or
         * an associative array to a plain JS object
         *
         * @returns {Array|object}
         */
        getNative: function () {
            var hasNonNumericKey = false,
                result = [],
                value = this;

            _.each(value.value, function (element) {
                // Treat string keys that have a numeric value as numeric
                if (!isFinite(element.getKey().getNative())) {
                    hasNonNumericKey = true;
                }
            });

            result = hasNonNumericKey ? {} : [];

            _.each(value.value, function (element) {
                result[element.getKey().getNative()] = element.getValue().getNative();
            });

            return result;
        },

        getCurrentElement: function () {
            var value = this;

            return value.value[value.pointer] || value.factory.createNull();
        },

        getElementByKey: function (key) {
            var element,
                keyValue,
                value = this;

            key = key.coerceToKey(value.callStack);

            if (!key) {
                // Could not be coerced to a key: error will already have been handled, just return NULL
                return new NullReference(value.factory);
            }

            keyValue = sanitiseKey(key.getNative());

            if (!hasOwn.call(value.keysToElements, keyValue)) {
                element = value.elementProvider.createElement(value.factory, value.callStack, value, key, null);

                value.keysToElements[keyValue] = element;
            }

            return value.keysToElements[keyValue];
        },

        getElementByIndex: function (index) {
            var value = this;

            return value.value[index] || (function () {
                    value.callStack.raiseError(PHPError.E_NOTICE, 'Undefined ' + value.referToElement(index));

                    return new NullReference(value.factory);
                }());
        },

        /**
         * Fetches a KeyValuePair or KeyReferencePair for the specified array element,
         * optionally allowing the key to be overridden
         *
         * @param {Value} key
         * @param {Value|undefined} overrideKey
         * @returns {KeyValuePair|KeyReferencePair}
         */
        getElementPairByKey: function (key, overrideKey) {
            return this.getElementByKey(key).getPairForAssignment(overrideKey);
        },

        /**
         * Creates an ArrayIterator for iterating over this array. Used by transpiled foreach loops.
         *
         * @returns {ArrayIterator}
         */
        getIterator: function () {
            var value = this;

            return value.factory.createArrayIterator(value);
        },

        getValueReferences: function () {
            var references = [];

            _.each(this.value, function (element) {
                references.push(element.getValueReference());
            });

            return references;
        },

        getKeyByIndex: function (index) {
            var value = this,
                element = value.value[index];

            return element ? element.key : null;
        },

        getLength: function () {
            return this.value.length;
        },

        getPointer: function () {
            return this.pointer;
        },

        getPushElement: function () {
            var value = this;

            return value.elementProvider.createElement(value.factory, value.callStack, value, null, null);
        },

        getValues: function () {
            var values = [];

            _.each(this.value, function (element) {
                values.push(element.getValue());
            });

            return values;
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfArray(this);
        },

        /**
         * {@inheritdoc}
         */
        isCallable: function (namespaceScope) {
            var classObject,
                globalNamespace,
                methodNameValue,
                objectOrClassValue,
                arrayValue = this,
                value = arrayValue.value;

            if (value.length < 2) {
                return false;
            }

            globalNamespace = namespaceScope.getGlobalNamespace();
            objectOrClassValue = value[0].getValue();
            methodNameValue = value[1].getValue();

            if (objectOrClassValue.getType() === 'string') {
                if (!globalNamespace.hasClass(objectOrClassValue.getNative())) {
                    return false;
                }

                classObject = globalNamespace.getClass(objectOrClassValue.getNative());
            } else if (objectOrClassValue.getType() === 'object') {
                classObject = objectOrClassValue.getClass();
            } else {
                // First element must either be an object or a string
                return false;
            }

            if (methodNameValue.getType() !== 'string') {
                // Second, method name element must be a string containing the name of a method
                return false;
            }

            return classObject.getMethodSpec(methodNameValue.getNative()) !== null;
        },

        /**
         * Determines whether this array is classed as "empty" or not.
         * Only empty arrays (with no elements) are classed as empty
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            return this.value.length === 0;
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToArray(this);
        },

        isEqualToNull: function () {
            var value = this;

            return value.factory.createBoolean(value.value.length === 0);
        },

        isEqualToArray: function (rightValue) {
            var equal = true,
                leftValue = this,
                factory = leftValue.factory;

            if (rightValue.value.length !== leftValue.value.length) {
                return factory.createBoolean(false);
            }

            _.forOwn(rightValue.keysToElements, function (element, nativeKey) {
                if (!hasOwn.call(leftValue.keysToElements, nativeKey) || element.getValue().isNotEqualTo(leftValue.keysToElements[nativeKey].getValue()).getNative()) {
                    equal = false;
                    return false;
                }
            });

            return factory.createBoolean(equal);
        },

        isEqualToBoolean: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.getNative() === (leftValue.value.length > 0));
        },

        isEqualToFloat: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToInteger: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToObject: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToString: function () {
            return this.factory.createBoolean(false);
        },

        isIdenticalTo: function (rightValue) {
            return rightValue.isIdenticalToArray(this);
        },

        isIdenticalToArray: function (rightValue) {
            var identical = true,
                leftValue = this,
                factory = leftValue.factory;

            if (rightValue.value.length !== leftValue.value.length) {
                return factory.createBoolean(false);
            }

            _.each(rightValue.value, function (element, index) {
                if (
                    leftValue.value[index].getKey().isNotIdenticalTo(element.getKey()).getNative() ||
                    leftValue.value[index].getValue().isNotIdenticalTo(element.getValue()).getNative()
                ) {
                    identical = false;
                    return false;
                }
            });

            return factory.createBoolean(identical);
        },

        /**
         * {@inheritdoc}
         */
        isIterable: function () {
            return true;
        },

        /**
         * Arrays are never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        next: function () {
            this.pointer++;
        },

        /**
         * Calculates the ones' complement of this value
         */
        onesComplement: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        pointToElement: function (elementReference) {
            var value = this;

            _.each(value.value, function (element, index) {
                if (element.getKey().isEqualTo(elementReference.getKey()).getNative()) {
                    value.setPointer(index);
                }
            });
        },

        /**
         * Removes the last element from the array and then returns it, if any.
         * If the array is empty (so that there is no last element), NULL is returned
         *
         * @returns {Value}
         */
        pop: function () {
            var value = this,
                length = value.getLength();

            if (length === 0) {
                // Array is empty: nothing to pop off
                return value.factory.createNull();
            }

            delete value.keysToElements[value.getKeyByIndex(length - 1).getNative()];

            value.pointer = 0;

            return value.value.pop().getValue();
        },

        /**
         * Pushes an indexed element onto the array and then returns the array
         *
         * @param {Value} otherValue
         * @returns {ArrayValue}
         */
        push: function (otherValue) {
            var value = this,
                index = value.factory.createInteger(value.keysToElements.length);

            value.getElementByKey(index).setValue(otherValue);

            return value;
        },

        /**
         * Pushes an indexed element onto the array and then returns the key generated for it
         *
         * @param {ElementReference} elementReference
         * @returns {IntegerValue}
         */
        pushElement: function (elementReference) {
            var value = this,
                key = value.keysToElements.length,
                keyValue;

            value.keysToElements[key] = elementReference;
            value.value.push(elementReference);

            keyValue = value.factory.createInteger(key);
            elementReference.setKey(keyValue);

            return keyValue;
        },

        referToElement: function (key) {
            return 'offset: ' + key;
        },

        reset: function () {
            var value = this;

            value.pointer = 0;

            return value;
        },

        setPointer: function (pointer) {
            this.pointer = pointer;
        },

        /**
         * Removes the first element from the array, returning it
         * and renumbering any numeric keys
         *
         * @returns {Value}
         */
        shift: function () {
            var value = this,
                elements = value.value,
                newElements = [],
                newKeysToElements = {},
                nextNumericKey = 0;

            if (elements.length === 0) {
                return value.factory.createNull();
            }

            _.each(elements.slice(1), function (element) {
                var key = element.getKey(),
                    nativeKey = key.getNative();

                if (isFinite(nativeKey)) {
                    // All numeric keys need to be renumbered to start from zero
                    nativeKey = nextNumericKey++;
                    key = value.factory.createInteger(nativeKey);
                }

                element = value.elementProvider.createElement(value.factory, value.callStack, value, key, element.getValue());

                newKeysToElements[sanitiseKey(nativeKey)] = element;
                newElements.push(element);
            });

            // Internal array pointer needs to be reset to the start of the array.
            // As we are removing an element and renumbering any numerically indexed ones,
            // the pointer could be left invalid if we didn't anyway
            value.pointer = 0;
            value.keysToElements = newKeysToElements;
            value.value = newElements;

            return elements[0].getValue();
        },

        shiftLeftBy: function (rightValue) {
            return this.coerceToInteger().shiftLeftBy(rightValue);
        },

        shiftRightBy: function (rightValue) {
            return this.coerceToInteger().shiftRightBy(rightValue);
        },

        sort: function (callback) {
            this.value.sort(callback);
        }
    });

    return ArrayValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/BarewordString.js":
/*!**********************************************************!*\
  !*** ./node_modules/phpcore/src/Value/BarewordString.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ./String */ "./node_modules/phpcore/src/Value/String.js")
], function (
    _,
    util,
    StringValue
) {
    function BarewordStringValue(factory, callStack, value) {
        StringValue.call(this, factory, callStack, value);
    }

    util.inherits(BarewordStringValue, StringValue);

    _.extend(BarewordStringValue.prototype, {
        call: function (args, namespaceOrNamespaceScope) {
            return namespaceOrNamespaceScope.getFunction(this.value).apply(null, args);
        },

        /**
         * Calls a static method of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @param {bool} isForwarding eg. self::f() is forwarding, MyParentClass::f() is non-forwarding
         * @returns {Value}
         */
        callStaticMethod: function (nameValue, args, namespaceOrNamespaceScope, isForwarding) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getClass(value.value);

            return classObject.callMethod(nameValue.getNative(), args, null, null, null, isForwarding);
        },

        /**
         * Fetches the fully-qualified version of this name (function or class)
         *
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {StringValue}
         */
        getCallableName: function (namespaceOrNamespaceScope) {
            var rightValue = this,
                resolvedClass = namespaceOrNamespaceScope.resolveClass(rightValue.value);

            return resolvedClass.namespace.getPrefix() + resolvedClass.name;
        },

        /**
         * Fetches the value of a constant from the class this string refers to
         *
         * @param {string} name
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getConstantByName: function (name, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getClass(value.value);

            return classObject.getConstantByName(name);
        },

        /**
         * Fetches the value of a static property of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getStaticPropertyByName: function (nameValue, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getClass(value.value);

            return classObject.getStaticPropertyByName(nameValue.getNative());
        },

        /**
         * Creates an instance of the class this string contains the name of,
         * relative to the current namespace
         *
         * @param {Value[]} args
         * @param {NamespaceScope} namespaceScope
         * @returns {ObjectValue}
         */
        instantiate: function (args, namespaceScope) {
            var value = this,
                classObject = namespaceScope.getClass(value.value);

            return classObject.instantiate(args);
        },

        /**
         * Determines whether the class this string references is the class of the specified object
         *
         * @param {ObjectValue} objectValue
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {BooleanValue}
         */
        isTheClassOfObject: function (objectValue, namespaceOrNamespaceScope) {
            var rightValue = this,
                fqcn = rightValue.getCallableName(namespaceOrNamespaceScope);

            return rightValue.factory.createBoolean(
                objectValue.classIs(fqcn)
            );
        }
    });

    return BarewordStringValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/Boolean.js":
/*!***************************************************!*\
  !*** ./node_modules/phpcore/src/Value/Boolean.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var UNSUPPORTED_OPERAND_TYPES = 'core.unsupported_operand_types',
        PHPError = phpCommon.PHPError;

    function BooleanValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'boolean', !!value);
    }

    util.inherits(BooleanValue, Value);

    _.extend(BooleanValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToBoolean(this);
        },

        addToBoolean: function (rightValue) {
            var value = this;

            return value.factory.createInteger(value.value + rightValue.value);
        },

        addToInteger: function (integerValue) {
            return integerValue.addToBoolean(this);
        },

        addToNull: function () {
            return this.coerceToInteger();
        },

        addToObject: function (objectValue) {
            return objectValue.addToBoolean(this);
        },

        coerceToBoolean: function () {
            return this;
        },

        coerceToInteger: function () {
            var value = this;

            return value.factory.createInteger(value.value ? 1 : 0);
        },

        coerceToKey: function () {
            return this.coerceToInteger();
        },

        coerceToNumber: function () {
            return this.coerceToInteger();
        },

        coerceToString: function () {
            var value = this;

            return value.factory.createString(value.value ? '1' : '');
        },

        /**
         * Divides this boolean by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        divide: function (rightValue) {
            return rightValue.divideByBoolean(this);
        },

        /**
         * Divides a non-array value by this boolean
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative(),
                quotient;

            if (divisor === false) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();
            quotient = coercedLeftValue.getNative() / divisor;

            return coercedLeftValue.getType() === 'float' ?
                rightValue.factory.createFloat(quotient) :
                rightValue.factory.createInteger(quotient);
        },

        formatAsString: function () {
            return this.value ? 'true' : 'false';
        },

        getElement: function () {
            // Array access on booleans always returns null, no notice or warning is raised
            return this.factory.createNull();
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfBoolean(this);
        },

        /**
         * {@inheritdoc}
         */
        isCallable: function () {
            return false;
        },

        /**
         * Determines whether this boolean is classed as "empty" or not.
         * Only false is classed as empty
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            return this.value === false;
        },

        isEqualTo: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(rightValue.coerceToBoolean().value === leftValue.value);
        },

        isEqualToObject: function () {
            return this;
        },

        isEqualToString: function (stringValue) {
            var booleanValue = this;

            return stringValue.factory.createBoolean(
                stringValue.coerceToBoolean().getNative() === booleanValue.getNative()
            );
        },

        /**
         * {@inheritdoc}
         */
        isIterable: function () {
            return false;
        },

        /**
         * Booleans are never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        /**
         * Multiplies this boolean by the specified value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        multiply: function (rightValue) {
            return rightValue.multiplyByBoolean(this);
        },

        /**
         * Multiplies a non-array value by this boolean
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByNonArray: function (leftValue) {
            var coercedLeftValue = leftValue.coerceToNumber(),
                rightValue = this,
                multiplier = rightValue.getNative(),
                product = coercedLeftValue.getNative() * multiplier;

            return coercedLeftValue.getType() === 'float' ?
                rightValue.factory.createFloat(product) :
                rightValue.factory.createInteger(product);
        },

        /**
         * Calculates the ones' complement of this value
         */
        onesComplement: function () {
            this.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        shiftLeftBy: function (rightValue) {
            return this.coerceToInteger().shiftLeftBy(rightValue);
        },

        shiftRightBy: function (rightValue) {
            return this.coerceToInteger().shiftRightBy(rightValue);
        }
    });

    return BooleanValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/Exit.js":
/*!************************************************!*\
  !*** ./node_modules/phpcore/src/Value/Exit.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    util,
    Value
) {
    function ExitValue(factory, callStack, statusValue) {
        Value.call(this, factory, callStack, 'exit', null);

        this.statusValue = statusValue;
    }

    util.inherits(ExitValue, Value);

    _.extend(ExitValue.prototype, {
        getStatus: function () {
            var value = this;

            return value.statusValue ? value.statusValue.getNative() : 0;
        }
    });

    return ExitValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/Float.js":
/*!*************************************************!*\
  !*** ./node_modules/phpcore/src/Value/Float.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function FloatValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'float', value);
    }

    util.inherits(FloatValue, Value);

    _.extend(FloatValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToFloat(this);
        },

        addToBoolean: function (booleanValue) {
            var value = this;

            return value.factory.createFloat(value.value + Number(booleanValue.value));
        },

        addToInteger: function (integerValue) {
            var value = this;

            return value.factory.createFloat(value.value + integerValue.value);
        },

        addToObject: function (objectValue) {
            return objectValue.addToFloat(this);
        },

        addToNull: function () {
            return this.coerceToNumber();
        },

        coerceToBoolean: function () {
            var value = this;

            return value.factory.createBoolean(!!value.value);
        },

        coerceToFloat: function () {
            return this;
        },

        coerceToInteger: function () {
            /*jshint bitwise: false */
            var value = this;

            return value.factory.createInteger(value.value >> 0);
        },

        coerceToKey: function () {
            return this.coerceToInteger();
        },

        coerceToNumber: function () {
            return this;
        },

        coerceToString: function () {
            var value = this;

            return value.factory.createString(value.value + '');
        },

        /**
         * Divides this float by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        divide: function (rightValue) {
            return rightValue.divideByFloat(this);
        },

        /**
         * Divides a non-array value by this float
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative();

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            return rightValue.factory.createFloat(coercedLeftValue.getNative() / divisor);
        },

        formatAsString: function () {
            return this.value + '';
        },

        getElement: function () {
            // Array access on floats always returns null, no notice or warning is raised
            return this.factory.createNull();
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfFloat(this);
        },

        /**
         * {@inheritdoc}
         */
        isCallable: function () {
            return false;
        },

        /**
         * Determines whether this float is classed as "empty" or not.
         * Only zero is classed as empty
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            return this.value === 0;
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToFloat(this);
        },

        isEqualToFloat: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.value === leftValue.value);
        },

        isEqualToInteger: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.coerceToFloat().value === leftValue.value);
        },

        isEqualToNull: function () {
            var leftValue = this;

            return leftValue.factory.createBoolean(leftValue.value === 0);
        },

        isEqualToObject: function (objectValue) {
            return objectValue.isEqualToFloat(this);
        },

        isEqualToString: function (stringValue) {
            var floatValue = this;

            return floatValue.factory.createBoolean(floatValue.value === stringValue.coerceToFloat().value);
        },

        /**
         * {@inheritdoc}
         */
        isIterable: function () {
            return false;
        },

        /**
         * Floats are always numeric: always returns true
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return true;
        },

        /**
         * Multiplies this float by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        multiply: function (rightValue) {
            return rightValue.multiplyByFloat(this);
        },

        /**
         * Multiplies a non-array value by this float
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByNonArray: function (leftValue) {
            var coercedMultiplicand = leftValue.coerceToNumber(),
                rightValue = this,
                multiplier = rightValue.value;

            return rightValue.factory.createFloat(coercedMultiplicand.getNative() * multiplier);
        },

        onesComplement: function () {
            /*jshint bitwise: false */
            return this.factory.createInteger(~this.value);
        },

        shiftLeftBy: function (rightValue) {
            return this.coerceToInteger().shiftLeftBy(rightValue);
        },

        shiftRightBy: function (rightValue) {
            return this.coerceToInteger().shiftRightBy(rightValue);
        },

        subtract: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            rightValue = rightValue.coerceToNumber();

            return factory.createFloat(leftValue.getNative() - rightValue.getNative());
        },

        toNegative: function () {
            var value = this;

            return value.factory.createFloat(-value.value);
        },

        toPositive: function () {
            var value = this;

            return value.factory.createInteger(+value.value);
        }
    });

    return FloatValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/Integer.js":
/*!***************************************************!*\
  !*** ./node_modules/phpcore/src/Value/Integer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function IntegerValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'int', value);
    }

    util.inherits(IntegerValue, Value);

    _.extend(IntegerValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToInteger(this);
        },

        addToBoolean: function (booleanValue) {
            var value = this;

            return value.factory.createInteger(value.value + booleanValue.value);
        },

        addToInteger: function (rightValue) {
            var value = this;

            return value.factory.createInteger(value.value + rightValue.value);
        },

        coerceToBoolean: function () {
            var value = this;

            return value.factory.createBoolean(!!value.value);
        },

        coerceToFloat: function () {
            var value = this;

            return value.factory.createFloat(value.value);
        },

        coerceToInteger: function () {
            return this;
        },

        coerceToKey: function () {
            return this;
        },

        coerceToNumber: function () {
            return this;
        },

        coerceToString: function () {
            var value = this;

            return value.factory.createString(value.value.toString());
        },

        decrement: function () {
            var value = this;

            return value.factory.createInteger(value.value - 1);
        },

        /**
         * Divides this integer by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        divide: function (rightValue) {
            return rightValue.divideByInteger(this);
        },

        /**
         * Divides a float value by this integer
         *
         * @param {FloatValue} leftValue
         * @returns {Value}
         */
        divideByFloat: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative();

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            return rightValue.factory.createFloat(coercedLeftValue.getNative() / divisor);
        },

        /**
         * Divides a non-array value by this integer
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.getNative(),
                quotient;

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            quotient = coercedLeftValue.getNative() / divisor;

            // Return result as a float if needed, otherwise keep as integer
            return Math.round(quotient) === quotient ?
                rightValue.factory.createInteger(quotient) :
                rightValue.factory.createFloat(quotient);
        },

        formatAsString: function () {
            return this.value + '';
        },

        getElement: function () {
            // Array access on integers always returns null, no notice or warning is raised
            return this.factory.createNull();
        },

        increment: function () {
            var value = this;

            return value.factory.createInteger(value.value + 1);
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfInteger(this);
        },

        /**
         * {@inheritdoc}
         */
        isCallable: function () {
            return false;
        },

        /**
         * Determines whether this integer is classed as "empty" or not.
         * Only zero is classed as empty
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            return this.value === 0;
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToInteger(this);
        },

        isEqualToInteger: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(rightValue.value === leftValue.value);
        },

        isEqualToNull: function () {
            var leftValue = this;

            return leftValue.factory.createBoolean(leftValue.value === 0);
        },

        isEqualToObject: function (objectValue) {
            return objectValue.isEqualToInteger(this);
        },

        isEqualToString: function (stringValue) {
            var integerValue = this;

            return integerValue.factory.createBoolean(integerValue.getNative() === parseFloat(stringValue.getNative()));
        },

        /**
         * {@inheritdoc}
         */
        isIterable: function () {
            return false;
        },

        /**
         * Integers are always numeric: always returns true
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return true;
        },

        /**
         * Multiplies another value by this integer
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        multiply: function (rightValue) {
            return rightValue.multiplyByInteger(this);
        },

        /**
         * Multiplies a float value by this integer
         *
         * @param {FloatValue} leftValue
         * @returns {Value}
         */
        multiplyByFloat: function (leftValue) {
            var coercedLeftValue = leftValue.coerceToNumber(),
                rightValue = this,
                multiplier = rightValue.value;

            return rightValue.factory.createFloat(coercedLeftValue.getNative() * multiplier);
        },

        /**
         * Multiplies a non-array value by this integer
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByNonArray: function (leftValue) {
            var coercedMultiplicand = leftValue.coerceToNumber(),
                rightValue = this,
                multiplier = rightValue.value,
                product = coercedMultiplicand.getNative() * multiplier;

            // Return result as a float if needed, otherwise keep as integer
            return Math.round(product) === product ?
                rightValue.factory.createInteger(product) :
                rightValue.factory.createFloat(product);
        },

        onesComplement: function () {
            /*jshint bitwise: false */
            return this.factory.createInteger(~this.value);
        },

        shiftLeftBy: function (rightValue) {
            /*jshint bitwise: false */
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createInteger(leftValue.getNative() << rightValue.coerceToInteger().getNative());
        },

        shiftRightBy: function (rightValue) {
            /*jshint bitwise: false */
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createInteger(leftValue.getNative() >> rightValue.coerceToInteger().getNative());
        },

        subtract: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            rightValue = rightValue.coerceToNumber();

            // Coerce to float and return a float if either operand is a float
            if (rightValue.getType() === 'float') {
                return factory.createFloat(leftValue.coerceToFloat().getNative() - rightValue.coerceToFloat().getNative());
            }

            return factory.createInteger(leftValue.getNative() - rightValue.getNative());
        },

        subtractFromNull: function () {
            var value = this;

            return value.factory.createInteger(-value.getNative());
        },

        toNegative: function () {
            var value = this;

            return value.factory.createInteger(-value.value);
        },

        toPositive: function () {
            var value = this;

            return value.factory.createInteger(+value.value);
        }
    });

    return IntegerValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/Null.js":
/*!************************************************!*\
  !*** ./node_modules/phpcore/src/Value/Null.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    phpCommon,
    util,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function NullValue(factory, callStack) {
        Value.call(this, factory, callStack, 'null', null);
    }

    util.inherits(NullValue, Value);

    _.extend(NullValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToNull();
        },

        addToBoolean: function (booleanValue) {
            return booleanValue.coerceToInteger();
        },

        coerceToArray: function () {
            // Null just casts to an empty array
            return this.factory.createArray();
        },

        coerceToBoolean: function () {
            return this.factory.createBoolean(false);
        },

        coerceToKey: function () {
            return this.factory.createString('');
        },

        coerceToString: function () {
            return this.factory.createString('');
        },

        /**
         * Divides this null by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        divide: function (rightValue) {
            return rightValue.divideByNull(this);
        },

        /**
         * Divides a non-array value by this null
         *
         * @returns {Value}
         */
        divideByNonArray: function () {
            var rightValue = this;

            rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

            return rightValue.factory.createBoolean(false);
        },

        formatAsString: function () {
            return 'NULL';
        },

        getInstancePropertyByName: function () {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Trying to get property of non-object'
            );

            return value.factory.createNull();
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfNull(this);
        },

        /**
         * {@inheritdoc}
         */
        isCallable: function () {
            return false;
        },

        /**
         * Null is always classed as empty
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            return true;
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToNull(this);
        },

        isEqualToFloat: function (floatValue) {
            return floatValue.isEqualToNull();
        },

        isEqualToNull: function () {
            return this.factory.createBoolean(true);
        },

        isEqualToObject: function (objectValue) {
            return objectValue.isEqualToNull();
        },

        isEqualToString: function (stringValue) {
            return stringValue.isEqualToNull();
        },

        /**
         * {@inheritdoc}
         */
        isIterable: function () {
            return false;
        },

        /**
         * Null is never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        isSet: function () {
            return false;
        },

        /**
         * Multiplies this null by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        multiply: function (rightValue) {
            return rightValue.multiplyByNull(this);
        },

        /**
         * Multiplies this value by a float
         *
         * @returns {FloatValue}
         */
        multiplyByFloat: function () {
            return this.factory.createFloat(0);
        },

        /**
         * Multiplies a non-array value by this null
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByNonArray: function (leftValue) {
            var value = this;

            return leftValue.coerceToNumber().getType() === 'float' ?
                value.factory.createFloat(0) :
                value.factory.createInteger(0);
        },

        subtract: function (rightValue) {
            return rightValue.subtractFromNull();
        }
    });

    return NullValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/Object.js":
/*!**************************************************!*\
  !*** ./node_modules/phpcore/src/Value/Object.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Closure */ "./node_modules/phpcore/src/Closure.js"),
    __webpack_require__(/*! ../KeyValuePair */ "./node_modules/phpcore/src/KeyValuePair.js"),
    __webpack_require__(/*! ../Reference/Null */ "./node_modules/phpcore/src/Reference/Null.js"),
    __webpack_require__(/*! ../Reference/ObjectElement */ "./node_modules/phpcore/src/Reference/ObjectElement.js"),
    __webpack_require__(/*! ../Reference/Property */ "./node_modules/phpcore/src/Reference/Property.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    phpCommon,
    util,
    Closure,
    KeyValuePair,
    NullReference,
    ObjectElement,
    PropertyReference,
    Value
) {
    var hasOwn = {}.hasOwnProperty,
        getPropertyCaseInsensitive = function (object, property) {
            var found = false,
                lowerCaseProperty = property.toLowerCase(),
                otherObject,
                value = null;

            _.forOwn(object, function (propertyValue, propertyName) {
                if (propertyName.toLowerCase() === lowerCaseProperty) {
                    found = true;
                    value = propertyValue;
                    return false;
                }
            });

            if (!found) {
                otherObject = Object.getPrototypeOf(object);

                if (!otherObject) {
                    return null;
                }

                return getPropertyCaseInsensitive(otherObject, property);
            }

            return {
                object: object,
                value: value
            };
        },
        Exception = phpCommon.Exception,
        MAGIC_CLONE = '__clone',
        PHPError = phpCommon.PHPError,

        CANNOT_ACCESS_PROPERTY = 'core.cannot_access_property',
        CANNOT_USE_WRONG_TYPE_AS = 'core.cannot_use_wrong_type_as',
        OBJECT_FROM_GET_ITERATOR_MUST_BE_TRAVERSABLE = 'core.object_from_get_iterator_must_be_traversable',
        UNDEFINED_PROPERTY = 'core.undefined_property',
        UNSUPPORTED_OPERAND_TYPES = 'core.unsupported_operand_types';

    /**
     * Represents an instance of a class. There is a JS<->PHP bridge
     * that wraps objects passed in from JS-land in instances of a special JSObject builtin class.
     *
     * @param {ValueFactory} factory
     * @param {CallStack} callStack
     * @param {Translator} translator
     * @param {object} object
     * @param {Class} classObject
     * @param {number} id
     * @constructor
     */
    function ObjectValue(factory, callStack, translator, object, classObject, id) {
        Value.call(this, factory, callStack, 'object', object);

        /**
         * @type {Class}
         */
        this.classObject = classObject;
        /**
         * @type {number}
         */
        this.id = id;
        /**
         * Internal properties allow JS-defined classes to store data against objects
         * without exposing it to PHP-land, which avoids the risk of any internal data names
         * conflicting with PHP class properties
         *
         * @type {Object.<string, *>}
         */
        this.internalProperties = {};
        /**
         * @type {number}
         */
        this.nextPropertyIndex = 0;
        /**
         * @type {Object.<string, PropertyReference>}
         */
        this.nonPrivateProperties = {};
        /**
         * @type {number}
         */
        this.pointer = 0;
        /**
         * Different classes in the hierarchy may declare their own private property
         * with the same name as an ancestor. For this reason we need to store private properties
         * indexed by the fully-qualified name of the class that defines them
         * (Effectively: {Object.<string, {Object.<string, PropertyReference>}>})
         *
         * @type {Object.<string, object>}
         */
        this.privatePropertiesByFQCN = {};
        /**
         * @type {Translator}
         */
        this.translator = translator;
    }

    util.inherits(ObjectValue, Value);

    _.extend(ObjectValue.prototype, {
        /**
         * Adds this value to another
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        add: function (rightValue) {
            return rightValue.addToObject(this);
        },

        /**
         * Adds this value to an array
         */
        addToArray: function () {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to number'
            );

            value.callStack.raiseTranslatedError(PHPError.E_ERROR, UNSUPPORTED_OPERAND_TYPES);
        },

        /**
         * Adds this value to a boolean
         *
         * @param {BooleanValue} booleanValue
         */
        addToBoolean: function (booleanValue) {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to number'
            );

            return value.factory.createInteger((booleanValue.getNative() ? 1 : 0) + 1);
        },

        /**
         * Adds this value to a float
         *
         * @param {FloatValue} floatValue
         */
        addToFloat: function (floatValue) {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to number'
            );

            return value.factory.createFloat(floatValue.getNative() + 1);
        },

        /**
         * Moves the iterator to its next position.
         * Used by transpiled foreach loops over objects implementing Iterator.
         */
        advance: function () {
            var value = this;

            if (!value.classIs('Iterator')) {
                throw new Exception('Object.advance() :: Object does not implement Iterator');
            }

            value.callMethod('next');
        },

        /**
         * When this object is a Closure instance, returns a new Closure
         * with the specified bound `$this` object and a new current class scope
         *
         * @param {ObjectValue|NullValue} thisValue
         * @param {Class|undefined} scopeClass
         * @returns {Closure}
         */
        bindClosure: function (thisValue, scopeClass) {
            var closure,
                value = this;

            if (!value.classIs('Closure')) {
                throw new Error('bindClosure() :: Value is not a Closure');
            }

            closure = value.getInternalProperty('closure');

            return closure.bind(thisValue, scopeClass);
        },

        /**
         * Calls the magic __invoke() method for this object
         *
         * @param {Reference[]|Value[]|Variable[]} args
         * @returns {Reference|Value}
         */
        call: function (args) {
            return this.callMethod('__invoke', args);
        },

        /**
         * Calls the specified method of this object
         *
         * @param {string} name
         * @param {Value[]?} args
         * @returns {Value} Returns the result of the method if it exists
         * @throws {PHPFatalError} Throws when the method does not exist
         */
        callMethod: function (name, args) {
            var value = this;

            return value.classObject.callMethod(name, args, value);
        },

        /**
         * Calls a static method of the class this object is an instance of
         *
         * @param {StringValue} nameValue
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @param {bool} isForwarding eg. self::f() is forwarding, MyParentClass::f() is non-forwarding
         * @returns {Value}
         */
        callStaticMethod: function (nameValue, args, namespaceOrNamespaceScope, isForwarding) {
            // Could be a static call in object context, in which case we want to pass
            // the object value through.
            // This will be handled by a fetch of `callStack.getThisObject()` inside `.callMethod(...)`
            return this.classObject.callMethod(nameValue.getNative(), args, null, null, null, isForwarding);
        },

        /**
         * Determines whether this object is an instance of the given class
         *
         * @param {string} className
         * @returns {boolean}
         */
        classIs: function (className) {
            return this.classObject.is(className);
        },

        /**
         * Returns a clone of this object value
         *
         * @returns {ObjectValue}
         */
        clone: function () {
            var value = this,
                // Avoid calling the __construct() class constructor when cloning,
                // however note that the native constructor will still be called
                // as that is used to initialise properties for PHP-defined classes etc.
                cloneObjectValue = value.classObject.instantiateBare(
                    // TODO: Consider storing the arguments passed to the constructor,
                    //       so that they may be passed here - however this may then leak memory
                    //       as we would be holding on to references to those arguments' values
                    []
                );

            // Clones are shallow: each property's value is simply copied over to the clone.
            // (Note that arrays will be copied as is done for assignments.)
            // If a deep clone is required then the user must implement the magic __clone method
            // and perform the recursion themselves.
            _.each(value.getPropertyNames(), function (name) {
                cloneObjectValue.setProperty(name, value.getProperty(name));
            });

            // Call the magic __clone method if defined
            if (cloneObjectValue.isMethodDefined(MAGIC_CLONE)) {
                cloneObjectValue.callMethod(MAGIC_CLONE);
            }

            return cloneObjectValue;
        },

        /**
         * Coerces this ObjectValue to an ArrayValue
         *
         * @returns {ArrayValue}
         */
        coerceToArray: function () {
            var elements = [],
                value = this,
                factory = value.factory;

            _.forOwn(value.nonPrivateProperties, function (propertyReference) {
                elements.push(
                    new KeyValuePair(
                        factory.coerce(propertyReference.getExternalName()),
                        propertyReference.getValue()
                    )
                );
            });
            _.forOwn(value.privatePropertiesByFQCN, function (fqcnMap) {
                _.forOwn(fqcnMap, function (propertyReference) {
                    elements.push(
                        new KeyValuePair(
                            factory.coerce(propertyReference.getExternalName()),
                            propertyReference.getValue()
                        )
                    );
                });
            });

            return value.factory.createArray(elements);
        },

        coerceToBoolean: function () {
            return this.factory.createBoolean(true);
        },

        coerceToInteger: function () {
            var value = this;

            value.callStack.raiseError(
                PHPError.E_NOTICE,
                'Object of class ' + value.classObject.getName() + ' could not be converted to number'
            );

            return value.factory.createInteger(1);
        },

        /**
         * Unwraps this instance of Exception to a native JS error
         *
         * TODO: Move the Throwable check elsewhere and deprecate this method in favour of .getNative()?
         *
         * @returns {Error|*}
         */
        coerceToNativeError: function () {
            var value = this;

            // Uncaught PHP Throwables become E_FATAL errors

            if (!value.classIs('Throwable')) {
                // TODO: Change for PHP 7:
                //       "Fatal error: Uncaught Error: Can only throw objects in Command line code:1"
                //       "Fatal error: Uncaught Error: Cannot throw objects that do not implement Throwable in Command line code:1"
                //       These will probably need to be handled with transpiler-level changes,
                //       so that a throw statement becomes eg. `tools.throw(...)` as it is too late
                //       to make these checks at this point, due to the original stack/context being lost
                throw new Exception('Weird value class thrown: ' + value.getClassName());
            }

            return value.getNative();
        },

        coerceToNumber: function () {
            return this.coerceToInteger();
        },

        coerceToKey: function () {
            this.callStack.raiseError(PHPError.E_WARNING, 'Illegal offset type');
        },

        coerceToObject: function () {
            // Already an object: no coercion needed
            return this;
        },

        coerceToString: function () {
            return this.callMethod('__toString');
        },

        /**
         * Declares an instance property for this object, with the specified visibility
         *
         * @param {string} name
         * @param {Class} classObject The class in the hierarchy that defines the property
         * @param {string} visibility "private", "protected" or "public"
         * @returns {PropertyReference}
         */
        declareProperty: function (name, classObject, visibility) {
            var value = this,
                propertyReference;

            function createProperty() {
                return new PropertyReference(
                    value.factory,
                    value.callStack,
                    value,
                    value.factory.coerce(name),
                    classObject,
                    visibility,
                    value.nextPropertyIndex++
                );
            }

            if (visibility === 'private') {
                if (!value.privatePropertiesByFQCN[classObject.getName()]) {
                    value.privatePropertiesByFQCN[classObject.getName()] = {};
                }

                propertyReference = value.privatePropertiesByFQCN[classObject.getName()][name];

                if (!propertyReference) {
                    propertyReference = createProperty();

                    value.privatePropertiesByFQCN[classObject.getName()][name] = propertyReference;
                }
            } else {
                propertyReference = value.nonPrivateProperties[name];

                if (!propertyReference) {
                    propertyReference = createProperty();

                    value.nonPrivateProperties[name] = propertyReference;
                }
            }

            return propertyReference;
        },

        /**
         * Divides (the numeric coercion of) this object by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        divide: function (rightValue) {
            return rightValue.divideByObject(this);
        },

        /**
         * Divides a non-array value by this object
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByNonArray: function (leftValue) {
            // Trigger notice due to coercion
            this.coerceToInteger();

            // Objects are always cast to int(1), so divisor will always be 1
            return leftValue.coerceToNumber();
        },

        /**
         * Builds a string representation of this value
         *
         * @returns {string}
         */
        formatAsString: function () {
            return 'Object(' + this.getClassName() + ')';
        },

        /**
         * Fetches the callable name of the value this reference resolves to
         *
         * @returns {string}
         */
        getCallableName: function () {
            var value = this;

            if (value.classObject.is('Closure')) {
                return value.value.functionSpec.getFunctionName(true);
            }

            return value.getClassName() + '::__invoke()';
        },

        /**
         * Fetches the Class of this object
         *
         * @returns {Class}
         */
        getClass: function () {
            return this.classObject;
        },

        /**
         * Fetches the name of the class of this object
         *
         * @returns {string}
         */
        getClassName: function () {
            return this.classObject.getName();
        },

        /**
         * Fetches a constant for the class of this object
         *
         * @param {string} name
         * @returns {Value}
         */
        getConstantByName: function (name) {
            return this.classObject.getConstantByName(name);
        },

        /**
         * Fetches a reference to the value at the current position of the iterator.
         * Used by transpiled foreach loops over objects implementing Iterator.
         *
         * @returns {Reference}
         */
        getCurrentElementReference: function () {
            // FIXME: Should this raise a warning or something?
            //        What if the current() method is marked as return-by-reference?
            return this.getCurrentElementValue();
        },

        /**
         * Fetches the value at the current position of the iterator.
         * Used by transpiled foreach loops over objects implementing Iterator.
         *
         * @returns {Value}
         */
        getCurrentElementValue: function () {
            var value = this;

            if (!value.classIs('Iterator')) {
                throw new Exception('Object.getCurrentElementValue() :: Object does not implement Iterator');
            }

            return value.callMethod('current');
        },

        /**
         * Fetches the key for the current position of the iterator.
         * Used by transpiled foreach loops over objects implementing Iterator.
         *
         * @returns {Value}
         */
        getCurrentKey: function () {
            var value = this;

            if (!value.classIs('Iterator')) {
                throw new Exception('Object.getCurrentKey() :: Object does not implement Iterator');
            }

            return value.callMethod('key').coerceToKey();
        },

        /**
         * {@inheritdoc}
         */
        getDisplayType: function () {
            // For objects, we want to display the class FQCN and not just "object"
            return this.getClassName();
        },

        /**
         * Fetches an element of the value this reference resolves to
         *
         * @param {number} index
         * @returns {Reference}
         */
        getElementByIndex: function (index) {
            var value = this,
                names = value.getInstancePropertyNames();

            if (!hasOwn.call(names, index)) {
                value.callStack.raiseError(
                    PHPError.E_NOTICE,
                    'Undefined ' + value.referToElement(index)
                );

                return new NullReference(value.factory);
            }

            return value.getInstancePropertyByName(names[index]);
        },

        /**
         * Fetches a property of this object using the array dereference notation if its class implements ArrayAccess
         *
         * @param {*} keyValue
         * @returns {Reference}
         */
        getElementByKey: function (keyValue) {
            var value = this;

            keyValue = keyValue.coerceToKey(value.callStack);

            if (!keyValue) {
                // Could not be coerced to a key: error will already have been handled, just return NULL
                return new NullReference(value.factory);
            }

            if (value.classObject.is('ArrayAccess')) {
                return new ObjectElement(value.factory, value, keyValue);
            }

            value.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_USE_WRONG_TYPE_AS, {
                actual: value.classObject.getName(),
                expected: 'array'
            });
        },

        /**
         * Returns either the current value or one based on it as part of an assignment.
         * Objects are passed around by reference so this should just return this
         *
         * @returns {Value}
         */
        getForAssignment: function () {
            return this;
        },

        /**
         * Fetches the unique internal ID of this object. Used by eg. var_dump(...)
         *
         * @returns {number}
         */
        getID: function () {
            return this.id;
        },

        /**
         * Fetches the value of an instance property of this object
         *
         * @param {string} name
         * @returns {Value}
         */
        getProperty: function (name) {
            var value = this,
                nameValue = value.factory.createString(name);

            return value.getInstancePropertyByName(nameValue).getValue();
        },

        /**
         * Fetches an instance property of this object
         *
         * @param {Value} nameValue
         * @returns {PropertyReference}
         */
        getInstancePropertyByName: function (nameValue) {
            var callingClass,
                nameKey = nameValue.coerceToKey(),
                name = nameKey.getNative(),
                propertyReference,
                value = this,
                classInHierarchy,
                classOfObject = value.classObject;

            if (value.classObject.hasStaticPropertyByName(name)) {
                // TODO: Change for PHP 7 (see https://www.php.net/manual/en/migration70.incompatible.php)
                value.callStack.raiseError(
                    PHPError.E_STRICT,
                    'Accessing static property ' + value.classObject.getName() + '::$' + name + ' as non static'
                );

                // Allow to continue, so that a further notice will be emitted when the property is accessed
            }

            // Fetch the class that the current line of PHP code is executing inside (if any)
            callingClass = value.callStack.getCurrentClass();

            // First check whether the property is defined as private for the calling class -
            // it could also exist at different levels in the hierarchy, but the same property
            // can have different values at different levels if it is private there
            propertyReference = callingClass && value.privatePropertiesByFQCN[callingClass.getName()] ?
                value.privatePropertiesByFQCN[callingClass.getName()][name] :
                null;

            if (propertyReference) {
                // Property is private, and we're inside the class that defines it so we're good to go.
                // Private properties should be the most common, so this is the first case for speed
                return propertyReference;
            }

            propertyReference = value.nonPrivateProperties[name];

            if (propertyReference) {
                /*
                 * Property is protected; may be read from methods of this class and methods of derivatives.
                 * This case is checked before the privates-check hierarchy walk below for speed,
                 * as invalid accesses to private properties should be rare
                 */
                if (propertyReference.getVisibility() === 'protected') {
                    if (
                        !callingClass ||
                        (
                            classOfObject.getName() !== callingClass.getName() &&
                            !callingClass.isInFamilyOf(classOfObject)
                        )
                    ) {
                        value.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_ACCESS_PROPERTY, {
                            className: classOfObject.getName(),
                            propertyName: name,
                            visibility: 'protected'
                        });
                    }
                }
            } else {
                classInHierarchy = classOfObject;

                // Check whether the property is in fact defined, but is defined as private
                // for a class that is not the calling class - if so then we are not allowed to access it
                do {
                    propertyReference = value.privatePropertiesByFQCN[classInHierarchy.getName()] ?
                        value.privatePropertiesByFQCN[classInHierarchy.getName()][name] :
                        null;

                    if (propertyReference) {
                        if (callingClass && callingClass.extends(classInHierarchy)) {
                            // We're in a class that is a descendant of the one that defines the private property
                            value.callStack.raiseTranslatedError(PHPError.E_ERROR, UNDEFINED_PROPERTY, {
                                className: callingClass.getName(),
                                propertyName: name
                            });
                        } else if (callingClass && classInHierarchy !== classOfObject) {
                            // The current object is a descendant of the one that defines the private property,
                            // but we're in a class that is an ancestor of the definer -
                            // just treat the property as not defined
                            break;
                        } else {
                            // Property is private, but we're not trying to access it from inside the class
                            value.callStack.raiseTranslatedError(PHPError.E_ERROR, CANNOT_ACCESS_PROPERTY, {
                                className: classOfObject.getName(),
                                propertyName: name,
                                visibility: 'private'
                            });
                        }
                    }

                    classInHierarchy = classInHierarchy.getSuperClass();
                } while (classInHierarchy !== null);

                /*
                 * Property is not yet defined for this object by any of its class hierarchy or dynamically -
                 * define it dynamically as a public property.
                 * This is a relatively slow case as it is only done after the privates-check hierarchy walk above,
                 * but this _should_ be a rare scenario so it makes sense not to optimise for it
                 */
                propertyReference = value.declareProperty(name, value.classObject, 'public');
            }

            return propertyReference;
        },

        /**
         * Fetches the names of all visible instance properties of this object, wrapped as values
         *
         * @returns {Value[]}
         */
        getInstancePropertyNames: function () {
            var callingClass,
                nameHash = {},
                sortedNames,
                value = this;

            // Include the names of all properties of the wrapped native object
            // TODO: Move this custom logic to JSObject, called via a magic method?
            _.forOwn(value.value, function (value, name) {
                nameHash[name] = -1;
            });

            // Fetch the class that the current line of PHP code is executing inside (if any)
            callingClass = value.callStack.getCurrentClass();

            // Include the names of all private properties defined on the calling class
            if (callingClass) {
                _.forOwn(value.privatePropertiesByFQCN, function (propertyReferences, fqcn) {
                    if (fqcn === callingClass.getName()) {
                        _.forOwn(propertyReferences, function (propertyReference, propertyName) {
                            if (propertyReference.isDefined()) {
                                nameHash[propertyName] = propertyReference.getIndex();
                            }
                        });
                    }
                });
            }

            // Include all public properties and all protected properties that belong
            // to ancestor or descendant classes of the calling class
            _.forOwn(value.nonPrivateProperties, function (propertyReference, propertyName) {
                if (propertyReference.isDefined() && propertyReference.isVisible()) {
                    nameHash[propertyName] = propertyReference.getIndex();
                }
            });

            sortedNames = Object.keys(nameHash);
            sortedNames.sort(function (nameA, nameB) {
                return nameHash[nameA] - nameHash[nameB];
            });

            // Wrap all the names in Value objects before returning
            return sortedNames.map(function (name) {
                return value.factory.coerce(name);
            });
        },

        /**
         * Sets the value of an internal property for this object. Internal properties
         * have nothing to do with the native object they wrap, so this mechanism
         * is useful for native classes to store data without PHP code having access to it
         *
         * @param {string} name
         * @returns {*}
         */
        getInternalProperty: function (name) {
            var value = this;

            if (!hasOwn.call(value.internalProperties, name)) {
                throw new Error(
                    'Object of class "' + value.getClassName() + '" has no internal property "' + name + '"'
                );
            }

            return value.internalProperties[name];
        },

        /**
         * Fetches either an ArrayIterator (for a normal object)
         * or the object itself if it implements Traversable via Iterator or IteratorAggregate.
         * Used by transpiled foreach loops over objects implementing Iterator.
         *
         * @returns {ArrayIterator|ObjectValue}
         */
        getIterator: function () {
            var value = this,
                iteratorValue = value;

            value.pointer = 0;

            if (iteratorValue.classIs('IteratorAggregate')) {
                // IteratorAggregate requires its ->getIterator() method to return something iterable
                iteratorValue = iteratorValue.callMethod('getIterator');

                if (iteratorValue.getType() !== 'object' || !iteratorValue.classIs('Iterator')) {
                    throw value.factory.createTranslatedExceptionObject(
                        'Exception',
                        OBJECT_FROM_GET_ITERATOR_MUST_BE_TRAVERSABLE,
                        {
                            className: value.getClassName()
                        }
                    );
                }
            }

            if (!iteratorValue.classIs('Iterator')) {
                // Objects not implementing Traversable are iterated like arrays
                return value.factory.createArrayIterator(value);
            }

            iteratorValue.callMethod('rewind');

            return iteratorValue;
        },

        /**
         * Fetches a key (property name) of this object by its index
         *
         * @param {number} index
         * @returns {Value|null}
         */
        getKeyByIndex: function (index) {
            var value = this,
                keys = value.getInstancePropertyNames();

            return keys[index] || null;
        },

        /**
         * Fetches the length (number of properties) for this object, regardless of their visibility
         *
         * @returns {number}
         */
        getLength: function () {
            var value = this,
                // Fetch the class that the current line of PHP code is executing inside (if any)
                callingClass = value.callStack.getCurrentClass(),
                count = 0;

            // Include the names of all private properties defined on the calling class
            if (callingClass) {
                _.forOwn(value.privatePropertiesByFQCN, function (propertyReferences, fqcn) {
                    if (fqcn === callingClass.getName()) {
                        _.forOwn(propertyReferences, function (propertyReference) {
                            if (propertyReference.isDefined()) {
                                count++;
                            }
                        });
                    }
                });
            }

            // Include all public properties and all protected properties that belong
            // to ancestor or descendant classes of the calling class
            _.forOwn(value.nonPrivateProperties, function (propertyReference) {
                if (propertyReference.isDefined() && propertyReference.isVisible()) {
                    count++;
                }
            });

            return count;
        },

        /**
         * Unwraps this PHP object value to something that non-PHPCore JS code will understand.
         * Special PHP classes like Closure and stdClass are unwrapped specially
         *
         * @returns {Object|*}
         */
        getNative: function () {
            var value = this;

            return value.classObject.exportInstanceForJS(value);
        },

        /**
         * Fetches a map of all non-private property names to values
         *
         * @returns {Object.<string, Value>}
         */
        getNonPrivateProperties: function () {
            var value = this,
                propertyNamesToValues = {};

            _.forOwn(value.nonPrivateProperties, function (propertyReference, propertyName) {
                propertyNamesToValues[propertyName] = propertyReference.getValue();
            });

            return propertyNamesToValues;
        },

        /**
         * Fetches the wrapped native JS object
         *
         * @returns {object}
         */
        getObject: function () {
            return this.value;
        },

        getPointer: function () {
            return this.pointer;
        },

        /**
         * Fetches the names of all instance properties of this object
         *
         * @returns {string[]}
         */
        getPropertyNames: function () {
            return this.getInstancePropertyNames().map(function (nameValue) {
                return nameValue.getNative();
            });
        },

        /**
         * Exports a proxy object that allows JS code to call any method of this object
         * (including magic ones implemented with __call)
         *
         * @returns {PHPObject}
         */
        getProxy: function () {
            var value = this;

            return value.classObject.proxyInstanceForJS(value);
        },

        /**
         * Fetches a reference to a static property of this object's class by its name
         *
         * @param {Reference|Value} nameValue
         * @returns {StaticPropertyReference|UndeclaredStaticPropertyReference}
         */
        getStaticPropertyByName: function (nameValue) {
            return this.classObject.getStaticPropertyByName(nameValue.getNative());
        },

        /**
         * Fetches either this ObjectValue or its inner native object, based on the class' auto-coercion mode
         *
         * @returns {ObjectValue|Object}
         */
        getThisObject: function () {
            var value = this;

            return value.classObject.getThisObjectForInstance(value);
        },

        /**
         * Creates a new instance of the class of this object for a normal PHP object.
         * For a JSObject, if the wrapped object is a function then it will create
         * a new instance of the wrapped JS class instead,
         * returning the resulting new JSObject instance
         *
         * @param {Value[]} args
         * @returns {ObjectValue}
         */
        instantiate: function (args) {
            var value = this,
                nativeObject,
                objectValue,
                unwrappedArgs;

            if (value.getClassName() !== 'JSObject') {
                // A normal PHP object is being instantiated as a class -
                // we just need to create a new instance of this object's class
                return value.classObject.instantiate(args);
            }

            // A JS function is being instantiated as a class from PHP (bridge integration)

            if (!_.isFunction(value.value)) {
                throw new Error('Cannot create a new instance of a non-function JSObject');
            }

            // Unwrap the arguments to native values (as the constructor will be native JS)
            unwrappedArgs = _.map(args, function (argValue) {
                return argValue.getNative();
            });

            /**
             * Create a new instance of the native class, using bind.apply(...)
             * to support passing varargs to the constructor (and ES6+ classes).
             *
             * JS constructor functions can override the normal constructor process
             * and return a completely different object, which this will handle automatically too.
             */
            nativeObject = new (function () {}.bind.apply(value.value, [undefined].concat(unwrappedArgs)))();

            objectValue = value.factory.coerceObject(nativeObject);

            return objectValue;
        },

        /**
         * Invokes the native function this object wraps when it is an instance of Closure
         *
         * @param {Value[]} args
         * @returns {Value}
         */
        invokeClosure: function (args) {
            var closure,
                value = this;

            if (!value.classIs('Closure')) {
                throw new Error('invokeClosure() :: Value is not a Closure');
            }

            closure = value.getInternalProperty('closure');

            return closure.invoke(args);
        },

        /**
         * Determines whether the object this reference resolves to is an instance of the specified class
         *
         * @param {Reference|Value} classNameValue
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {BooleanValue}
         */
        isAnInstanceOf: function (classNameValue, namespaceOrNamespaceScope) {
            return classNameValue.isTheClassOfObject(this, namespaceOrNamespaceScope);
        },

        /**
         * {@inheritdoc}
         */
        isCallable: function () {
            var value = this;

            return value.classIs('Closure') ||
                value.isMethodDefined('__invoke');
        },

        /**
         * Objects are never classed as empty
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            return false;
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToObject(this);
        },

        isEqualToArray: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToFloat: function (floatValue) {
            return this.factory.createBoolean(floatValue.getNative() === 1);
        },

        isEqualToInteger: function (integerValue) {
            return this.factory.createBoolean(integerValue.getNative() === 1);
        },

        isEqualToNull: function () {
            return this.factory.createBoolean(false);
        },

        /**
         * Determines whether this object is equal (but not necessarily identical) to another
         *
         * @param {ObjectValue} rightValue
         * @returns {BooleanValue}
         */
        isEqualToObject: function (rightValue) {
            var equal = true,
                leftValue = this,
                factory = leftValue.factory;

            if (
                rightValue.getLength() !== leftValue.getLength() ||
                rightValue.getClassName() !== leftValue.getClassName()
            ) {
                return factory.createBoolean(false);
            }

            // Check public and protected properties
            _.forOwn(rightValue.nonPrivateProperties, function (propertyReference, propertyName) {
                if (
                    !hasOwn.call(leftValue.nonPrivateProperties, propertyName) ||
                    propertyReference.getValue().isNotEqualTo(
                        leftValue.nonPrivateProperties[propertyName].getValue()
                    ).getNative()
                ) {
                    equal = false;
                    return false;
                }
            });
            // Check private properties
            _.forOwn(rightValue.privatePropertiesByFQCN, function (propertyReferences, fqcn) {
                _.forOwn(propertyReferences, function (propertyReference, propertyName) {
                    if (
                        !hasOwn.call(leftValue.privatePropertiesByFQCN, fqcn) ||
                        !hasOwn.call(leftValue.privatePropertiesByFQCN[fqcn], propertyName) ||
                        propertyReference.getValue().isNotEqualTo(
                            leftValue.privatePropertiesByFQCN[fqcn][propertyName].getValue()
                        ).getNative()
                    ) {
                        equal = false;
                        return false;
                    }
                });
            });

            return factory.createBoolean(equal);
        },

        isEqualToString: function () {
            return this.factory.createBoolean(false);
        },

        isIdenticalTo: function (rightValue) {
            return rightValue.isIdenticalToObject(this);
        },

        isIdenticalToArray: function () {
            return this.factory.createBoolean(false);
        },

        isIdenticalToObject: function (rightValue) {
            var leftValue = this,
                factory = leftValue.factory;

            return factory.createBoolean(rightValue.value === leftValue.value);
        },

        /**
         * {@inheritdoc}
         */
        isIterable: function () {
            return this.classIs('Traversable');
        },

        /**
         * Determines whether the class of this object defines an instance or static method with the given name
         *
         * @param {string} methodName
         * @returns {boolean}
         */
        isMethodDefined: function (methodName) {
            return this.classObject.getMethodSpec(methodName) !== null;
        },

        /**
         * Determines whether this iterator has finished iterating or not.
         * Used by transpiled foreach loops over objects implementing Iterator.
         *
         * @returns {boolean}
         */
        isNotFinished: function () {
            var value = this;

            if (!value.classIs('Iterator')) {
                throw new Exception('ObjectValue.isNotFinished() :: Object does not implement Iterator');
            }

            return value.callMethod('valid').coerceToBoolean().getNative();
        },

        /**
         * Objects are never numeric: always returns false
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return false;
        },

        isTheClassOfArray: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfBoolean: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfFloat: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfInteger: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfNull: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfObject: function (leftValue) {
            var rightValue = this;

            return rightValue.factory.createBoolean(
                rightValue.classObject === leftValue.classObject ||
                    leftValue.classObject.extends(rightValue.classObject)
            );
        },

        isTheClassOfString: function () {
            return this.factory.createBoolean(false);
        },

        /**
         * Multiplies this object by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        multiply: function (rightValue) {
            return rightValue.multiplyByObject(this);
        },

        /**
         * Multiplies this object by a non-array value
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByNonArray: function (leftValue) {
            // Trigger notice due to coercion
            this.coerceToInteger();

            // Objects are always cast to int(1), so multiplier will always be 1
            return leftValue.coerceToNumber();
        },

        /**
         * Moves the internal array-like pointer to the specified property
         *
         * @param {PropertyReference} propertyReference
         */
        pointToProperty: function (propertyReference) {
            var index = 0,
                propertyName = propertyReference.getKey().getNative(),
                value = this;

            // Find the property in the set of properties visible to the current scope
            _.each(value.getInstancePropertyNames(), function (name) {
                if (name.getNative() === propertyName) {
                    value.setPointer(index);
                }

                index++;
            });
        },

        referToElement: function (key) {
            return 'property: ' + this.getClassName() + '::$' + key;
        },

        reset: function () {
            var value = this;

            value.pointer = 0;

            return value;
        },

        /**
         * Sets the value of an internal property for this object. Internal properties
         * have nothing to do with the native object they wrap, so this mechanism
         * is useful for native classes to store data without PHP code having access to it
         *
         * @param {string} name
         * @param {*} newValue
         */
        setInternalProperty: function (name, newValue) {
            this.internalProperties[name] = newValue;
        },

        setPointer: function (pointer) {
            this.pointer = pointer;
        },

        setProperty: function (name, newValue) {
            var value = this,
                nameValue = value.factory.createString(name);

            value.getInstancePropertyByName(nameValue).setValue(newValue);
        }
    });

    return ObjectValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Value/String.js":
/*!**************************************************!*\
  !*** ./node_modules/phpcore/src/Value/String.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    __webpack_require__(/*! ../Reference/Null */ "./node_modules/phpcore/src/Reference/Null.js"),
    __webpack_require__(/*! ../Value */ "./node_modules/phpcore/src/Value.js")
], function (
    _,
    phpCommon,
    util,
    NullReference,
    Value
) {
    var PHPError = phpCommon.PHPError;

    function StringValue(factory, callStack, value) {
        Value.call(this, factory, callStack, 'string', value);
    }

    util.inherits(StringValue, Value);

    _.extend(StringValue.prototype, {
        add: function (rightValue) {
            return rightValue.addToString(this);
        },

        addToBoolean: function (booleanValue) {
            return this.coerceToNumber().add(booleanValue);
        },

        /**
         * Calls a function or static method based on the contents of the string
         *
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        call: function (args, namespaceOrNamespaceScope) {
            var classNameValue,
                match,
                methodNameValue,
                value = this;

            if (value.value.indexOf('::') > -1) {
                /**
                 * Handle static method call format:
                 *
                 *     $func = 'My\Stuff\MyClass::myStaticMethod';
                 *     $func(...);
                 */
                match = value.value.match(/(.*)::(.*)/);

                classNameValue = value.factory.createString(match[1]);
                methodNameValue = value.factory.createString(match[2]);

                return classNameValue.callStaticMethod(
                    methodNameValue,
                    args,
                    namespaceOrNamespaceScope
                );
            }

            // Otherwise must just be the name of a function
            return namespaceOrNamespaceScope.getGlobalNamespace().getFunction(value.value).apply(null, args);
        },

        /**
         * Calls a static method of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Value[]} args
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @param {bool=} isForwarding eg. self::f() is forwarding, MyParentClass::f() is non-forwarding
         * @returns {Value}
         */
        callStaticMethod: function (nameValue, args, namespaceOrNamespaceScope, isForwarding) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getGlobalNamespace().getClass(value.value);

            return classObject.callMethod(nameValue.getNative(), args, null, null, null, !!isForwarding);
        },

        coerceToBoolean: function () {
            return this.factory.createBoolean(this.value !== '' && this.value !== '0');
        },

        /**
         * Coerces this string to a float value
         *
         * @returns {FloatValue}
         */
        coerceToFloat: function () {
            var value = this;

            return value.factory.createFloat(/^(\d|-[\d.])/.test(value.value) ? parseFloat(value.value) : 0);
        },

        /**
         * Coerces this string to an integer value
         *
         * @returns {IntegerValue}
         */
        coerceToInteger: function () {
            var value = this;

            return value.factory.createInteger(/^(\d|-[\d.])/.test(value.value) ? parseInt(value.value, 10) : 0);
        },

        coerceToKey: function () {
            return this;
        },

        /**
         * Coerces this string to either a FloatValue or IntegerValue, depending on its contents
         *
         * @returns {FloatValue|IntegerValue}
         */
        coerceToNumber: function () {
            var value = this,
                isFloat = /^-?\d*(\.|[eE][-+]?)\d/.test(value.value);

            if (isFloat) {
                return value.coerceToFloat();
            } else {
                return value.coerceToInteger();
            }
        },

        coerceToString: function () {
            return this;
        },

        /**
         * Divides this string by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        divide: function (rightValue) {
            return rightValue.divideByString(this);
        },

        /**
         * Divides a float by this string
         *
         * @param {FloatValue} leftValue
         * @returns {Value}
         */
        divideByFloat: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisor = rightValue.coerceToNumber().getNative();

            if (divisor === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            return rightValue.factory.createFloat(coercedLeftValue.getNative() / divisor);
        },

        /**
         * Divides a non-array value by this string
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        divideByNonArray: function (leftValue) {
            var coercedLeftValue,
                rightValue = this,
                divisorValue = rightValue.coerceToNumber(),
                quotient;

            if (divisorValue.getNative() === 0) {
                rightValue.callStack.raiseError(PHPError.E_WARNING, 'Division by zero');

                return rightValue.factory.createBoolean(false);
            }

            coercedLeftValue = leftValue.coerceToNumber();

            quotient = coercedLeftValue.getNative() / divisorValue.getNative();

            // Return result as a float if needed, otherwise keep as integer
            return Math.round(quotient) !== quotient || divisorValue.getType() === 'float' ?
                rightValue.factory.createFloat(quotient) :
                rightValue.factory.createInteger(quotient);
        },

        /**
         * Formats the string for display in stack traces etc.
         *
         * @returns {string}
         */
        formatAsString: function () {
            // To match Zend's output, simply wrap the string value in single-quotes,
            // leaving any embedded single-quotes unescaped
            var textValue = this.value;

            if (textValue.length > 15) {
                // Truncate long strings to improve readability (as per Zend's output)
                textValue = textValue.substr(0, 15) + '...';
            }

            return '\'' + textValue + '\'';
        },

        getCallableName: function () {
            // Strip any leading backslash off to normalise
            return this.value.replace(/^\\/, '');
        },

        /**
         * Fetches the value of a constant from the class this string refers to
         *
         * @param {string} name
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getConstantByName: function (name, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getGlobalNamespace().getClass(value.value);

            return classObject.getConstantByName(name);
        },

        getElementByKey: function (key) {
            var keyValue,
                value = this;

            key = key.coerceToKey(value.callStack);

            if (!key) {
                // Could not be coerced to a key: error will already have been handled, just return NULL
                return new NullReference(value.factory);
            }

            keyValue = key.getNative();

            return value.factory.createString(value.value.charAt(keyValue));
        },

        getLength: function () {
            return this.value.length;
        },

        /**
         * Fetches the value of a static property of the class this string refers to
         *
         * @param {StringValue} nameValue
         * @param {Namespace|NamespaceScope} namespaceOrNamespaceScope
         * @returns {Value}
         */
        getStaticPropertyByName: function (nameValue, namespaceOrNamespaceScope) {
            var value = this,
                classObject = namespaceOrNamespaceScope.getGlobalNamespace().getClass(value.value);

            return classObject.getStaticPropertyByName(nameValue.getNative());
        },

        /**
         * Creates an instance of the class this string contains the FQCN of
         *
         * @param {Value[]} args
         * @param {NamespaceScope} namespaceScope
         * @returns {ObjectValue}
         */
        instantiate: function (args, namespaceScope) {
            var value = this,
                classObject = namespaceScope.getGlobalNamespace().getClass(value.value);

            return classObject.instantiate(args);
        },

        isAnInstanceOf: function (classNameValue) {
            return classNameValue.isTheClassOfString(this);
        },

        /**
         * {@inheritdoc}
         */
        isCallable: function (namespaceScope) {
            // Must just be the name of a function or static method - as this is a normal string
            // and not a bareword, it should just be resolved as a FQCN
            // and not relative to the current namespace scope

            var className,
                classObject,
                globalNamespace = namespaceScope.getGlobalNamespace(),
                match,
                methodName,
                value = this;

            if (value.value.indexOf('::') > -1) {
                /**
                 * Handle static method call format:
                 *
                 *     $func = 'My\Stuff\MyClass::myStaticMethod';
                 *     $func(...);
                 */
                match = value.value.match(/(.*)::(.*)/);

                className = match[1];
                methodName = match[2];

                if (!globalNamespace.hasClass(className)) {
                    return false;
                }

                classObject = globalNamespace.getClass(className);

                return classObject.getMethodSpec(methodName) !== null;
            }

            return globalNamespace.hasFunction(value.value);
        },

        /**
         * Determines whether this value is classed as "empty" or not
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            var value = this;

            // NB: string("0.0") is _not_ classed as empty
            return value.value === '' || value.value === '0';
        },

        isEqualTo: function (rightValue) {
            return rightValue.isEqualToString(this);
        },

        isEqualToNull: function () {
            var value = this;

            return value.factory.createBoolean(value.getNative() === '');
        },

        isEqualToObject: function () {
            return this.factory.createBoolean(false);
        },

        isEqualToString: function (rightValue) {
            var leftValue = this;

            return leftValue.factory.createBoolean(leftValue.value === rightValue.value);
        },

        /**
         * {@inheritdoc}
         */
        isIterable: function () {
            return false;
        },

        /**
         * Returns true if the string is numeric, false otherwise
         *
         * @returns {boolean}
         */
        isNumeric: function () {
            return /(\d+(\.)?)?\d+([Ee][+-]\d+)?/.test(this.value);
        },

        isTheClassOfArray: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfBoolean: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfFloat: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfInteger: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfNull: function () {
            return this.factory.createBoolean(false);
        },

        isTheClassOfObject: function (objectValue) {
            var rightValue = this;

            return rightValue.factory.createBoolean(
                objectValue.classIs(rightValue.value)
            );
        },

        isTheClassOfString: function () {
            return this.factory.createBoolean(false);
        },

        /**
         * Multiplies this string by another value
         *
         * @param {Value} rightValue
         * @returns {Value}
         */
        multiply: function (rightValue) {
            return rightValue.multiplyByString(this);
        },

        /**
         * Multiplies a float by this string
         *
         * @param {FloatValue} leftValue
         * @returns {Value}
         */
        multiplyByFloat: function (leftValue) {
            var coercedMultiplicandValue = leftValue.coerceToNumber(),
                rightValue = this,
                multiplier = rightValue.coerceToNumber().getNative();

            return rightValue.factory.createFloat(coercedMultiplicandValue.getNative() * multiplier);
        },

        /**
         * Multiplies a non-array value by this string
         *
         * @param {Value} leftValue
         * @returns {Value}
         */
        multiplyByNonArray: function (leftValue) {
            var coercedMultiplicandValue = leftValue.coerceToNumber(),
                rightValue = this,
                coercedMultiplierValue = rightValue.coerceToNumber(),
                product = coercedMultiplicandValue.getNative() * coercedMultiplierValue.getNative();

            // Return result as a float if either coerced operand is a float, otherwise keep as integer
            return coercedMultiplicandValue.getType() === 'float' || coercedMultiplierValue.getType() === 'float' ?
                rightValue.factory.createFloat(product) :
                rightValue.factory.createInteger(product);
        },

        onesComplement: function () {
            return this.factory.createString('?');
        }
    });

    return StringValue;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/ValueFactory.js":
/*!**************************************************!*\
  !*** ./node_modules/phpcore/src/ValueFactory.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! is-promise */ "./node_modules/is-promise/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ./Iterator/ArrayIterator */ "./node_modules/phpcore/src/Iterator/ArrayIterator.js"),
    __webpack_require__(/*! ./Value/Array */ "./node_modules/phpcore/src/Value/Array.js"),
    __webpack_require__(/*! ./Value/BarewordString */ "./node_modules/phpcore/src/Value/BarewordString.js"),
    __webpack_require__(/*! ./Value/Boolean */ "./node_modules/phpcore/src/Value/Boolean.js"),
    __webpack_require__(/*! ./Reference/Element/ElementProvider */ "./node_modules/phpcore/src/Reference/Element/ElementProvider.js"),
    __webpack_require__(/*! ./Value/Exit */ "./node_modules/phpcore/src/Value/Exit.js"),
    __webpack_require__(/*! ./FFI/Result */ "./node_modules/phpcore/src/FFI/Result.js"),
    __webpack_require__(/*! ./Value/Float */ "./node_modules/phpcore/src/Value/Float.js"),
    __webpack_require__(/*! ./Value/Integer */ "./node_modules/phpcore/src/Value/Integer.js"),
    __webpack_require__(/*! ./KeyValuePair */ "./node_modules/phpcore/src/KeyValuePair.js"),
    __webpack_require__(/*! ./Value/Null */ "./node_modules/phpcore/src/Value/Null.js"),
    __webpack_require__(/*! ./Value/Object */ "./node_modules/phpcore/src/Value/Object.js"),
    __webpack_require__(/*! ./FFI/Value/PHPObject */ "./node_modules/phpcore/src/FFI/Value/PHPObject.js"),
    __webpack_require__(/*! ./Value/String */ "./node_modules/phpcore/src/Value/String.js"),
    __webpack_require__(/*! ./Value */ "./node_modules/phpcore/src/Value.js"),
    __webpack_require__(/*! ./FFI/Value/ValueStorage */ "./node_modules/phpcore/src/FFI/Value/ValueStorage.js")
], function (
    _,
    isPromise,
    phpCommon,
    ArrayIterator,
    ArrayValue,
    BarewordStringValue,
    BooleanValue,
    ElementProvider,
    ExitValue,
    FFIResult,
    FloatValue,
    IntegerValue,
    KeyValuePair,
    NullValue,
    ObjectValue,
    PHPObject,
    StringValue,
    Value,
    ValueStorage
) {
    var Exception = phpCommon.Exception;

    /**
     * Creates Value and related objects
     *
     * @param {Resumable|null} pausable
     * @param {string} mode
     * @param {ElementProvider} elementProvider
     * @param {Translator} translator
     * @param {CallFactory} callFactory
     * @param {ErrorPromoter} errorPromoter
     * @param {ValueStorage} valueStorage
     * @constructor
     */
    function ValueFactory(
        pausable,
        mode,
        elementProvider,
        translator,
        callFactory,
        errorPromoter,
        valueStorage
    ) {
        /**
         * @type {CallFactory}
         */
        this.callFactory = callFactory;
        /**
         * @type {ElementProvider}
         */
        this.elementProvider = elementProvider || new ElementProvider();
        /**
         * Used for generating a unique ID for the next ObjectValue that is created
         * (shown in the output of var_dump(...), for example)
         *
         * @type {number}
         */
        this.nextObjectID = 1;
        /**
         * @type {CallStack|null}
         */
        this.callStack = null;
        /**
         * @type {ErrorPromoter}
         */
        this.errorPromoter = errorPromoter;
        /**
         * @type {Namespace|null}
         */
        this.globalNamespace = null;
        /**
         * @type {string}
         */
        this.mode = mode;
        /**
         * The single NullValue for efficiency, created lazily in .createNull(...).
         * It must be created lazily there as it depends on CallStack, which due to a circular dependency
         * is injected via setter: .setCallStack(...). That setter is not always called, eg. by various unit tests,
         * for simplicity.
         *
         * @type {NullValue|null}
         */
        this.nullValue = null;
        /**
         * @type {Resumable|null}
         */
        this.pausable = pausable;
        /**
         * @type {Translator}
         */
        this.translator = translator;
        /**
         * @type {ValueStorage}
         */
        this.valueStorage = valueStorage || new ValueStorage();
    }

    _.extend(ValueFactory.prototype, {
        /**
         * Attempts to resolve the given value to a Value object instance.
         * - If already a Value instance, simply returns it.
         * - If an FFIResult, it is handled as appropriate (pausing PHP execution if in async mode)
         * - If any other primitive or object, it is coerced to a Value instance
         *
         * @param {*} value
         * @return {Value}
         */
        coerce: function (value) {
            var factory = this;

            if (value instanceof Value) {
                return value;
            }

            if (value instanceof FFIResult) {
                // An FFI Result was returned, so we need to handle it as appropriate
                return value.resolve(factory);
            }

            // TODO: Consider removing this behaviour altogether now that we have FFIResult?
            if (isPromise(value) && factory.pausable) {
                // A promise was returned (note that returning an FFIResult is preferred)
                return this.coercePromise(value);
            }

            return factory.createFromNative(value);
        },

        /**
         * Coerces the given array-like of natives and/or values
         * into an array where all have been coerced to values
         *
         * @param {*[]} arrayLike
         * @returns {Value[]}
         */
        coerceList: function (arrayLike) {
            var coercedValues = [],
                factory = this;

            _.each(arrayLike, function (element) {
                coercedValues.push(factory.coerce(element));
            });

            return coercedValues;
        },

        /**
         * Coerces a JavaScript object to a PHP object instance of the special JSObject class
         *
         * @param {Object|Value} value
         * @return {ObjectValue|Value}
         * @throws {Error} Throws when a value other than an ObjectValue instance, null or undefined is given
         */
        coerceObject: function (value) {
            var factory = this;

            if (value instanceof Value) {
                if (value.getType() !== 'object') {
                    throw new Exception('Tried to coerce a Value of type "' + value.getType() + '" to object');
                }

                return value;
            }

            if (value === null || typeof value === 'undefined') {
                return factory.createNull();
            }

            if (typeof value !== 'object') {
                throw new Error('Only objects, null or undefined may be coerced to an object');
            }

            return factory.createObject(value, factory.globalNamespace.getClass('JSObject'));
        },

        /**
         * Awaits a promise (in async mode). Throws if in psync or sync mode
         *
         * @param {Promise} promise
         * @returns {Value}
         */
        coercePromise: function (promise) {
            var factory = this,
                pause;

            if (!factory.pausable) {
                throw new Exception('Cannot await a promise in non-async mode');
            }

            pause = factory.pausable.createPause();

            // Wait for the returned promise to resolve or reject before continuing
            promise.then(function (resultValue) {
                // Remember we still need to coerce the result
                pause.resume(factory.coerce(resultValue));
            }, function (error) {
                pause.throw(error);
            });

            return pause.now();
        },

        /**
         * Creates a PHP ArrayValue. A custom element provider may optionally be provided,
         * if special elements are required (for example, HookableElements, which are used
         * by the special $GLOBALS superglobal for two-way binding to global variables)
         *
         * @param {Array} value
         * @param {ElementProvider|HookableElementProvider=} elementProvider
         * @return {ArrayValue}
         */
        createArray: function (value, elementProvider) {
            var factory = this;

            return new ArrayValue(
                factory,
                factory.callStack,
                value,
                null,
                elementProvider || factory.elementProvider
            );
        },

        /**
         * Creates an ArrayIterator
         *
         * @param {ArrayValue|ObjectValue} arrayLikeValue
         * @returns {ArrayIterator}
         */
        createArrayIterator: function (arrayLikeValue) {
            return new ArrayIterator(arrayLikeValue);
        },

        /**
         * Creates a BarewordStringValue
         *
         * @param {string} value
         * @return {BarewordStringValue}
         */
        createBarewordString: function (value) {
            var factory = this;

            return new BarewordStringValue(factory, factory.callStack, value);
        },

        /**
         * Creates a BooleanValue
         *
         * TODO: Consider having only two instances of BooleanValue, one for true and one for false,
         *       to save on memory usage
         *
         * @param {boolean} value
         * @return {BooleanValue}
         */
        createBoolean: function (value) {
            var factory = this;

            return new BooleanValue(factory, factory.callStack, value);
        },

        /**
         * Instantiates a PHP Closure instance with the given internal closure object
         *
         * @param {Closure} closure Internal closure object
         * @return {ObjectValue}
         */
        createClosureObject: function (closure) {
            var factory = this,
                closureClass = factory.globalNamespace.getClass('Closure');

            return closureClass.instantiateWithInternals([], {
                'closure': closure
            });
        },

        /**
         * Creates an ObjectValue wrapping a PHP Error instance (eg. a call to an undefined method)
         *
         * @param {string} className eg. Error, ParseError, DivisionByZeroError
         * @param {string|null=} message
         * @param {number|null=} code
         * @param {ObjectValue|null=} previousThrowable
         * @param {string=} filePath To override the file path
         * @param {number=} lineNumber To override the line number
         * @param {boolean=} reportsOwnContext Whether the error handles reporting its own file/line context
         * @returns {ObjectValue}
         */
        createErrorObject: function (
            className,
            message,
            code,
            previousThrowable,
            filePath,
            lineNumber,
            reportsOwnContext
        ) {
            var factory = this,
                errorObject = factory.globalNamespace.getClass(className).instantiate([
                    factory.createString(message || ''),
                    factory.createInteger(code || 0),
                    previousThrowable || factory.createNull()
                ]);

            if (reportsOwnContext) {
                errorObject.setInternalProperty('reportsOwnContext', true);
            }

            // File and line cannot be passed as constructor args,
            // so we need to manually set them here if specified

            if (filePath !== null && filePath !== undefined) {
                errorObject.setProperty('file', factory.createString(filePath));
            }

            if (lineNumber !== null && lineNumber !== undefined) {
                errorObject.setProperty('line', factory.createInteger(lineNumber));
            }

            return errorObject;
        },

        /**
         * Creates an ExitValue. This is a special type of value only returned as the result
         * of an `exit;` or `die;` statement being executed from PHP
         *
         * @param {Value} statusValue
         * @return {ExitValue}
         */
        createExit: function (statusValue) {
            var factory = this;

            return new ExitValue(factory, factory.callStack, statusValue);
        },

        /**
         * Creates a FloatValue
         *
         * @param {number} value
         * @return {FloatValue}
         */
        createFloat: function (value) {
            var factory = this;

            return new FloatValue(factory, factory.callStack, value);
        },

        /**
         * Coerces a native JavaScript value to a suitable *Value object,
         * based on its type. For example, a string primitive value from JS
         * will be coerced to a StringValue instance for PHP
         *
         * @param {*} nativeValue
         * @returns {Value}
         */
        createFromNative: function (nativeValue) {
            var factory = this;

            if (nativeValue === null || typeof nativeValue === 'undefined') {
                return factory.createNull();
            }

            if (_.isString(nativeValue)) {
                return factory.createString(nativeValue);
            }

            if (_.isNumber(nativeValue)) {
                return factory.createInteger(nativeValue);
            }

            if (_.isBoolean(nativeValue)) {
                return factory.createBoolean(nativeValue);
            }

            if (_.isArray(nativeValue)) {
                return factory.createFromNativeArray(nativeValue);
            }

            return factory.createFromNativeObject(nativeValue);
        },

        /**
         * Coerces a native JavaScript object to either an ArrayValue or ObjectValue object,
         * depending on its suitability to be cast as an associative array
         *
         * @param {object} nativeObject
         * @returns {ArrayValue|ObjectValue}
         */
        createFromNativeObject: function (nativeObject) {
            var factory = this,
                hasAMethod = false,
                orderedElements = [];

            if (nativeObject instanceof PHPObject) {
                // PHPObjects wrap instances of PHP classes when exported with .getProxy()
                return nativeObject.getObjectValue();
            }

            if (factory.valueStorage.hasObjectValueForExport(nativeObject)) {
                // Objects exported with .getNative() are mapped back to their original ObjectValue
                return factory.valueStorage.getObjectValueForExport(nativeObject);
            }

            // Handle plain objects -> associative arrays
            if (Object.getPrototypeOf(nativeObject) === Object.prototype) {
                _.forOwn(nativeObject, function (value) {
                    if (_.isFunction(value)) {
                        hasAMethod = true;
                        return false;
                    }
                });

                if (!hasAMethod) {
                    // Plain object has no methods: can be safely cast to an associative array
                    _.forOwn(nativeObject, function (value, key) {
                        orderedElements.push(new KeyValuePair(factory.coerce(key), factory.coerce(value)));
                    });

                    return factory.createArray(orderedElements);
                }

                // Plain object, but has methods: needs to be cast to a JSObject
            }

            return factory.createObject(nativeObject, factory.globalNamespace.getClass('JSObject'));
        },

        /**
         * Takes a native Array object and converts it to a wrapped ArrayValue for PHP
         *
         * @param {Array} nativeArray
         * @returns {ArrayValue}
         */
        createFromNativeArray: function (nativeArray) {
            var factory = this,
                orderedElements = [];

            _.each(nativeArray, function (value, index) {
                orderedElements[index] = value;
            });

            _.forOwn(nativeArray, function (value, key) {
                if (!isFinite(key) || key >= nativeArray.length) {
                    orderedElements.push(new KeyValuePair(factory.coerce(key), factory.coerce(value)));
                }
            });

            return factory.createArray(orderedElements);
        },

        /**
         * Creates an IntegerValue
         *
         * @param {number} value
         * @return {IntegerValue}
         */
        createInteger: function (value) {
            var factory = this;

            return new IntegerValue(factory, factory.callStack, value);
        },

        /**
         * Creates a NullValue
         *
         * Note that there is only ever a single instance of NullValue to save on memory usage.
         *
         * @return {NullValue}
         */
        createNull: function () {
            var factory = this;

            if (factory.nullValue === null) {
                factory.nullValue = new NullValue(factory, factory.callStack);
            }

            return factory.nullValue;
        },

        /**
         * Creates an ObjectValue for a given native value and class
         *
         * @param {object} nativeValue
         * @param {Class} classObject
         * @returns {ObjectValue}
         */
        createObject: function (nativeValue, classObject) {
            var factory = this;

            // Object ID tracking is incomplete: ID should be freed when all references are lost
            return new ObjectValue(
                factory,
                factory.callStack,
                factory.translator,
                nativeValue,
                classObject,
                factory.nextObjectID++
            );
        },

        /**
         * Creates an instance of the builtin stdClass class
         *
         * @return {ObjectValue}
         */
        createStdClassObject: function () {
            var factory = this;

            return factory.globalNamespace.getClass('stdClass').instantiate();
        },

        /**
         * Creates a StringValue
         *
         * @param {string} value
         * @return {StringValue}
         */
        createString: function (value) {
            var factory = this;

            return new StringValue(factory, factory.callStack, value);
        },

        /**
         * Creates an ObjectValue wrapping a PHP Error instance (eg. a call to an undefined method)
         *
         * @param {string} className eg. Error, ParseError, DivisionByZeroError
         * @param {string} translationKey
         * @param {Object.<string, string>=} placeholderVariables
         * @param {number|null=} code
         * @param {ObjectValue|null=} previousThrowable
         * @param {string=} filePath To override the file path
         * @param {number=} lineNumber To override the line number
         * @returns {ObjectValue}
         */
        createTranslatedErrorObject: function (
            className,
            translationKey,
            placeholderVariables,
            code,
            previousThrowable,
            filePath,
            lineNumber
        ) {
            var factory = this,
                message = factory.translator.translate(translationKey, placeholderVariables);

            return factory.createErrorObject(
                className,
                message,
                code,
                previousThrowable,
                filePath,
                lineNumber
            );
        },

        /**
         * Creates an ObjectValue wrapping a PHP Exception instance (eg. a RuntimeException)
         *
         * @param {string} className eg. Exception, LogicException, RuntimeException
         * @param {string} translationKey
         * @param {Object.<string, string>=} placeholderVariables
         * @param {number|null=} code
         * @param {ObjectValue|null=} previousThrowable
         * @returns {ObjectValue}
         */
        createTranslatedExceptionObject: function (
            className,
            translationKey,
            placeholderVariables,
            code,
            previousThrowable
        ) {
            var factory = this,
                message = factory.translator.translate(translationKey, placeholderVariables);

            return factory.instantiateObject(
                className,
                [
                    message,
                    code,
                    previousThrowable
                ]
            );
        },

        /**
         * Creates an ObjectValue instance of the specified class
         *
         * @param {string} className
         * @param {Array} constructorArgNatives
         * @returns {ObjectValue}
         */
        instantiateObject: function (className, constructorArgNatives) {
            var factory = this,
                constructorArgValues = _.map(constructorArgNatives, function (argNative) {
                    return factory.coerce(argNative);
                });

            return factory.globalNamespace.getClass(className).instantiate(constructorArgValues);
        },

        /**
         * Determines whether the given object is a PHP Value instance
         *
         * @param {Object} object
         * @return {boolean}
         */
        isValue: function (object) {
            return object instanceof Value;
        },

        /**
         * Sets the CallStack to use for created value objects
         *
         * @param {CallStack} callStack
         */
        setCallStack: function (callStack) {
            this.callStack = callStack;
        },

        /**
         * Sets the root/global namespace
         *
         * @param {Namespace} globalNamespace
         */
        setGlobalNamespace: function (globalNamespace) {
            this.globalNamespace = globalNamespace;
        }
    });

    return ValueFactory;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/Variable.js":
/*!**********************************************!*\
  !*** ./node_modules/phpcore/src/Variable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    __webpack_require__(/*! ./Reference/ReferenceSlot */ "./node_modules/phpcore/src/Reference/ReferenceSlot.js")
], function (
    _,
    phpCommon,
    ReferenceSlot
) {
    var USED_THIS_OUTSIDE_OBJECT_CONTEXT = 'core.used_this_outside_object_context',
        PHPError = phpCommon.PHPError;

    /**
     * Variables can either hold a value directly or hold a pointer
     * to a reference (an array element, object instance property or static class property etc.)
     *
     * @param {CallStack} callStack
     * @param {ValueFactory} valueFactory
     * @param {string} name
     * @constructor
     */
    function Variable(callStack, valueFactory, name) {
        /**
         * @type {string}
         */
        this.name = name;
        /**
         * @type {Reference|null}
         */
        this.reference = null;
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {Value|null}
         */
        this.value = null;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
    }

    _.extend(Variable.prototype, {
        /**
         * Coerces this value and the specified one to strings,
         * concatenates them together and then assigns the result back to this variable
         *
         * @param {Value} rightValue
         */
        concatWith: function (rightValue) {
            var variable = this;

            variable.setValue(variable.getValue().concat(rightValue));
        },

        decrementBy: function (rightValue) {
            var variable = this;

            variable.setValue(variable.getValue().subtract(rightValue));
        },

        /**
         * Divides the value of this variable by the specified value
         *
         * Used by the `/=` operator
         *
         * @param {Value} rightValue
         */
        divideBy: function (rightValue) {
            var variable = this;

            variable.setValue(variable.getValue().divide(rightValue));
        },

        /**
         * Formats the variable (which may not be defined) for display in stack traces etc.
         *
         * @returns {string}
         */
        formatAsString: function () {
            var variable = this;

            return variable.isDefined() ?
                variable.getValue().formatAsString() :
                'NULL';
        },

        /**
         * Fetches a property of an object stored in this variable
         *
         * @param {Value} nameValue
         * @returns {PropertyReference}
         */
        getInstancePropertyByName: function (nameValue) {
            var variable = this;

            if (variable.name === 'this' && variable.value === null) {
                variable.callStack.raiseTranslatedError(PHPError.E_ERROR, USED_THIS_OUTSIDE_OBJECT_CONTEXT);
            }

            return variable.getValue().getInstancePropertyByName(nameValue);
        },

        /**
         * Fetches the name of this variable, which must be unique within its scope
         *
         * @returns {string}
         */
        getName: function () {
            return this.name;
        },

        /**
         * Fetches the value of this variable. If it holds a value directly
         * this will be returned, otherwise if it is a reference to another
         * variable or reference (array element/object property etc.)
         * then the value of the reference will be fetched
         *
         * @returns {Value}
         */
        getValue: function () {
            var variable = this;

            if (variable.value) {
                return variable.value;
            }

            if (variable.reference) {
                return variable.reference.getValue();
            }

            if (variable.name === 'this') {
                variable.callStack.raiseTranslatedError(PHPError.E_ERROR, USED_THIS_OUTSIDE_OBJECT_CONTEXT);
            }

            variable.callStack.raiseError(PHPError.E_NOTICE, 'Undefined variable: ' + variable.name);

            return variable.valueFactory.createNull();
        },

        /**
         * Returns this variable's value if defined, NULL otherwise.
         * No notice/warning will be raised if the variable has no value defined.
         *
         * @return {Value}
         */
        getValueOrNull: function () {
            var variable = this;

            return variable.isDefined() ?
                variable.getValue() :
                variable.valueFactory.createNull();
        },

        getNative: function () {
            return this.getValue().getNative();
        },

        /**
         * Fetches a reference to this variable's value
         *
         * @returns {Reference}
         */
        getReference: function () {
            var variable = this;

            if (variable.reference) {
                // This variable already refers to something else, so return its target
                return variable.reference;
            }

            // Implicitly define a "slot" to contain this variable's value
            variable.reference = new ReferenceSlot(variable.valueFactory);

            if (variable.value) {
                variable.reference.setValue(variable.value);
                variable.value = null; // This variable now has a reference (to the slot) and not a value
            }

            return variable.reference;
        },

        incrementBy: function (rightValue) {
            var variable = this;

            variable.setValue(variable.getValue().add(rightValue));
        },

        /**
         * Determines whether this variable is defined,
         * either with a value directly assigned or by being
         * a reference to another variable/reference
         *
         * @returns {boolean}
         */
        isDefined: function () {
            var variable = this;

            return !!(variable.value || variable.reference);
        },

        /**
         * Determines whether this variable is classed as "empty" or not
         *
         * @returns {boolean}
         */
        isEmpty: function () {
            var variable = this;

            return !variable.isDefined() || variable.getValue().isEmpty();
        },

        /**
         * Determines whether this variable is classed as "set" or not
         *
         * @returns {boolean}
         */
        isSet: function () {
            var variable = this;

            return variable.isDefined() && variable.getValue().isSet();
        },

        /**
         * Multiplies the value of this variable by the specified value
         *
         * Used by the `*=` operator
         *
         * @param {Value} rightValue
         */
        multiplyBy: function (rightValue) {
            var variable = this;

            variable.setValue(variable.getValue().multiply(rightValue));
        },

        /**
         * Decrements the stored value, returning its original value
         *
         * @returns {Value}
         */
        postDecrement: function () {
            var variable = this,
                decrementedValue = variable.getValue().decrement(),
                result = variable.getValue();

            if (decrementedValue) {
                variable.setValue(decrementedValue);
            }

            return result;
        },

        /**
         * Decrements the stored value, returning its new value
         *
         * @returns {Value}
         */
        preDecrement: function () {
            var variable = this,
                decrementedValue = variable.getValue().decrement();

            if (decrementedValue) {
                variable.setValue(decrementedValue);
            }

            return variable.getValue();
        },

        /**
         * Increments the stored value, returning its original value
         *
         * @returns {Value}
         */
        postIncrement: function () {
            var variable = this,
                incrementedValue = variable.getValue().increment(),
                result = variable.getValue();

            if (incrementedValue) {
                variable.setValue(incrementedValue);
            }

            return result;
        },

        /**
         * Increments the stored value, returning its new value
         *
         * @returns {Value}
         */
        preIncrement: function () {
            var variable = this,
                incrementedValue = variable.getValue().increment();

            if (incrementedValue) {
                variable.setValue(incrementedValue);
            }

            return variable.getValue();
        },

        /**
         * Sets either the value or the reference of this variable depending on the argument provided
         *
         * @param {Reference|Value|Variable} referenceOrValue
         */
        setReferenceOrValue: function (referenceOrValue) {
            var variable = this;

            if (variable.valueFactory.isValue(referenceOrValue)) {
                variable.setValue(referenceOrValue);
            } else {
                variable.setReference(referenceOrValue.getReference());
            }
        },

        /**
         * Sets the value of this variable. If it holds a value directly
         * this will be overwritten, otherwise if it is a reference to another
         * variable or reference (array element/object property etc.)
         * then the value of the reference will be changed instead.
         * Returns the value that was assigned
         *
         * @param {Reference|Value} value
         * @returns {Value}
         */
        setValue: function (value) {
            var variable = this;

            if (variable.name === 'this' && value.getType() === 'null') {
                // Normalise the value of $this to either be set to an ObjectValue
                // or be unset
                variable.value = null;

                return value;
            }

            if (variable.reference) {
                variable.reference.setValue(value);
            } else {
                variable.value = value.getForAssignment();
            }

            return value;
        },

        setReference: function (reference) {
            var variable = this;

            variable.reference = reference;
            variable.value = null;

            return variable;
        },

        toArray: function () {
            return this.value.toArray();
        },

        toBoolean: function () {
            return this.value.toBoolean();
        },

        toFloat: function () {
            return this.value.toFloat();
        },

        toInteger: function () {
            return this.value.toInteger();
        },

        unset: function () {
            var variable = this;

            variable.value = variable.reference = null;
        }
    });

    return Variable;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/VariableFactory.js":
/*!*****************************************************!*\
  !*** ./node_modules/phpcore/src/VariableFactory.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js")
], function (
    _
) {
    /**
     * @param {class} Variable
     * @param {CallStack} callStack
     * @param {ValueFactory} valueFactory
     * @constructor
     */
    function VariableFactory(
        Variable,
        callStack,
        valueFactory
    ) {
        /**
         * @type {CallStack}
         */
        this.callStack = callStack;
        /**
         * @type {ValueFactory}
         */
        this.valueFactory = valueFactory;
        /**
         * @type {class}
         */
        this.Variable = Variable;
    }

    _.extend(VariableFactory.prototype, {
        /**
         * Creates a new Variable
         *
         * @param {string} variableName
         * @returns {Variable}
         */
        createVariable: function (variableName) {
            var factory = this;

            return new factory.Variable(factory.callStack, factory.valueFactory, variableName);
        }
    });

    return VariableFactory;
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/builtins.js":
/*!******************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/builtins.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! ./functions/optionsAndInfo/config */ "./node_modules/phpcore/src/builtin/functions/optionsAndInfo/config.js"),
    __webpack_require__(/*! ./constants/errorHandling */ "./node_modules/phpcore/src/builtin/constants/errorHandling.js"),
    __webpack_require__(/*! ./ini/errorHandling */ "./node_modules/phpcore/src/builtin/ini/errorHandling.js"),
    __webpack_require__(/*! ./messages/error.en_GB */ "./node_modules/phpcore/src/builtin/messages/error.en_GB.js"),
    __webpack_require__(/*! ./messages/misc.en_GB */ "./node_modules/phpcore/src/builtin/messages/misc.en_GB.js"),
    __webpack_require__(/*! ./messages/notice.en_GB */ "./node_modules/phpcore/src/builtin/messages/notice.en_GB.js"),
    __webpack_require__(/*! ./constants/reserved */ "./node_modules/phpcore/src/builtin/constants/reserved.js"),
    __webpack_require__(/*! ./functions/spl */ "./node_modules/phpcore/src/builtin/functions/spl.js"),
    __webpack_require__(/*! ./classes/stdClass */ "./node_modules/phpcore/src/builtin/classes/stdClass.js"),
    __webpack_require__(/*! ./classes/Error/ArgumentCountError */ "./node_modules/phpcore/src/builtin/classes/Error/ArgumentCountError.js"),
    __webpack_require__(/*! ./interfaces/ArrayAccess */ "./node_modules/phpcore/src/builtin/interfaces/ArrayAccess.js"),
    __webpack_require__(/*! ./classes/Closure */ "./node_modules/phpcore/src/builtin/classes/Closure.js"),
    __webpack_require__(/*! ./classes/Error/CompileError */ "./node_modules/phpcore/src/builtin/classes/Error/CompileError.js"),
    __webpack_require__(/*! ./classes/Error */ "./node_modules/phpcore/src/builtin/classes/Error.js"),
    __webpack_require__(/*! ./classes/Exception */ "./node_modules/phpcore/src/builtin/classes/Exception.js"),
    __webpack_require__(/*! ./interfaces/Iterator */ "./node_modules/phpcore/src/builtin/interfaces/Iterator.js"),
    __webpack_require__(/*! ./interfaces/IteratorAggregate */ "./node_modules/phpcore/src/builtin/interfaces/IteratorAggregate.js"),
    __webpack_require__(/*! ./classes/JSObject */ "./node_modules/phpcore/src/builtin/classes/JSObject.js"),
    __webpack_require__(/*! ./classes/Error/ParseError */ "./node_modules/phpcore/src/builtin/classes/Error/ParseError.js"),
    __webpack_require__(/*! ./interfaces/Throwable */ "./node_modules/phpcore/src/builtin/interfaces/Throwable.js"),
    __webpack_require__(/*! ./interfaces/Traversable */ "./node_modules/phpcore/src/builtin/interfaces/Traversable.js"),
    __webpack_require__(/*! ./classes/Error/TypeError */ "./node_modules/phpcore/src/builtin/classes/Error/TypeError.js")
], function (
    configOptionsAndInfoFunctions,
    errorHandlingConstants,
    errorHandlingDefaultINIOptions,
    errorMessages,
    miscellaneousMessages,
    noticeMessages,
    reservedConstants,
    splFunctions,
    stdClass,
    ArgumentCountError,
    ArrayAccess,
    Closure,
    CompileError,
    Error,
    Exception,
    Iterator,
    IteratorAggregate,
    JSObject,
    ParseError,
    Throwable,
    Traversable,
    TypeError
) {
    return {
        classes: [
            {'stdClass': stdClass},
            {'ArrayAccess': ArrayAccess},
            {'Closure': Closure},
            {'Throwable': Throwable},
            {'Error': Error},
            {'CompileError': CompileError},
            {'ParseError': ParseError},
            {'TypeError': TypeError},
            {'ArgumentCountError': ArgumentCountError},
            {'Exception': Exception},
            {'Iterator': Iterator},
            {'IteratorAggregate': IteratorAggregate},
            {'JSObject': JSObject},
            {'Traversable': Traversable}
        ],
        constantGroups: [
            errorHandlingConstants,
            reservedConstants
        ],
        functionGroups: [
            configOptionsAndInfoFunctions,
            splFunctions
        ],
        defaultINIGroups: [
            errorHandlingDefaultINIOptions
        ],
        translationCatalogues: [
            errorMessages,
            noticeMessages,
            miscellaneousMessages
        ]
    };
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/Closure.js":
/*!*************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/Closure.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    PHPError = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js").PHPError,
    Promise = __webpack_require__(/*! lie */ "./node_modules/lie/lib/browser.js");

module.exports = function (internals) {
    var callFactory = internals.callFactory,
        callStack = internals.callStack,
        createStaticMethod = function (method) {
            method.isStatic = true;

            return method;
        },
        errorPromoter = internals.errorPromoter,
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    /**
     * Class used to represent anonymous functions or "closures"
     *
     * @see {@link https://secure.php.net/manual/en/class.closure.php}
     * @see {@link https://secure.php.net/manual/en/closure.construct.php}
     *
     * @constructor
     */
    function Closure() {

    }

    _.extend(Closure.prototype, {
        /**
         * Duplicates a closure with a specific bound object and class scope
         *
         * @see {@link https://secure.php.net/manual/en/closure.bind.php}
         *
         * @param {ObjectValue|Variable} closureReference
         * @param {ObjectValue|Variable|undefined} newThisReference
         * @param {StringValue|Variable|undefined} newScopeReference
         */
        'bind': createStaticMethod(function (closureReference, newThisReference, newScopeReference) {
            var closureValue,
                newScopeValue,
                newThisValue,
                scopeClass,
                scopeClassName;

            if (!closureReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects at least 2 parameters, 0 given'
                );
                return valueFactory.createNull();
            }

            if (!newThisReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects at least 2 parameters, 1 given'
                );
                return valueFactory.createNull();
            }

            closureValue = closureReference.getValue();

            if (closureValue.getType() !== 'object' || !closureValue.classIs('Closure')) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects parameter 1 to be Closure, ' + closureValue.getType() + ' given'
                );
                return valueFactory.createNull();
            }

            newThisValue = newThisReference.getValue();

            if (newThisValue.getType() !== 'object' && newThisValue.getType() !== 'null') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bind() expects parameter 2 to be object, ' + newThisValue.getType() + ' given'
                );
                return valueFactory.createNull();
            }

            newScopeValue = newScopeReference ? newScopeReference.getValue() : null;

            if (newScopeValue) {
                if (newScopeValue.getType() === 'object') {
                    // Use object's class as the scope class
                    scopeClassName = newScopeValue.getClassName();
                } else {
                    // For any other type, coerce to string to use as class name
                    // (yes, even integers/floats or resources)
                    scopeClassName = newScopeValue.coerceToString().getNative();
                }
            } else {
                scopeClassName = null;
            }

            // Fetch the class to use as the static scope if specified,
            // otherwise if not specified or "static", use the class of the `$this` object
            if (scopeClassName && scopeClassName !== 'static') {
                scopeClass = globalNamespace.getClass(scopeClassName);
            } else if (newThisValue.getType() !== 'null') {
                scopeClass = newThisValue.getClass();
            } else {
                scopeClass = null;
            }

            return valueFactory.createClosureObject(closureValue.bindClosure(newThisValue, scopeClass));
        }),

        /**
         * Duplicates a closure with a specific bound object and class scope
         *
         * @see {@link https://secure.php.net/manual/en/closure.bindto.php}
         *
         * @param {ObjectValue|Variable|undefined} newThisReference
         * @param {StringValue|Variable|undefined} newScopeReference
         */
        'bindTo': function (newThisReference, newScopeReference) {
            var closureValue = this,
                newScopeValue,
                newThisValue,
                scopeClass,
                scopeClassName;

            if (!newThisReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bindTo() expects at least 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            newThisValue = newThisReference.getValue();

            if (newThisValue.getType() !== 'object' && newThisValue.getType() !== 'null') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Closure::bindTo() expects parameter 1 to be object, ' + newThisValue.getType() + ' given'
                );
                return valueFactory.createNull();
            }

            newScopeValue = newScopeReference ? newScopeReference.getValue() : null;

            if (newScopeValue) {
                if (newScopeValue.getType() === 'object') {
                    // Use object's class as the scope class
                    scopeClassName = newScopeValue.getClassName();
                } else {
                    // For any other type, coerce to string to use as class name
                    // (yes, even integers/floats or resources)
                    scopeClassName = newScopeValue.coerceToString().getNative();
                }
            } else {
                scopeClassName = null;
            }

            // Fetch the class to use as the static scope if specified,
            // otherwise if not specified or "static", use the class of the `$this` object
            if (scopeClassName && scopeClassName !== 'static') {
                scopeClass = globalNamespace.getClass(scopeClassName);
            } else if (newThisValue.getType() !== 'null') {
                scopeClass = newThisValue.getClass();
            } else {
                scopeClass = null;
            }

            return valueFactory.createClosureObject(closureValue.bindClosure(newThisValue, scopeClass));
        },

        /**
         * Invokes the closure with the specified arguments, using calling magic.
         *
         * @see {@link http://php.net/manual/en/language.oop5.magic.php#language.oop5.magic.invoke}
         *
         * @returns {Value}
         */
        '__invoke': function () {
            return this.invokeClosure([].slice.call(arguments));
        }
    });

    internals.disableAutoCoercion();

    /**
     * This unwrapper will be used when an instance of this builtin PHP class Closure
     * is returned from PHP-land to JS-land. We need to export a callable native JS function
     * so that JS-land code can neatly call into the PHP-land closure like this.
     */
    internals.defineUnwrapper(function (objectValue) {
        var closure = objectValue.getInternalProperty('closure');

        // Unwrap PHP Closures to native JS functions that may be called
        // just like any other (with arguments coerced from JS->PHP
        // and the return value coerced from PHP->JS automatically)
        return function __uniterInboundStackMarker__() {
            // Wrap thisObj in *Value object
            var thisObj = valueFactory.coerceObject(this),
                // Wrap all native JS values in *Value objects
                args = valueFactory.coerceList(arguments);

            // Push an FFI call onto the stack, representing the call from JavaScript-land
            callStack.push(callFactory.createFFICall([].slice.call(arguments)));

            function popFFICall() {
                callStack.pop();
            }

            if (internals.mode === 'async') {
                return new Promise(function (resolve, reject) {
                    // Call the method via Pausable to allow for blocking operation
                    internals.pausable.call(
                        closure.invoke,
                        [args, thisObj],
                        closure
                    )
                        // Pop the call off the stack _before_ returning, to mirror sync mode's behaviour
                        .finally(popFFICall)
                        .then(
                            function (resultValue) {
                                resolve(resultValue.getNative());
                            },
                            function (error) {
                                if (valueFactory.isValue(error) && error.getType() === 'object') {
                                    // Method threw a PHP Throwable, so throw a native JS error for it

                                    // Feed the error into the ErrorReporting mechanism,
                                    // so it will be written to stdout/stderr as applicable
                                    reject(errorPromoter.promote(error));
                                    return;
                                }

                                // Normal error: just pass it up to the caller
                                reject(error);
                            }
                        );
                });
            }

            function invoke() {
                var nativeError;

                // Call the closure, and then unwrap its result value back to a native one
                try {
                    return closure.invoke(args, thisObj).getNative();
                } catch (error) {
                    if (valueFactory.isValue(error) && error.getType() === 'object') {
                        // Feed the error into the ErrorReporting mechanism,
                        // so it will be written to stdout/stderr as applicable
                        nativeError = errorPromoter.promote(error);

                        throw nativeError;
                    }

                    throw error;
                } finally {
                    popFFICall();
                }
            }

            if (internals.mode === 'psync') {
                // For Promise-synchronous mode, we need to return a promise
                // even though the actual invocation must return synchronously
                return new Promise(function (resolve, reject) {
                    try {
                        resolve(invoke());
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // Otherwise we're in sync mode
            return invoke();
        };
    });

    return Closure;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/Error.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/Error.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

module.exports = function (internals) {
    var callStack = internals.callStack,
        traceFormatter = internals.traceFormatter,
        valueFactory = internals.valueFactory;

    /**
     * Base class for all internal non-warning/non-notice Errors
     *
     * @see {@link https://secure.php.net/manual/en/class.error.php}
     * @see {@link https://secure.php.net/manual/en/error.construct.php}
     *
     * @param {Reference|Value|Variable=} messageReference
     * @constructor
     */
    function Error(messageReference) {
        var messageValue = messageReference ?
                messageReference.getValue() :
                valueFactory.createString('');

        /**
         * The internal `line` property is defined by the shadow constructor.
         *
         * If this class is extended but a parent constructor call is not used,
         * then no parent constructor will be called (even this native constructor function).
         *
         * To run code regardless of whether the parent constructor is called, we use
         * a "shadow constructor", defined below.
         */

        /**
         * A message describing the error
         *
         * (Default to empty here - unless overridden by calling the constructor defined above
         * or overridden by a subclass)
         *
         * @see {@link https://secure.php.net/manual/en/class.error.php#error.props.message}
         */
        this.setProperty('message', messageValue);
    }

    Error.shadowConstructor = function () {
        // Define these data properties here, so they are always defined for any derived class of error,
        // regardless of whether a parent constructor call is used or not

        /**
         * The file the error was created inside
         *
         * @see {@link https://secure.php.net/manual/en/class.error.php#error.props.file}
         */
        this.setProperty('file', valueFactory.coerce(callStack.getLastFilePath()));

        /**
         * The line the error was created on
         *
         * @see {@link https://secure.php.net/manual/en/class.error.php#error.props.line}
         */
        this.setProperty('line', valueFactory.coerce(callStack.getLastLine()));

        /**
         * A message describing the error
         *
         * (Default to empty here - unless overridden by calling the constructor defined above
         * or overridden by a subclass)
         *
         * @see {@link https://secure.php.net/manual/en/class.error.php#error.props.message}
         */
        this.setProperty('message', valueFactory.createString(''));

        this.setInternalProperty('reportsOwnContext', false);

        // This internal trace prop will not be visible to PHP code
        // except for read-only via the ->getTraceAsString() method.
        this.setInternalProperty('trace', callStack.getTrace());
    };

    // Error class should implement Throwable in PHP 7+
    internals.implement('Throwable');

    _.extend(Error.prototype, {
        /**
         * Fetches the path to the file containing the line this error was created from
         * (not the line it was thrown from, if it was thrown at all)
         *
         * @see {@link https://secure.php.net/manual/en/error.getfile.php}
         *
         * @returns {StringValue}
         */
        getFile: function () {
            return this.getProperty('file');
        },

        /**
         * Fetches the line number this error was created on
         * (not the line it was thrown from, if it was thrown at all)
         *
         * @see {@link https://secure.php.net/manual/en/error.getline.php}
         *
         * @returns {IntegerValue}
         */
        getLine: function () {
            return this.getProperty('line');
        },

        /**
         * Fetches the message for the error
         *
         * @see {@link https://secure.php.net/manual/en/error.getmessage.php}
         *
         * @returns {StringValue}
         */
        getMessage: function () {
            return this.getProperty('message');
        },

        /**
         * Gets the stack trace as a string
         *
         * @see {@link https://secure.php.net/manual/en/error.gettraceasstring.php}
         *
         * @returns {StringValue}
         */
        getTraceAsString: function () {
            var trace = this.getInternalProperty('trace');

            return valueFactory.createString(traceFormatter.format(trace));
        }
    });

    internals.disableAutoCoercion();

    return Error;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/Error/ArgumentCountError.js":
/*!******************************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/Error/ArgumentCountError.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Thrown when an invalid number of arguments are passed to a user-defined function or method
     *
     * @see {@link https://secure.php.net/manual/en/class.argumentcounterror.php}
     * @constructor
     */
    function ArgumentCountError() {
        internals.callSuperConstructor(this, arguments);
    }

    // Extend the base TypeError class
    internals.extendClass('TypeError');

    internals.disableAutoCoercion();

    return ArgumentCountError;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/Error/CompileError.js":
/*!************************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/Error/CompileError.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Base class for compilation errors
     *
     * @see {@link https://secure.php.net/manual/en/class.compileerror.php}
     * @constructor
     */
    function CompileError() {
        internals.callSuperConstructor(this, arguments);
    }

    // Extend the base Error class
    internals.extendClass('Error');

    internals.disableAutoCoercion();

    return CompileError;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/Error/ParseError.js":
/*!**********************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/Error/ParseError.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPParseError = phpCommon.PHPParseError;

module.exports = function (internals) {
    /**
     * Thrown when an error occurs during parsing of PHP code, eg. when eval(...) is called
     *
     * @see {@link https://secure.php.net/manual/en/class.parseerror.php}
     * @constructor
     */
    function ParseError() {
        internals.callSuperConstructor(this, arguments);
    }

    internals.extendClass('CompileError');

    internals.disableAutoCoercion();

    internals.defineUnwrapper(function (errorValue) {
        /*
         * When throwing/returning a ParseError instance to JS-land, convert it to a PHPParseError from PHPCommon.
         * Note that this is also used when returning rather than throwing, due to use of this unwrapper.
         * This is useful for consistency, in the scenario where a ParseError is returned (not thrown)
         * to JS-land, then later thrown from JS-land.
         *
         * Note that this unwrapper shadows the one defined on the Throwable interface.
         */
        return new PHPParseError(
            errorValue.getProperty('message').getNative(),
            errorValue.getProperty('file').getNative(),
            errorValue.getProperty('line').getNative()
        );
    });

    return ParseError;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/Error/TypeError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/Error/TypeError.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Base class for type errors
     *
     * @see {@link https://secure.php.net/manual/en/class.typeerror.php}
     * @constructor
     */
    function TypeError() {
        internals.callSuperConstructor(this, arguments);
    }

    // Extend the base Error class
    internals.extendClass('Error');

    internals.disableAutoCoercion();

    return TypeError;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/Exception.js":
/*!***************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/Exception.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

module.exports = function (internals) {
    var callStack = internals.callStack,
        traceFormatter = internals.traceFormatter,
        valueFactory = internals.valueFactory;

    /**
     * Base class for all user Exceptions
     *
     * @see {@link https://secure.php.net/manual/en/class.exception.php}
     * @see {@link https://secure.php.net/manual/en/exception.construct.php}
     *
     * @param {Reference|Value|Variable=} messageReference
     * @constructor
     */
    function Exception(messageReference) {
        var messageValue = messageReference ?
            messageReference.getValue() :
            valueFactory.createString(''); // The default exception message is the empty string

        /**
         * The internal `trace` property is defined by the shadow constructor.
         *
         * If this class is extended but a parent constructor call is not used,
         * then no parent constructor will be called (even this native constructor function).
         *
         * To run code regardless of whether the parent constructor is called, we use
         * a "shadow constructor", defined below.
         */

        this.setProperty('message', messageValue);
    }

    Exception.shadowConstructor = function () {
        // Define these data properties here, so they are always defined for any derived class of Exception,
        // regardless of whether a parent constructor call is used or not

        /**
         * The file the exception was created inside
         *
         * @see {@link https://secure.php.net/manual/en/class.exception.php#exception.props.file}
         */
        this.setProperty('file', valueFactory.coerce(callStack.getLastFilePath()));

        /**
         * The line the exception was created on
         *
         * @see {@link https://secure.php.net/manual/en/class.exception.php#exception.props.line}
         */
        this.setProperty('line', valueFactory.coerce(callStack.getLastLine()));

        /**
         * A message describing the exception
         *
         * (Default to empty here - unless overridden by calling the constructor defined above
         * or overridden by a subclass)
         *
         * @see {@link https://secure.php.net/manual/en/class.exception.php#exception.props.message}
         */
        this.setProperty('message', valueFactory.createString(''));

        this.setInternalProperty('reportsOwnContext', false);

        // This internal trace prop will not be visible to PHP code
        // except for read-only via the ->getTraceAsString() method.
        this.setInternalProperty('trace', callStack.getTrace());
    };

    // Exception class should implement Throwable in PHP 7+
    internals.implement('Throwable');

    _.extend(Exception.prototype, {
        /**
         * Fetches the path to the file containing the line this exception was created from
         * (not the line it was thrown from, if it was thrown at all)
         *
         * @see {@link https://secure.php.net/manual/en/exception.getfile.php}
         *
         * @returns {StringValue}
         */
        getFile: function () {
            return this.getProperty('file');
        },

        /**
         * Fetches the line number this exception was created on
         * (not the line it was thrown from, if it was thrown at all)
         *
         * @see {@link https://secure.php.net/manual/en/exception.getline.php}
         *
         * @returns {IntegerValue}
         */
        getLine: function () {
            return this.getProperty('line');
        },

        /**
         * Fetches the message for the exception
         *
         * @see {@link https://secure.php.net/manual/en/exception.getmessage.php}
         *
         * @returns {StringValue}
         */
        getMessage: function () {
            return this.getProperty('message');
        },

        /**
         * Gets the stack trace as a string
         *
         * @see {@link https://secure.php.net/manual/en/exception.gettraceasstring.php}
         *
         * @returns {StringValue}
         */
        getTraceAsString: function () {
            var trace = this.getInternalProperty('trace');

            return valueFactory.createString(traceFormatter.format(trace));
        }
    });

    internals.disableAutoCoercion();

    return Exception;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/JSObject.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/JSObject.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError,
    UNDEFINED_METHOD = 'core.undefined_method';

module.exports = function (internals) {
    var callStack = internals.callStack;

    function JSObject() {

    }

    _.extend(JSObject.prototype, {
        /**
         * JSObject needs to implement its own way of calling out to native JS methods,
         * because the method property lookup needs to be case-sensitive, unlike PHP
         *
         * @param {string} name
         * @param {*[]} args
         * @returns {*}
         */
        '__call': function __uniterOutboundStackMarker__(name, args) {
            var object = this,
                result;

            if (!_.isFunction(object[name])) {
                callStack.raiseTranslatedError(PHPError.E_ERROR, UNDEFINED_METHOD, {
                    className: 'JSObject',
                    methodName: name
                });
            }

            result = object[name].apply(object, args);

            return result;
        },

        /**
         * Fetches a property from the native JS object
         *
         * @param {string} propertyName
         * @returns {*}
         */
        '__get': function (propertyName) {
            return this[propertyName];
        },

        /**
         * In JavaScript, objects cannot normally be made callable, only functions
         * (and Proxies with the "apply" trap) -
         * this magic method is implemented to allow imported JS functions to be callable.
         *
         * @returns {*}
         */
        '__invoke': function () {
            var object = this,
                result;

            if (!_.isFunction(object)) {
                throw new Error('Attempted to invoke a non-function JS object');
            }

            result = object.apply(null, arguments);

            return result;
        },

        /**
         * Sets a property on the native JS object
         *
         * @param {string} propertyName
         * @param {*} nativeValue
         */
        '__set': function (propertyName, nativeValue) {
            // Ensure we write the native value to properties on native JS objects -
            // as JSObject is auto-coercing we already have it
            this[propertyName] = nativeValue;
        },

        /**
         * Deletes a property from the native JS object when `unset($jsObject->prop)` is called from PHP-land
         *
         * @param {string} propertyName
         */
        '__unset': function (propertyName) {
            delete this[propertyName];
        }
    });

    internals.defineUnwrapper(function (nativeObject) {
        /*
         * JSObjects are objects that originate from JS-land and were subsequently passed into PHP-land -
         * when we want to unwrap them to pass back to JS-land, simply return the original native object
         */
        return nativeObject;
    });

    return JSObject;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/classes/stdClass.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/classes/stdClass.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

module.exports = function (internals) {
    function stdClass() {

    }

    internals.disableAutoCoercion();

    internals.defineUnwrapper(function () {
        // When exporting via the public FFI API, unwrap stdClass instances to a plain object
        // with native property values
        var objectValue = this,
            result = {};

        _.forOwn(objectValue.getNonPrivateProperties(), function (propertyValue, propertyName) {
            result[propertyName] = propertyValue.getNative();
        });

        return result;
    });

    return stdClass;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/constants/errorHandling.js":
/*!*********************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/constants/errorHandling.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    return {
        'E_ERROR': 1,
        'E_WARNING': 2,
        'E_PARSE': 4,
        'E_NOTICE': 8,
        'E_CORE_ERROR': 16,
        'E_CORE_WARNING': 32,
        'E_COMPILE_ERROR': 64,
        'E_COMPILE_WARNING': 128,
        'E_USER_ERROR': 256,
        'E_USER_WARNING': 512,
        'E_USER_NOTICE': 1024,
        'E_STRICT': 2048,
        'E_RECOVERABLE_ERROR': 4096,
        'E_DEPRECATED': 8192,
        'E_USER_DEPRECATED': 16384,
        'E_ALL': 32767
    };
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/constants/reserved.js":
/*!****************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/constants/reserved.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    return {
        'PHP_EOL': '\n'
    };
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/functions/optionsAndInfo/config.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/functions/optionsAndInfo/config.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        iniState = internals.iniState,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Fetches the value of a PHP configuration option.
         * Any changes made at runtime (eg. with ini_set(...)) will be taken into account.
         *
         * @see {@link https://secure.php.net/manual/en/function.ini-get.php}
         *
         * @param {Reference|Value|Variable} optionNameReference
         * @returns {Value}
         */
        'ini_get': function (optionNameReference) {
            var optionName,
                optionValue;

            if (arguments.length !== 1) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'ini_get() expects exactly 1 parameter, ' + arguments.length + ' given'
                );

                return valueFactory.createNull();
            }

            optionName = optionNameReference.getValue().getNative();
            optionValue = iniState.get(optionName);

            if (optionValue === null) {
                // Indicate that the option is not defined with bool(false)
                return valueFactory.createBoolean(false);
            }

            return valueFactory.coerce(optionValue);
        },

        /**
         * Sets the value of a defined PHP configuration option at runtime,
         * returning its previous value.
         * If the option does not exist, false will be returned.
         *
         * @see {@link https://secure.php.net/manual/en/function.ini-set.php}
         *
         * @param {Reference|Value|Variable} optionNameReference
         * @param {Reference|Value|Variable} optionValueReference
         * @returns {Value}
         */
        'ini_set': function (optionNameReference, optionValueReference) {
            var previousOptionValue,
                optionName,
                optionValue;

            if (arguments.length !== 2) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'ini_set() expects exactly 2 parameters, ' + arguments.length + ' given'
                );

                return valueFactory.createNull();
            }

            optionName = optionNameReference.getValue().getNative();
            previousOptionValue = iniState.get(optionName);

            if (previousOptionValue === null) {
                // Indicate that the option is not defined with bool(false)
                return valueFactory.createBoolean(false);
            }

            optionValue = optionValueReference.getValue().getNative();

            iniState.set(optionName, optionValue);

            return valueFactory.coerce(previousOptionValue);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/functions/spl.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/functions/spl.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = __webpack_require__(/*! pauser */ "./node_modules/pauser/index.js")([
    __webpack_require__(/*! ../../Variable */ "./node_modules/phpcore/src/Variable.js")
], function (
    Variable
) {
    return function (internals) {
        var classAutoloader = internals.classAutoloader,
            valueFactory = internals.valueFactory;

        return {
            'spl_autoload_register': function (callableReference) {
                var isReference = (callableReference instanceof Variable),
                    callableValue = isReference ? callableReference.getValue() : callableReference;

                classAutoloader.appendAutoloadCallable(callableValue);
            },
            'spl_autoload_unregister': function (callableReference) {
                var isReference = (callableReference instanceof Variable),
                    callableValue = isReference ? callableReference.getValue() : callableReference;

                return valueFactory.createBoolean(
                    classAutoloader.removeAutoloadCallable(callableValue)
                );
            }
        };
    };
}, {strict: true});


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/ini/errorHandling.js":
/*!***************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/ini/errorHandling.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /*jshint bitwise: false */
    var E_ALL = internals.getConstant('E_ALL'),
        E_DEPRECATED = internals.getConstant('E_DEPRECATED'),
        E_NOTICE = internals.getConstant('E_NOTICE'),
        E_STRICT = internals.getConstant('E_STRICT');

    return {
        /**
         * Determines whether errors should be printed to stdout or hidden from the user.
         * Errors are always written to stderr regardless of this setting.
         *
         * The value `stderr` will cause both messages to be written to stderr.
         *
         * @see {@link https://www.php.net/manual/en/errorfunc.configuration.php#ini.display-errors}
         */
        'display_errors': true,

        /**
         * Controls what levels of error are reported to the user.
         *
         * @see {@link https://www.php.net/manual/en/errorfunc.configuration.php#ini.error-reporting}
         */
        'error_reporting': E_ALL & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED
    };
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/interfaces/ArrayAccess.js":
/*!********************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/interfaces/ArrayAccess.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    function ArrayAccess() {

    }

    return ArrayAccess;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/interfaces/Iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/interfaces/Iterator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Interface for user-defined iterators or objects that can be iterated themselves internally
     *
     * @see {@link https://secure.php.net/manual/en/class.iterator.php}
     *
     * @interface
     */
    function Iterator() {

    }

    internals.implement('Traversable');

    Iterator.shadowConstructor = function () {
        var iteratorValue = this;

        iteratorValue.setInternalProperty('getIterator', function () {
            // Implementors of Iterator are themselves iterable
            return iteratorValue;
        });
    };

    return Iterator;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/interfaces/IteratorAggregate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/interfaces/IteratorAggregate.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Interface for user-defined iterators or objects that can be iterated themselves internally
     *
     * @see {@link https://secure.php.net/manual/en/class.iteratoraggregate.php}
     *
     * @interface
     */
    function IteratorAggregate() {

    }

    internals.implement('Traversable');

    IteratorAggregate.shadowConstructor = function () {
        var aggregateValue = this;

        aggregateValue.setInternalProperty('getIterator', function () {
            // Implementors of IteratorAggregate expose their iterator via a ->getIterator() method
            return aggregateValue.callMethod('getIterator');
        });
    };

    IteratorAggregate.prototype.getIterator = function () {
        throw new Error('Interface method should be implemented by sub-classes');
    };

    return IteratorAggregate;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/interfaces/Throwable.js":
/*!******************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/interfaces/Throwable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    PHPError = phpCommon.PHPError,
    PHPFatalError = phpCommon.PHPFatalError,

    UNCAUGHT_EMPTY_THROWABLE = 'core.uncaught_empty_throwable',
    UNCAUGHT_THROWABLE = 'core.uncaught_throwable';

module.exports = function (internals) {
    var translator = internals.translator;

    /**
     * PHP 7 Throwable interface
     *
     * @see {@link https://secure.php.net/manual/en/class.throwable.php}
     *
     * @constructor
     */
    function Throwable() {
    }

    util.inherits(Throwable, PHPError);

    internals.disableAutoCoercion();

    internals.defineUnwrapper(function (errorValue) {
        /*
         * When throwing/returning a Throwable instance to JS-land, by default convert it to a PHPFatalError from PHPCommon.
         * Note that this is also used when returning rather than throwing, due to use of this unwrapper.
         * This is useful for consistency, in the scenario where an Error or Exception is returned (not thrown)
         * to JS-land, then later thrown from JS-land.
         */
        var message = errorValue.getProperty('message').getNative();

        if (message !== '') {
            message = translator.translate(UNCAUGHT_THROWABLE, {
                name: errorValue.getClassName(),
                message: message
            });
        } else {
            message = translator.translate(UNCAUGHT_EMPTY_THROWABLE, {
                name: errorValue.getClassName()
            });
        }

        return new PHPFatalError(
            message,
            errorValue.getProperty('file').getNative(),
            errorValue.getProperty('line').getNative()
        );
    });

    return Throwable;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/interfaces/Traversable.js":
/*!********************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/interfaces/Traversable.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Interface for classes traversable using foreach (extended by Iterator and IteratorAggregate)
     *
     * @see {@link https://secure.php.net/manual/en/class.traversable.php}
     *
     * @interface
     */
    function Traversable() {

    }

    Traversable.shadowConstructor = function () {
        var traversableValue = this;

        traversableValue.setInternalProperty('getIterator', function () {
            throw new Error('\\Traversable: Sub-interface should have set the iterator getter');
        });
    };

    internals.disableAutoCoercion();

    return Traversable;
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/messages/error.en_GB.js":
/*!******************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/messages/error.en_GB.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



/*
 * Translations for error-level error messages
 */
module.exports = {
    'en_GB': {
        'core': {
            'break_or_continue_in_wrong_context': '\'${type}\' not in the \'loop\' or \'switch\' context',
            'call_to_undefined_function': 'Call to undefined function ${name}()',
            'cannot_access_property': 'Cannot access ${visibility} property ${className}::$${propertyName}',
            'cannot_access_when_no_active_class': 'Cannot access ${className}:: when no class scope is active',
            'cannot_declare_class_as_name_already_in_use': 'Cannot declare class ${className} because the name is already in use',
            // NB: This translation is in fact different to the above, by a comma
            'cannot_redeclare_class_as_name_already_in_use': 'Cannot declare class ${className}, because the name is already in use',
            'cannot_implement_throwable': 'Class ${className} cannot implement interface Throwable, extend Exception or Error instead',
            'cannot_unset_static_property': 'Attempt to unset static property ${className}::$${propertyName}',
            'cannot_use_as_name_already_in_use': 'Cannot use ${source} as ${alias} because the name is already in use',
            'cannot_use_wrong_type_as': 'Cannot use object of type ${actual} as ${expected}',
            'class_name_not_valid': 'Class name must be a valid object or a string',
            'class_not_found': 'Class \'${name}\' not found',
            'function_name_must_be_string': 'Function name must be a string',
            'invalid_value_for_type': 'Argument ${index} passed to ${func}() must be ${expectedType}, ${actualType} given, called in ${callerFile} on line ${callerLine} and defined in ${definitionFile}:${definitionLine}',
            'method_called_on_non_object': '${method} method called on non-object',
            'no_parent_class': 'Cannot access parent:: when current class scope has no parent',
            'non_object_method_call': 'Call to a member function ${name}() on ${type}',
            'object_from_get_iterator_must_be_traversable': 'Objects returned by ${className}::getIterator() must be traversable or implement interface Iterator',
            'only_variables_by_reference': 'Only variables can be passed by reference',
            'too_few_args_for_exact_count': 'Too few arguments to function ${func}(), ${actualCount} passed in ${callerFile} on line ${callerLine} and exactly ${expectedCount} expected',
            'uncaught_throwable': 'Uncaught ${name}: ${message}',
            'uncaught_empty_throwable': 'Uncaught ${name}',
            'undeclared_static_property': 'Access to undeclared static property: ${className}::$${propertyName}',
            'undefined_class_constant': 'Undefined class constant \'${name}\'',
            'undefined_constant': 'Undefined constant \'${name}\'',
            'undefined_method': 'Call to undefined method ${className}::${methodName}()',
            'undefined_property': 'Undefined property: ${className}::$${propertyName}',
            'unsupported_operand_types': 'Unsupported operand types',
            'used_this_outside_object_context': 'Using $this when not in object context'
        }
    }
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/messages/misc.en_GB.js":
/*!*****************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/messages/misc.en_GB.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



/*
 * Miscellaneous translations
 */
module.exports = {
    'en_GB': {
        'core': {
            // For uncaught errors (see ErrorReporting)
            'error_with_context_and_trace': ' in ${filePath}:${line}\n' +
                'Stack trace:' + '\n' +
                '${formattedTrace}\n' +
                '  thrown in ${filePath} on line ${line}',
            'error_without_context_but_with_trace': '\n' +
                'Stack trace:' + '\n' +
                '${formattedTrace}\n' +
                '  thrown in ${filePath} on line ${line}',

            // For warnings/notices/uncatchable errors etc.
            'error_without_trace': ' in ${filePath} on line ${line}',

            // The path used in stack traces etc. for eval'd code
            'eval_path': '${path}(${lineNumber}) : eval()\'d code',

            // Used for building messages referencing types
            'instance_of_type_expected': 'an instance of ${expectedType}',
            'instance_of_type_actual': 'instance of ${actualType}',
            'of_generic_type_expected': 'of the type ${expectedType}',

            // For any type of error that needs to be scoped to the current function
            'scoped_error': '${function}(): ${message}',

            // For unknown file paths, line numbers etc.
            'unknown': 'unknown'
        }
    }
};


/***/ }),

/***/ "./node_modules/phpcore/src/builtin/messages/notice.en_GB.js":
/*!*******************************************************************!*\
  !*** ./node_modules/phpcore/src/builtin/messages/notice.en_GB.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



/*
 * Translations for notice-level error messages
 */
module.exports = {
    'en_GB': {
        'core': {
            'constant_already_defined': 'Constant ${name} already defined'
        }
    }
};


/***/ }),

/***/ "./node_modules/phpcore/src/shared/debugFormatterInstaller.js":
/*!********************************************************************!*\
  !*** ./node_modules/phpcore/src/shared/debugFormatterInstaller.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

/**
 * DebugFormatterInstaller shared service.
 *
 * Allows current & future class dependencies to be added in a single place.
 */



var DebugFactory = __webpack_require__(/*! ../Debug/DebugFactory */ "./node_modules/phpcore/src/Debug/DebugFactory.js"),
    DebugFormatter = __webpack_require__(/*! ../Debug/DebugFormatter */ "./node_modules/phpcore/src/Debug/DebugFormatter.js"),
    DebugFormatterInstaller = __webpack_require__(/*! ../Debug/DebugFormatterInstaller */ "./node_modules/phpcore/src/Debug/DebugFormatterInstaller.js"),
    DebugValue = __webpack_require__(/*! ../Debug/DebugValue */ "./node_modules/phpcore/src/Debug/DebugValue.js"),
    ValueFormatter = __webpack_require__(/*! ../Debug/ValueFormatter */ "./node_modules/phpcore/src/Debug/ValueFormatter.js"),
    debugFactory = new DebugFactory(DebugFormatter, DebugValue, ValueFormatter);

module.exports = new DebugFormatterInstaller(global, debugFactory);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/phpcore/src/shared/globalStackHooker.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpcore/src/shared/globalStackHooker.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

/**
 * GlobalStackHooker shared service.
 *
 * Allows current & future class dependencies to be added in a single place.
 */



var usingV8StackTraceAPI = typeof Error.captureStackTrace === 'function' &&
        Function.prototype.toString.call(Error.captureStackTrace).indexOf('[native code]') > -1,
    GlobalStackHooker = __webpack_require__(/*! ../FFI/Stack/GlobalStackHooker */ "./node_modules/phpcore/src/FFI/Stack/GlobalStackHooker.js"),
    NonV8FrameStackHooker = __webpack_require__(/*! ../FFI/Stack/NonV8FrameStackHooker */ "./node_modules/phpcore/src/FFI/Stack/NonV8FrameStackHooker.js"),
    StackCleaner = __webpack_require__(/*! ../FFI/Stack/StackCleaner */ "./node_modules/phpcore/src/FFI/Stack/StackCleaner.js"),
    V8FrameStackHooker = __webpack_require__(/*! ../FFI/Stack/V8FrameStackHooker */ "./node_modules/phpcore/src/FFI/Stack/V8FrameStackHooker.js"),
    stackCleaner = new StackCleaner(),
    frameStackHooker = usingV8StackTraceAPI ?
        new V8FrameStackHooker(stackCleaner) :
        new NonV8FrameStackHooker(stackCleaner);

module.exports = new GlobalStackHooker(frameStackHooker, global);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/phpcore/src/shared/runtimeFactory.js":
/*!***********************************************************!*\
  !*** ./node_modules/phpcore/src/shared/runtimeFactory.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */

/**
 * RuntimeFactory shared service.
 *
 * Allows current & future class dependencies to be added in a single place.
 */



var Engine = __webpack_require__(/*! ../Engine */ "./node_modules/phpcore/src/Engine.js"),
    Environment = __webpack_require__(/*! ../Environment */ "./node_modules/phpcore/src/Environment.js"),
    globalStackHooker = __webpack_require__(/*! ./globalStackHooker */ "./node_modules/phpcore/src/shared/globalStackHooker.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPStateWrapper = __webpack_require__(/*! ../PHPState */ "./node_modules/phpcore/src/PHPState.js"),
    RuntimeFactory = __webpack_require__(/*! ../RuntimeFactory */ "./node_modules/phpcore/src/RuntimeFactory.js"),
    RuntimeWrapper = __webpack_require__(/*! ../Runtime */ "./node_modules/phpcore/src/Runtime.js");

module.exports = new RuntimeFactory(
    Environment,
    Engine,
    PHPStateWrapper,
    RuntimeWrapper,
    phpCommon,
    globalStackHooker
);


/***/ }),

/***/ "./node_modules/phpify/api/psync.js":
/*!******************************************!*\
  !*** ./node_modules/phpify/api/psync.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



/*global global */
var API = __webpack_require__(/*! ../src/API */ "./node_modules/phpify/src/API.js"),
    EnvironmentProvider = __webpack_require__(/*! ../src/EnvironmentProvider */ "./node_modules/phpify/src/EnvironmentProvider.js"),
    FileSystem = __webpack_require__(/*! ../src/FileSystem */ "./node_modules/phpify/src/FileSystem.js"),
    IO = __webpack_require__(/*! ../src/IO */ "./node_modules/phpify/src/IO.js"),
    Loader = __webpack_require__(/*! ../src/Loader */ "./node_modules/phpify/src/Loader.js"),
    ModuleRepository = __webpack_require__(/*! ../src/ModuleRepository */ "./node_modules/phpify/src/ModuleRepository.js"),
    Performance = __webpack_require__(/*! ../src/Performance */ "./node_modules/phpify/src/Performance.js"),
    performance = new Performance(Date, global),
    phpConfigImporter = __webpack_require__(/*! phpconfig */ "./node_modules/phpconfig/dist/index.js").configImporter,
    phpRuntime = __webpack_require__(/*! phpruntime/psync */ "./node_modules/phpruntime/psync.js"),
    io = new IO(console),
    environmentProvider = new EnvironmentProvider(phpRuntime, performance, io),
    api = new API(FileSystem, Loader, ModuleRepository, environmentProvider, phpConfigImporter),
    loader = api.createLoader();

module.exports = loader;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/phpify/src/API.js":
/*!****************************************!*\
  !*** ./node_modules/phpify/src/API.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * API entry point for creating Loaders for compiled PHP modules to use
 *
 * @param {class} FileSystem
 * @param {class} Loader
 * @param {class} ModuleRepository
 * @param {EnvironmentProvider} environmentProvider
 * @param {ConfigImporter} phpConfigImporter
 * @constructor
 */
function API(
    FileSystem,
    Loader,
    ModuleRepository,
    environmentProvider,
    phpConfigImporter
) {
    /**
     * @type {EnvironmentProvider}
     */
    this.environmentProvider = environmentProvider;
    /**
     * @type {class}
     */
    this.FileSystem = FileSystem;
    /**
     * @type {class}
     */
    this.Loader = Loader;
    /**
     * @type {class}
     */
    this.ModuleRepository = ModuleRepository;
    /**
     * @type {ConfigImporter}
     */
    this.phpConfigImporter = phpConfigImporter;
}

_.extend(API.prototype, {
    /**
     * Creates a new, isolated Loader along with a FileSystem
     * and PHPCore/PHPRuntime environment for compiled PHP modules to use
     *
     * @returns {Loader}
     */
    createLoader: function () {
        var api = this,
            moduleRepository = new api.ModuleRepository(__webpack_require__.c),
            fileSystem = new api.FileSystem(moduleRepository);

        return new api.Loader(moduleRepository, fileSystem, api.environmentProvider, api.phpConfigImporter);
    }
});

module.exports = API;


/***/ }),

/***/ "./node_modules/phpify/src/EnvironmentProvider.js":
/*!********************************************************!*\
  !*** ./node_modules/phpify/src/EnvironmentProvider.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Creates the Environment for a loader
 *
 * @param {Object} phpRuntime
 * @param {Performance} performance
 * @param {IO} io
 * @constructor
 */
function EnvironmentProvider(phpRuntime, performance, io) {
    /**
     * @type {IO}
     */
    this.io = io;
    /**
     * @type {Performance}
     */
    this.performance = performance;
    /**
     * @type {Object}
     */
    this.phpRuntime = phpRuntime;
}

_.extend(EnvironmentProvider.prototype, {
    /**
     * Creates a new Environment
     *
     * @param {FileSystem} fileSystem
     * @param {Object} phpifyConfig
     * @param {Object} phpCoreConfig
     * @returns {Environment}
     */
    createEnvironment: function (fileSystem, phpifyConfig, phpCoreConfig) {
        var provider = this,
            environmentOptions = Object.assign({}, phpCoreConfig, {
                fileSystem: fileSystem,
                include: function (filePath, promise) {
                    var result;

                    try {
                        result = fileSystem.getModuleFactory(filePath);
                    } catch (error) {
                        promise.reject(error);
                        return;
                    }

                    promise.resolve(result);
                },
                performance: provider.performance
            }),
            addons = environmentOptions.addons || [],
            environment;

        delete environmentOptions.addons;

        environment = provider.phpRuntime.createEnvironment(
            environmentOptions,
            addons
        );

        provider.io.install(environment, phpifyConfig);

        return environment;
    }
});

module.exports = EnvironmentProvider;


/***/ }),

/***/ "./node_modules/phpify/src/FileSystem.js":
/*!***********************************************!*\
  !*** ./node_modules/phpify/src/FileSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    path = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js"),
    Promise = __webpack_require__(/*! lie */ "./node_modules/lie/lib/browser.js");

/**
 * Virtual FileSystem for use in the browser with compiled PHP modules
 *
 * @param {ModuleRepository} moduleRepository
 * @constructor
 */
function FileSystem(moduleRepository) {
    /**
     * @type {ModuleRepository}
     */
    this.moduleRepository = moduleRepository;
}

_.extend(FileSystem.prototype, {
    /**
     * Fetches the module wrapper factory function for a compiled PHP module,
     * if it exists in the compiled bundle
     *
     * @param {string} filePath
     * @returns {Function}
     * @throws {Error} Throws when the specified compiled module does not exist
     */
    getModuleFactory: function (filePath) {
        var fileSystem = this;

        filePath = fileSystem.realPath(filePath);

        // TODO: If a PHP source file has been written to the virtual FS, and eval-ish support
        //       is installed, allow the dynamically-generated module to be compiled and run

        return fileSystem.moduleRepository.getModuleFactory(filePath);
    },

    /**
     * Determines whether the specified directory path exists in the FileSystem.
     * Currently always returns true, as we cannot be sure from the info we have
     *
     * @returns {boolean}
     */
    isDirectory: function () {
        // TODO: Implement once we have support for non-PHP files in the VFS
        return false;
    },

    /**
     * Determines whether the specified file exists in the FileSystem.
     * Currently only compiled PHP modules can be in the FileSystem, so only those
     * may be detected.
     *
     * @param {string} filePath
     * @returns {boolean}
     */
    isFile: function (filePath) {
        var fileSystem = this;

        filePath = fileSystem.realPath(filePath);

        return fileSystem.moduleRepository.moduleExists(filePath);
    },

    /**
     * Opens a Stream for the specified file asynchronously
     *
     * @param {string} filePath
     * @returns {Promise} Resolves with a Stream for the file on success, rejects on failure
     */
    open: function (filePath) {
        return new Promise(function (resolve, reject) {
            reject(new Error('Could not open "' + filePath + '" :: Streams are not currently supported by PHPify'));
        });
    },

    /**
     * Opens a Stream for the specified file synchronously
     *
     * @param {string} filePath
     * @returns {Stream}
     */
    openSync: function (filePath) {
        throw new Error('Could not open "' + filePath + '" :: Streams are not currently supported by PHPify');
    },

    /**
     * Converts the specified module path to a full one,
     * normalizing any parent- or current-directory symbols
     *
     * @param {string} filePath
     * @returns {string}
     */
    realPath: function (filePath) {
        filePath = path.normalize(filePath);

        // Strip any leading slash, as the virtual FS does not expect it
        filePath = filePath.replace(/^\/+/, '');

        return filePath;
    },

    /**
     * Deletes a file or folder asynchronously
     *
     * @param {string} filePath
     * @returns {Promise} Resolves on success, rejects on failure
     */
    unlink: function (filePath) {
        return new Promise(function (resolve, reject) {
            reject(new Error('Could not delete "' + filePath + '" :: not currently supported by PHPify'));
        });
    },

    /**
     * Deletes a file or folder synchronously
     *
     * @param {string} filePath
     */
    unlinkSync: function (filePath) {
        throw new Error('Could not delete "' + filePath + '" :: not currently supported by PHPify');
    }
});

module.exports = FileSystem;


/***/ }),

/***/ "./node_modules/phpify/src/IO.js":
/*!***************************************!*\
  !*** ./node_modules/phpify/src/IO.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Hooks Uniter's PHP stdout and stderr streams up to the console, if available and enabled
 *
 * @param {Console} console
 * @constructor
 */
function IO(console) {
    /**
     * @type {Console}
     */
    this.console = console;
}

_.extend(IO.prototype, {
    /**
     * Hooks the IO for a PHP engine up to the console
     *
     * @param {Environment} environment
     * @param {Object} phpifyConfig
     */
    install: function (environment, phpifyConfig) {
        var io = this;

        if (!io.console) {
            // Console is not available - nothing to do
            return;
        }

        if (phpifyConfig.stdio === false) {
            // Standard I/O has been disabled in config - nothing to do
            return;
        }

        environment.getStdout().on('data', function (data) {
            io.console.info(data);
        });

        environment.getStderr().on('data', function (data) {
            io.console.warn(data);
        });
    }
});

module.exports = IO;


/***/ }),

/***/ "./node_modules/phpify/src/Loader.js":
/*!*******************************************!*\
  !*** ./node_modules/phpify/src/Loader.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Public API for compiled PHP modules
 *
 * @param {ModuleRepository} moduleRepository
 * @param {FileSystem} fileSystem
 * @param {EnvironmentProvider} environmentProvider
 * @param {ConfigImporterInterface} phpConfigImporter
 * @constructor
 */
function Loader(
    moduleRepository,
    fileSystem,
    environmentProvider,
    phpConfigImporter
) {
    /**
     * @type {Environment|null} Lazily-initialised by .getEnvironment()
     */
    this.environment = null;
    /**
     * @type {EnvironmentProvider}
     */
    this.environmentProvider = environmentProvider;
    /**
     * @type {FileSystem}
     */
    this.fileSystem = fileSystem;
    /**
     * @type {ModuleRepository}
     */
    this.moduleRepository = moduleRepository;
    /**
     * @type {ConfigImporterInterface}
     */
    this.phpConfigImporter = phpConfigImporter;
    /**
     * @type {Object} Populated from the Initialiser by .configure(...)
     */
    this.phpCoreConfig = {};
    /**
     * @type {Object} Populated from the Initialiser by .configure(...)
     */
    this.phpifyConfig = {};
}

_.extend(Loader.prototype, {
    /**
     * Executes zero or more bootstrap modules within the environment.
     * Must be done as a separate method call from .installModules(...), as the PHP module factory fetcher
     * function installed needs to be available here, because bootstrap modules may themselves
     * be PHP modules (useful for including Composer's autoloader, for example)
     *
     * @param {Function[]} bootstraps
     * @returns {Loader} For chaining
     */
    bootstrap: function (bootstraps) {
        var loader = this;

        // Now execute any bootstraps against the environment, before any modules run
        bootstraps.forEach(function (bootstrap) {
            // If the bootstrap returned a function, invoke it with the environment,
            // otherwise do nothing (the bootstrap module has already had the chance to run)
            if (typeof bootstrap === 'function') {
                bootstrap(loader.getEnvironment());
            }
        });

        return loader;
    },

    /**
     * Populates the PHPify and PHPCore configurations
     *
     * @param {Object} phpifyConfig
     * @param {Object[]} phpCoreConfigs
     * @returns {Loader} For chaining
     */
    configure: function (phpifyConfig, phpCoreConfigs) {
        var loader = this;

        loader.phpifyConfig = phpifyConfig;
        loader.phpCoreConfig = loader.phpConfigImporter
            .importLibrary({configs: phpCoreConfigs})
            .mergeAll();

        return loader;
    },

    /**
     * Fetches the Environment for this loader, creating it if necessary
     *
     * @return {Environment}
     */
    getEnvironment: function () {
        var loader = this;

        if (!loader.environment) {
            loader.environment = loader.environmentProvider.createEnvironment(
                loader.fileSystem,
                loader.phpifyConfig,
                loader.phpCoreConfig
            );
        }

        return loader.environment;
    },

    /**
     * Fetches the module wrapper factory function for a compiled PHP module,
     * if it exists in the compiled bundle
     *
     * @param {string} filePath
     * @returns {Function}
     * @throws {Error} Throws when the specified compiled module does not exist
     */
    getModuleFactory: function (filePath) {
        return this.moduleRepository.getModuleFactory(filePath);
    },

    /**
     * Installs a function into the loader for fetching the compiled module wrappers of PHP modules
     *
     * @param {Function} phpModuleFactoryFetcher
     * @returns {Loader} For chaining
     */
    installModules: function (phpModuleFactoryFetcher) {
        var loader = this;

        loader.moduleRepository.init(phpModuleFactoryFetcher);

        return loader;
    },

    /**
     * Determines whether this loader has already been initialised
     * (whether the Environment has been created, lazily, when loading a PHP module)
     *
     * @return {boolean}
     */
    isInitialised: function () {
        return this.environment !== null;
    },

    /**
     * Configures the environment and path for the given module, and either executes it
     * and returns the result or just returns the module factory depending on mode.
     * Used by all compiled PHP modules
     *
     * @param {string} filePath
     * @param {Function} moduleFactory
     * @returns {Function|Promise|Value}
     */
    load: function (filePath, moduleFactory) {
        var loader = this;

        return loader.moduleRepository.load(filePath, moduleFactory, loader.getEnvironment());
    }
});

module.exports = Loader;


/***/ }),

/***/ "./node_modules/phpify/src/ModuleRepository.js":
/*!*****************************************************!*\
  !*** ./node_modules/phpify/src/ModuleRepository.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    hasOwn = {}.hasOwnProperty;

/**
 * Contains a cache of configured PHP modules and the module factory fetcher
 * to use for both fetching any as-yet unloaded modules and determining their existence
 *
 * @param {Object} requireCache
 * @constructor
 */
function ModuleRepository(requireCache) {
    /**
     * @type {Object.<string, Function>} PHP module factories, indexed by path
     */
    this.configuredModuleFactories = {};
    /**
     * @type {boolean} Indicates that a module's factory function should be returned without execution
     */
    this.loadingModuleFactoryOnly = false;
    /**
     * A special function, generated by the PHP module compiler,
     * that can be called to fetch the module wrapper of any compiled modules
     * or return true/false to determine whether they exist.
     * Note that this is set by the special Initialiser module
     * generated at compile-time (see Transformer)
     *
     * @type {Function|null}
     */
    this.moduleFactoryFetcher = null;
    /**
     * @type {Object} require.cache
     */
    this.requireCache = requireCache;
}

_.extend(ModuleRepository.prototype, {
    /**
     * Fetches the module wrapper factory function for a compiled PHP module,
     * if it exists in the compiled bundle
     *
     * @param {string} filePath
     * @returns {Function}
     * @throws {Error} Throws when the specified compiled module does not exist
     */
    getModuleFactory: function (filePath) {
        var cachePath,
            configuredModuleFactory,
            repository = this;

        if (hasOwn.call(repository.configuredModuleFactories, filePath)) {
            // Module has already been configured: return the cached module factory
            return repository.configuredModuleFactories[filePath];
        }

        // Module has not yet been loaded: require it via the fetcher function. The transpiled module
        // will call back into the loader via `.load(...)` to configure it.
        // The `loadingModuleFactoryOnly` flag ensures that the module is not executed,
        // only its module factory is exported instead
        repository.loadingModuleFactoryOnly = true;
        configuredModuleFactory = repository.moduleFactoryFetcher(filePath, false);
        repository.loadingModuleFactoryOnly = false;

        if (configuredModuleFactory === null) {
            throw new Error('File "' + filePath + '" is not in the compiled PHP file map');
        }

        // By this point, the require()'d module should have called back via .prepare()
        // [via <Public API::Loader>.run()] and so its wrapper should be in the
        if (!hasOwn.call(repository.configuredModuleFactories, filePath)) {
            throw new Error('Unexpected state: module "' + filePath + '" should have been loaded by now');
        }
        if (repository.configuredModuleFactories[filePath] !== configuredModuleFactory) {
            throw new Error('Unexpected state: factory for module "' + filePath + '" loaded incorrectly');
        }

        cachePath = './' + filePath;

        if (!hasOwn.call(repository.requireCache, cachePath)) {
            throw new Error('Expected path "' + cachePath + '" to be in require.cache, but it was not');
        }

        // Delete the module's exports object from the cache: it was not executed as we only wanted
        // to extract the factory function, so that will have been stored instead.
        // If the module's factory function is ever needed again, it will be fetched from the
        // .configuredModuleFactories[...] cache instead
        delete repository.requireCache[cachePath];

        return repository.configuredModuleFactories[filePath];
    },

    /**
     * Initializes the repository with a function
     * for fetching the compiled module wrappers of PHP modules
     *
     * @param {Function} phpModuleFactoryFetcher
     */
    init: function (phpModuleFactoryFetcher) {
        this.moduleFactoryFetcher = phpModuleFactoryFetcher;
    },

    /**
     * Configures the environment and path for the given module, and either executes it
     * and returns the result or just returns the module factory depending on mode.
     * Used by all compiled PHP modules
     *
     * @param {string} filePath
     * @param {Function} moduleFactory
     * @param {Environment} environment
     * @returns {Function}
     */
    load: function (filePath, moduleFactory, environment) {
        var repository = this,
            configuredModuleFactory = moduleFactory.using({path: filePath}, environment);

        repository.configuredModuleFactories[filePath] = configuredModuleFactory;

        if (repository.loadingModuleFactoryOnly) {
            // Only the factory is needed, don't execute
            return configuredModuleFactory;
        }

        // Create, execute and return the result of the module
        return configuredModuleFactory().execute();
    },

    /**
     * Determines whether the module with the given path exists in the bundle
     *
     * @param {string} filePath
     * @return {boolean}
     */
    moduleExists: function (filePath) {
        var repository = this;

        if (hasOwn.call(repository.configuredModuleFactories, filePath)) {
            // Module has already been configured: return the cached module factory
            return true;
        }

        // Module has not yet been loaded: determine its existence using the fetcher function.
        // To save space in the compiled bundle, the large switch statement with a case for each
        // compiled PHP module doubles as an existence-check (see Transformer for details)
        return repository.moduleFactoryFetcher(filePath, true);
    }
});

module.exports = ModuleRepository;


/***/ }),

/***/ "./node_modules/phpify/src/Performance.js":
/*!************************************************!*\
  !*** ./node_modules/phpify/src/Performance.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPify - Compiles PHP modules to CommonJS with Uniter
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpify
 *
 * Released under the MIT license
 * https://github.com/uniter/phpify/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Performance option wrapper
 *
 * @param {class} Date
 * @param {global} global
 * @constructor
 */
function Performance(Date, global) {
    /**
     * @type {class}
     */
    this.Date = Date;
    /**
     * @type {global}
     */
    this.global = global;
}

_.extend(Performance.prototype, {
    /**
     * Returns the time since the Unix epoch in microseconds
     *
     * @returns {number}
     */
    getTimeInMicroseconds: function () {
        var performance = this;

        if (performance.global.performance) {
            // Use 5-microsecond-precise Performance API, if available
            return (
                performance.global.performance.timing.navigationStart + performance.global.performance.now()
            ) * 1000;
        }

        // Fall back to fake microsecond accuracy (will be correct to the nearest millisecond)
        return new performance.Date().getTime() * 1000;
    }
});

module.exports = Performance;


/***/ }),

/***/ "./node_modules/phpify/src/php/initialiser_stub.php":
/*!**********************************************************!*\
  !*** ./node_modules/phpify/src/php/initialiser_stub.php ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").installModules(function (path, checkExistence) {
    var exists = false;

    function handlePath(aPath) {
        if (!checkExistence) {
            return aPath;
        }

        if (aPath === path) {
            exists = true;
        }

        // Return something that should not match with the path variable,
        // so that the case itself is not executed and we eventually
        // reach the return after the end of the switch
        return null;
    }

    switch (path) {
    case handlePath("src/Markdown.php"): return __webpack_require__(/*! ./../../../../src/Markdown.php */ "./src/Markdown.php");
    case handlePath("vendor/autoload.php"): return __webpack_require__(/*! ./../../../../vendor/autoload.php */ "./vendor/autoload.php");
    case handlePath("vendor/composer/autoload_classmap.php"): return __webpack_require__(/*! ./../../../../vendor/composer/autoload_classmap.php */ "./vendor/composer/autoload_classmap.php");
    case handlePath("vendor/composer/autoload_namespaces.php"): return __webpack_require__(/*! ./../../../../vendor/composer/autoload_namespaces.php */ "./vendor/composer/autoload_namespaces.php");
    case handlePath("vendor/composer/autoload_psr4.php"): return __webpack_require__(/*! ./../../../../vendor/composer/autoload_psr4.php */ "./vendor/composer/autoload_psr4.php");
    case handlePath("vendor/composer/autoload_real.php"): return __webpack_require__(/*! ./../../../../vendor/composer/autoload_real.php */ "./vendor/composer/autoload_real.php");
    case handlePath("vendor/composer/autoload_static.php"): return __webpack_require__(/*! ./../../../../vendor/composer/autoload_static.php */ "./vendor/composer/autoload_static.php");
    case handlePath("vendor/composer/ClassLoader.php"): return __webpack_require__(/*! ./../../../../vendor/composer/ClassLoader.php */ "./vendor/composer/ClassLoader.php");
    case handlePath("vendor/composer/installed.php"): return __webpack_require__(/*! ./../../../../vendor/composer/installed.php */ "./vendor/composer/installed.php");
    case handlePath("vendor/composer/InstalledVersions.php"): return __webpack_require__(/*! ./../../../../vendor/composer/InstalledVersions.php */ "./vendor/composer/InstalledVersions.php");
    }

    return checkExistence ? exists : null;
})
.configure({"stdio":true}, [__webpack_require__(/*! ./node_modules/uniter-markdown-plugin/dist/config.phpcore */ "./node_modules/uniter-markdown-plugin/dist/config.phpcore.js"), {}])
.bootstrap([__webpack_require__(/*! ./../../../../browser/bootstrap.js */ "./browser/bootstrap.js")]);

/***/ }),

/***/ "./node_modules/phpruntime/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/phpruntime/constants.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = {
    sapi: 'cli',

    operatingSystem: {
        name: 'Uniter',           // Operating system name. eg. FreeBSD
        hostName: 'localhost',    // Host name. eg. localhost.example.com
        releaseName: '1.0.0',     // Release name. eg. 5.1.2-RELEASE
        versionInfo: '(Generic)', // Version information. Varies a lot between operating systems
        machineType: 'JavaScript' // Machine type. eg. i386
    },

    phpVersion: {
        major: 5,
        minor: 4,
        release: 0
    },

    zendVersion: {
        major: 2,
        minor: 5,
        release: 0
    }
};


/***/ }),

/***/ "./node_modules/phpruntime/psync.js":
/*!******************************************!*\
  !*** ./node_modules/phpruntime/psync.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */

/**
 * "Promise-synchronous" (psync) mode entrypoint
 *
 * Allows the public API to be Promise-based even when not using Pausable,
 * so that switching to/from async mode does not require changes to the consuming application.
 */



var builtins = __webpack_require__(/*! ./src/builtin/builtins */ "./node_modules/phpruntime/src/builtin/builtins.js"),
    runtime = __webpack_require__(/*! phpcore/psync */ "./node_modules/phpcore/psync.js");

runtime.install(builtins);

module.exports = runtime;


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/bindings/string.js":
/*!****************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/bindings/string.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var FormatConverter = __webpack_require__(/*! ./string/FormatConverter */ "./node_modules/phpruntime/src/builtin/bindings/string/FormatConverter.js"),
    FormatParser = __webpack_require__(/*! ./string/FormatParser */ "./node_modules/phpruntime/src/builtin/bindings/string/FormatParser.js"),
    Formatter = __webpack_require__(/*! ./string/Formatter */ "./node_modules/phpruntime/src/builtin/bindings/string/Formatter.js"),
    NativeFormatter = __webpack_require__(/*! ./string/NativeFormatter */ "./node_modules/phpruntime/src/builtin/bindings/string/NativeFormatter.js");

/**
 * String handling bindings
 */
module.exports = function () {
    return {
        stringFormatter: function () {
            return new Formatter(new NativeFormatter(new FormatParser(), new FormatConverter()));
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/bindings/string/Exception/MissingFormatArgumentException.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/bindings/string/Exception/MissingFormatArgumentException.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    Exception = phpCommon.Exception;

/**
 * Thrown when a format by the printf(...) family of functions is missing an argument
 *
 * @param {number} argumentPosition
 * @constructor
 */
function MissingFormatArgumentException(argumentPosition) {
    Exception.call(this, 'Missing argument #' + (argumentPosition + 1));

    /**
     * @type {number}
     */
    this.argumentPosition = argumentPosition;
}

util.inherits(MissingFormatArgumentException, Exception);

module.exports = MissingFormatArgumentException;


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/bindings/string/FormatConverter.js":
/*!********************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/bindings/string/FormatConverter.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Processes a conversion specification supported by the printf(...) family of functions
 *
 * @constructor
 */
function FormatConverter() {
}

_.extend(FormatConverter.prototype, {
    /**
     * Processes a conversion specification, converting the specified value to a string
     *
     * @param {*} value
     * @param {object} directive
     * @returns {string}
     */
    convert: function (value, directive) {
        switch (directive.type) {
            case 'signed-decimal': // eg. "%d"
                /*jshint bitwise: false */
                value = value >> 0; // Cast to signed integer number

                if (directive.showPositiveSign && value > 0) {
                    value = '+' + value;
                }

                value += ''; // Cast to string

                // Alignment specifiers for printf(...) refer to which side the number should be on,
                // but .padStart(...) and .padEnd(...) refer to which side the _padding_ should be on (the opposite)
                // which is why these might seem reversed
                value = directive.alignmentSpecifier === 'right' ?
                    value.padStart(directive.widthSpecifier, directive.paddingCharacter) :
                    value.padEnd(directive.widthSpecifier, directive.paddingCharacter);

                return value;
            case 'string': // eg. "%s"
                return value;
            default:
                throw new Error('Unsupported conversion specification type "' + directive.type + '"');
        }
    }
});

module.exports = FormatConverter;


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/bindings/string/FormatParser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/bindings/string/FormatParser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    TYPE_SPECIFIER_TO_TYPE = {
        'b': 'binary',
        'c': 'ascii-character',
        'd': 'signed-decimal',
        'e': 'lower-exponent',
        'E': 'upper-exponent',
        'f': 'locale-aware-float',
        'F': 'locale-unaware-float',
        'g': 'lower-exponent-or-float',
        'G': 'upper-exponent-or-float',
        'o': 'octal',
        's': 'string',
        'u': 'unsigned-decimal',
        'x': 'lower-hexadecimal',
        'X': 'upper-hexadecimal'
    };

/**
 * Parses strings that use the format supported by the printf(...) family of functions
 *
 * @constructor
 */
function FormatParser() {
}

_.extend(FormatParser.prototype, {
    /**
     * Parses the provided format string to a list of directives
     *
     * @param {string} formatString
     * @returns {object[]}
     */
    parse: function (formatString) {
        var alignmentSpecifier,
            directives = [],
            explicitArgumentPosition,
            lastMatchEnd = 0,
            match,
            nextArgumentPosition = 0,
            regex = /%(?:(\d+)\$)?(\+)?(?:([ 0])|'(.))?(-)?(\d+)?(?:\.(\D)?(\d+))?([%bcdeEfFgGosuxX])/g,
            paddingCharacter,
            precisionSpecifier,
            showPositiveNumberSigns,
            typeSpecifier,
            widthSpecifier;

        while ((match = regex.exec(formatString)) !== null) {
            if (match[9] === '%') {
                continue;
            }

            if (lastMatchEnd < match.index) {
                directives.push({
                    kind: 'ordinary',
                    text: formatString.substring(lastMatchEnd, match.index)
                        // Resolve escapes back to a single literal "%" character
                        .replace(/%%/g, '%')
                });
            }

            explicitArgumentPosition = match[1] ? match[1] * 1 - 1 : null;

            // Sign specifier - prefix positive numbers with "+"
            // (by default only negatives are prefixed, with "-")
            showPositiveNumberSigns = !!match[2];

            // Padding character - 0 or a space, or another character if prefixed with a single quote
            paddingCharacter = match[3] || match[4] || ' ';

            // Whether to justify to the left or to the right (default is to the right)
            alignmentSpecifier = match[5] === '-' ? 'left': 'right';

            // The minimum no. of characters this conversion should result in
            // (using the padding character determined above)
            widthSpecifier = (match[6] || 0) * 1;

            if (match[7]) {
                // The character to use to pad a number may optionally be specified
                // between the period and the digit
                paddingCharacter = match[7];
            }

            // For a number this specifies how many decimal digits to display after the decimal point.
            // For a string this acts as a cutoff, specifying the maximum length it will be truncated to
            precisionSpecifier = (match[8] || 0) * 1;

            typeSpecifier = match[9];

            if (typeSpecifier === 's') {
                directives.push({
                    kind: 'conversion-specification',
                    argumentPosition: explicitArgumentPosition || nextArgumentPosition,
                    type: 'string'
                });
            } else {
                directives.push({
                    kind: 'conversion-specification',
                    argumentPosition: explicitArgumentPosition || nextArgumentPosition,
                    type: TYPE_SPECIFIER_TO_TYPE[typeSpecifier],
                    showPositiveSign: showPositiveNumberSigns,
                    paddingCharacter: paddingCharacter,
                    alignmentSpecifier: alignmentSpecifier,
                    widthSpecifier: widthSpecifier,
                    precisionSpecifier: precisionSpecifier
                });
            }

            if (explicitArgumentPosition === null) {
                nextArgumentPosition++;
            }

            lastMatchEnd = match.index + match[0].length;
        }

        if (lastMatchEnd < formatString.length) {
            directives.push({
                kind: 'ordinary',
                text: formatString.substr(lastMatchEnd)
                    // Resolve escapes back to a single literal "%" character
                    .replace(/%%/g, '%')
            });
        }

        return directives;
    }
});

module.exports = FormatParser;


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/bindings/string/Formatter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/bindings/string/Formatter.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js");

/**
 * Formats a string according to the format supported by the printf(...) family of functions
 *
 * @param {NativeFormatter} nativeFormatter
 * @constructor
 */
function Formatter(nativeFormatter) {
    /**
     * @type {NativeFormatter}
     */
    this.nativeFormatter = nativeFormatter;
}

_.extend(Formatter.prototype, {
    /**
     * Builds and returns the provided format string populated with the given arguments
     *
     * @param {string} formatString
     * @param {Reference[]|Value[]|Variable[]} argReferences
     * @returns {string}
     */
    format: function (formatString, argReferences) {
        var argNatives = argReferences.map(function (argReference) {
            var argValue = argReference.getValue();

            if (argValue.getType() === 'object' || argValue.getType() === 'array') {
                argValue = argValue.coerceToString();
            }

            return argValue.getNative();
        });

        return this.nativeFormatter.format(formatString, argNatives);
    }
});

module.exports = Formatter;


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/bindings/string/NativeFormatter.js":
/*!********************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/bindings/string/NativeFormatter.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    Exception = phpCommon.Exception,
    MissingFormatArgumentException = __webpack_require__(/*! ./Exception/MissingFormatArgumentException */ "./node_modules/phpruntime/src/builtin/bindings/string/Exception/MissingFormatArgumentException.js");

/**
 * Formats a string according to the format supported by the printf(...) family of functions
 *
 * @param {FormatParser} formatParser
 * @param {FormatConverter} formatConverter
 * @constructor
 */
function NativeFormatter(formatParser, formatConverter) {
    /**
     * @type {FormatConverter}
     */
    this.formatConverter = formatConverter;
    /**
     * @type {FormatParser}
     */
    this.formatParser = formatParser;
}

_.extend(NativeFormatter.prototype, {
    /**
     * Builds and returns the provided format string populated with the given arguments
     *
     * @param {string} formatString
     * @param {array} args
     * @returns {string}
     */
    format: function (formatString, args) {
        var formatter = this,
            directives = formatter.formatParser.parse(formatString);

        args = args || [];

        return directives
            .map(function (directive) {
                var arg;

                if (directive.kind === 'ordinary') {
                    // Plain text - just output as it was in the format string
                    return directive.text;
                }

                if (directive.kind === 'conversion-specification') {
                    // Conversion specifications are the placeholders "%s", "%d" etc.

                    if (directive.argumentPosition >= args.length) {
                        throw new MissingFormatArgumentException(directive.argumentPosition);
                    }

                    arg = args[directive.argumentPosition];

                    // Perform the conversion
                    return formatter.formatConverter.convert(arg, directive);
                }

                throw new Exception('Unsupported directive kind "' + directive.kind + '"');
            })
            .join('');
    }
});

module.exports = NativeFormatter;


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/builtins.js":
/*!*********************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/builtins.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var arrayConstants = __webpack_require__(/*! ./constants/array */ "./node_modules/phpruntime/src/builtin/constants/array.js"),
    arrayFunctions = __webpack_require__(/*! ./functions/array */ "./node_modules/phpruntime/src/builtin/functions/array.js"),
    baseConversionMathFunctions = __webpack_require__(/*! ./functions/math/baseConversion */ "./node_modules/phpruntime/src/builtin/functions/math/baseConversion.js"),
    classFunctions = __webpack_require__(/*! ./functions/class */ "./node_modules/phpruntime/src/builtin/functions/class.js"),
    configOptionsAndInfoFunctions = __webpack_require__(/*! ./functions/optionsAndInfo/config */ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/config.js"),
    constantFunctions = __webpack_require__(/*! ./functions/misc/constant */ "./node_modules/phpruntime/src/builtin/functions/misc/constant.js"),
    Countable = __webpack_require__(/*! ./interfaces/SPL/Countable */ "./node_modules/phpruntime/src/builtin/interfaces/SPL/Countable.js"),
    environmentFunctions = __webpack_require__(/*! ./functions/optionsAndInfo/environment */ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/environment.js"),
    errorHandlingFunctions = __webpack_require__(/*! ./functions/errorHandling */ "./node_modules/phpruntime/src/builtin/functions/errorHandling.js"),
    extensionOptionsAndInfoFunctions = __webpack_require__(/*! ./functions/optionsAndInfo/extension */ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/extension.js"),
    filesystemConstants = __webpack_require__(/*! ./constants/filesystem */ "./node_modules/phpruntime/src/builtin/constants/filesystem.js"),
    filesystemFunctions = __webpack_require__(/*! ./functions/filesystem */ "./node_modules/phpruntime/src/builtin/functions/filesystem.js"),
    functionHandlingFunctions = __webpack_require__(/*! ./functions/functionHandling */ "./node_modules/phpruntime/src/builtin/functions/functionHandling.js"),
    htmlStringFunctions = __webpack_require__(/*! ./functions/string/html */ "./node_modules/phpruntime/src/builtin/functions/string/html.js"),
    InvalidArgumentException = __webpack_require__(/*! ./classes/Exception/InvalidArgumentException */ "./node_modules/phpruntime/src/builtin/classes/Exception/InvalidArgumentException.js"),
    LogicException = __webpack_require__(/*! ./classes/Exception/LogicException */ "./node_modules/phpruntime/src/builtin/classes/Exception/LogicException.js"),
    outputControlFunctions = __webpack_require__(/*! ./functions/outputControl */ "./node_modules/phpruntime/src/builtin/functions/outputControl.js"),
    pcreCommonFunctions = __webpack_require__(/*! ./functions/pcre/common */ "./node_modules/phpruntime/src/builtin/functions/pcre/common.js"),
    pcreConstants = __webpack_require__(/*! ./constants/pcre */ "./node_modules/phpruntime/src/builtin/constants/pcre.js"),
    phpConstants = __webpack_require__(/*! ./constants/php */ "./node_modules/phpruntime/src/builtin/constants/php.js"),
    phpOptionsAndInfoFunctions = __webpack_require__(/*! ./functions/optionsAndInfo/php */ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/php.js"),
    splFunctions = __webpack_require__(/*! ./functions/spl */ "./node_modules/phpruntime/src/builtin/functions/spl.js"),
    stringBindings = __webpack_require__(/*! ./bindings/string */ "./node_modules/phpruntime/src/builtin/bindings/string.js"),
    stringConstants = __webpack_require__(/*! ./constants/string */ "./node_modules/phpruntime/src/builtin/constants/string.js"),
    stringFunctions = __webpack_require__(/*! ./functions/string */ "./node_modules/phpruntime/src/builtin/functions/string.js"),
    timeDateAndTimeFunctions = __webpack_require__(/*! ./functions/dateAndTime/time */ "./node_modules/phpruntime/src/builtin/functions/dateAndTime/time.js"),
    timeFunctions = __webpack_require__(/*! ./functions/misc/time */ "./node_modules/phpruntime/src/builtin/functions/misc/time.js"),
    variableHandlingFunctions = __webpack_require__(/*! ./functions/variableHandling */ "./node_modules/phpruntime/src/builtin/functions/variableHandling.js");

module.exports = {
    bindingGroups: [
        stringBindings
    ],
    classGroups: [
        function () {
            return {
                'Countable': Countable
            };
        },
        function () {
            return {
                'LogicException': LogicException
            };
        },
        function () {
            return {
                'InvalidArgumentException': InvalidArgumentException
            };
        }
    ],
    constantGroups: [
        arrayConstants,
        filesystemConstants,
        pcreConstants,
        phpConstants,
        stringConstants
    ],
    functionGroups: [
        arrayFunctions,
        baseConversionMathFunctions,
        classFunctions,
        configOptionsAndInfoFunctions,
        constantFunctions,
        environmentFunctions,
        errorHandlingFunctions,
        extensionOptionsAndInfoFunctions,
        filesystemFunctions,
        functionHandlingFunctions,
        htmlStringFunctions,
        outputControlFunctions,
        pcreCommonFunctions,
        phpOptionsAndInfoFunctions,
        splFunctions,
        stringFunctions,
        timeDateAndTimeFunctions,
        timeFunctions,
        variableHandlingFunctions
    ]
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/classes/Exception/InvalidArgumentException.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/classes/Exception/InvalidArgumentException.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Exception thrown if an argument is not of the expected type
     *
     * @see {@link https://secure.php.net/manual/en/class.invalidargumentexception.php}
     * @constructor
     */
    function InvalidArgumentException() {
        internals.callSuperConstructor(this, arguments);
    }

    // Extend the base PHP LogicException class
    internals.extendClass('LogicException');

    internals.disableAutoCoercion();

    return InvalidArgumentException;
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/classes/Exception/LogicException.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/classes/Exception/LogicException.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    /**
     * Exception representing an issue with the logic of the program
     *
     * @see {@link https://secure.php.net/manual/en/class.logicexception.php}
     * @constructor
     */
    function LogicException() {
        internals.callSuperConstructor(this, arguments);
    }

    // Extend the base PHP Exception class
    internals.extendClass('Exception');

    internals.disableAutoCoercion();

    return LogicException;
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/constants/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/constants/array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    return {
        'COUNT_NORMAL': 0,
        'COUNT_RECURSIVE': 1
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/constants/filesystem.js":
/*!*********************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/constants/filesystem.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    return {
        'DIRECTORY_SEPARATOR': '/',
        'PATH_SEPARATOR': ':' // Be Unix-y and use colon rather than semi-colon (Windows)
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/constants/pcre.js":
/*!***************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/constants/pcre.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    return {
        'PREG_OFFSET_CAPTURE': 256,
        'PREG_PATTERN_ORDER': 1,
        'PREG_SET_ORDER': 2
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/constants/php.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/constants/php.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var systemConstants = __webpack_require__(/*! ../../../constants */ "./node_modules/phpruntime/constants.js");

module.exports = function () {
    // NB: Some of the most basic constants (eg. PHP_EOL) are defined by the PHPCore library

    return {
        'PHP_OS': 'Uniter',
        'PHP_SAPI': systemConstants.sapi,
        'PHP_VERSION':
            systemConstants.phpVersion.major + '.' +
            systemConstants.phpVersion.minor + '.' +
            systemConstants.phpVersion.release,
        'PHP_VERSION_ID':
            systemConstants.phpVersion.major * 10000 +
            systemConstants.phpVersion.minor * 100 +
            systemConstants.phpVersion.release
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/constants/string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/constants/string.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    return {
        'HTML_SPECIALCHARS': 0,
        'HTML_ENTITIES': 1,

        'ENT_NOQUOTES': 0,
        'ENT_COMPAT': 2,
        'ENT_QUOTES': 3,

        'ENT_HTML401': 0,

        'ENT_SUBSTITUTE': 8 // Not applicable, as JS string literals cannot contain invalid Unicode escape sequences
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    hasOwn = {}.hasOwnProperty,
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    COUNT_NORMAL = 0,
    IMPLODE = 'implode',
    KeyValuePair = __webpack_require__(/*! phpcore/src/KeyValuePair */ "./node_modules/phpcore/src/KeyValuePair.js"),
    SORT_REGULAR = 0,
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        globalNamespace = internals.globalNamespace,
        methods,
        valueFactory = internals.valueFactory;

    methods = {
        /**
         * Determines the difference between arrays. A new array will be returned,
         * with all the elements of the first array that are not present in any of the other arrays
         *
         * @see {@link https://secure.php.net/manual/en/function.array-diff.php}
         *
         * @returns {ArrayValue|NullValue}
         */
        'array_diff': function () {
            var firstArrayValue,
                remainingElementPairs,
                returnNull = false;

            if (arguments.length < 2) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'array_diff() expects at least 2 parameters, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            firstArrayValue = arguments[0].getValue();

            if (firstArrayValue.getType() !== 'array') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'array_diff(): Argument #0 is not an array'
                );
                return valueFactory.createNull();
            }

            // Start with the key-value pairs for the elements of the first array,
            // as for each successive array we will compare their values against the values
            // of this first one
            remainingElementPairs = firstArrayValue.getKeys().map(function (keyValue) {
                return firstArrayValue.getElementPairByKey(keyValue);
            });

            _.each([].slice.call(arguments, 1), function (arrayReference, argumentIndex) {
                var arrayValue = arrayReference.getValue();

                if (arrayValue.getType() !== 'array') {
                    callStack.raiseError(
                        PHPError.E_WARNING,
                        'array_diff(): Argument #' + (argumentIndex + 2) + ' is not an array'
                    );
                    returnNull = true;
                    return false;
                }

                _.each(arrayValue.getKeys(), function (keyValue) {
                    var elementValue = arrayValue.getElementByKey(keyValue).getValue();

                    remainingElementPairs = remainingElementPairs.filter(function (remainingElementPair) {
                        return elementValue.getValue().isNotEqualTo(remainingElementPair.getValue()).getNative();
                    });
                });
            });

            if (returnNull) {
                return valueFactory.createNull();
            }

            return valueFactory.createArray(remainingElementPairs);
        },

        /**
         * Determines whether the given key or index exists in the array
         *
         * @see {@link https://secure.php.net/manual/en/function.array-key-exists.php}
         *
         * @param {Variable|Value} keyReference
         * @param {Variable|ArrayValue} arrayReference
         * @returns {BooleanValue}
         */
        'array_key_exists': function (keyReference, arrayReference) {
            var arrayValue,
                keyValue;

            keyValue = keyReference.getValue();
            arrayValue = arrayReference.getValue();

            return valueFactory.createBoolean(arrayValue.getElementByKey(keyValue).isDefined());
        },

        /**
         * Fetch all keys (or a subset of the keys) in an array
         *
         * @see {@link https://secure.php.net/manual/en/function.array-keys.php}
         *
         * @param {Variable|ArrayValue} arrayReference
         * @param {Variable|Value} searchValueReference
         * @param {Variable|BooleanValue} strictMatchReference
         * @returns {ArrayValue}
         */
        'array_keys': function (arrayReference, searchValueReference, strictMatchReference) {
            var arrayValue;

            if (searchValueReference || strictMatchReference) {
                throw new Error('array_keys() :: Search functionality is not yet supported');
            }

            arrayValue = arrayReference.getValue();

            return valueFactory.createArray(arrayValue.getKeys());
        },

        /**
         * Maps one or more arrays to a new array
         *
         * @see {@link https://secure.php.net/manual/en/function.array-map.php}
         *
         * @param {Variable|Value} callbackReference
         * @param {Variable|ArrayValue} firstArrayReference
         * @returns {ArrayValue}
         */
        'array_map': function (callbackReference, firstArrayReference) {
            var callbackValue = callbackReference.getValue(),
                firstArrayValue = firstArrayReference.getValue(),
                result = [];

            if (arguments.length > 2) {
                throw new Error('array_map() :: Multiple input arrays are not yet supported');
            }

            _.each(firstArrayValue.getKeys(), function (keyValue) {
                // Pass the global namespace as the namespace scope -
                // any normal function callback will need to be fully-qualified
                // TODO: Test what happens with barewords, eg. `array_map(MyClass::staticMethod, [...])`
                var elementValue = firstArrayValue.getElementByKey(keyValue),
                    // FIXME: This does not handle async mode!!
                    mappedElementValue = callbackValue.call([elementValue], globalNamespace);

                result.push(new KeyValuePair(keyValue, mappedElementValue));
            });

            return valueFactory.createArray(result);
        },

        /**
         * Merges one or more arrays together, returning a new array with the result
         *
         * @see {@link https://secure.php.net/manual/en/function.array-merge.php}
         *
         * @returns {IntegerValue}
         */
        'array_merge': function () {
            var nativeKeyToElementMap = {},
                mergedElements,
                nativeKeys = [],
                nextIndex = 0,
                returnNull = false;

            if (arguments.length === 0) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'array_merge() expects at least 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            _.each(arguments, function (arrayReference, argumentIndex) {
                var arrayValue = arrayReference.getValue();

                if (arrayValue.getType() !== 'array') {
                    callStack.raiseError(
                        PHPError.E_WARNING,
                        'array_merge(): Argument #' + (argumentIndex + 1) + ' is not an array'
                    );
                    returnNull = true;
                    return false;
                }

                _.each(arrayValue.getKeys(), function (key) {
                    var mergedKey,
                        nativeKey;

                    if (key.isNumeric()) {
                        nativeKey = nextIndex++;
                        mergedKey = valueFactory.createInteger(nativeKey);
                        nativeKeys.push(nativeKey);
                    } else {
                        nativeKey = key.getNative();
                        mergedKey = key;

                        if (!hasOwn.call(nativeKeyToElementMap, nativeKey)) {
                            nativeKeys.push(nativeKey);
                        }
                    }

                    nativeKeyToElementMap[nativeKey] = arrayValue.getElementPairByKey(key, mergedKey);
                });
            });

            if (returnNull) {
                return valueFactory.createNull();
            }

            mergedElements = _.map(nativeKeys, function (nativeKey) {
                return nativeKeyToElementMap[nativeKey];
            });

            return valueFactory.createArray(mergedElements);
        },

        /**
         * Pops the last element off the end of an array and returns it
         *
         * - Also resets the internal array pointer
         *
         * @see {@link https://secure.php.net/manual/en/function.array-pop.php}
         *
         * @param {Value|Variable|Reference} arrayReference
         * @return {Value}
         */
        'array_pop': function (arrayReference) {
            var arrayValue = arrayReference.getValue();

            return arrayValue.pop();
        },

        /**
         * Pushes one or more elements onto the end of an array
         *
         * @see {@link https://secure.php.net/manual/en/function.array-push.php}
         *
         * @param {Variable|ArrayValue} arrayReference
         * @returns {IntegerValue} The new length of the array after pushing
         */
        'array_push': function (arrayReference) {
            var arrayValue,
                i,
                reference,
                value;

            if (!arrayReference) {
                callStack.raiseError(PHPError.E_WARNING, 'array_push() expects at least 2 parameters, 0 given');
                return valueFactory.createNull();
            }

            arrayValue = arrayReference.getValue();

            for (i = 1; i < arguments.length; i++) {
                reference = arguments[i];
                value = reference.getValue();
                arrayValue.push(value);
            }

            return valueFactory.createInteger(arrayValue.getLength());
        },

        /**
         * Shifts an element off the beginning of an array
         *
         * @see {@link https://secure.php.net/manual/en/function.array-shift.php}
         *
         * @param {Variable|ArrayValue} arrayReference
         * @returns {ArrayValue}
         */
        'array_shift': function (arrayReference) {
            var arrayValue = arrayReference.getValue();

            return arrayValue.shift();
        },

        /**
         * Returns a new array without duplicate values from a source array
         *
         * @see {@link https://secure.php.net/manual/en/function.array-unique.php}
         *
         * @param {Variable|ArrayValue} arrayReference
         * @param {Variable|IntegerValue} sortFlagsReference
         * @returns {ArrayValue}
         */
        'array_unique': function (arrayReference, sortFlagsReference) {
            var arrayValue,
                resultPairs = [],
                usedValues = {};

            if (!arrayReference) {
                callStack.raiseError(PHPError.E_WARNING, 'array_unique() expects at least 1 parameter, 0 given');
                return valueFactory.createNull();
            }

            if (sortFlagsReference) {
                throw new Error('array_unique() :: Sort flags are not yet supported');
            }

            arrayValue = arrayReference.getValue();

            // Work on a copy, so we don't mutate the original array
            arrayValue = arrayValue.getForAssignment();

            // First sort the elements alphabetically by value (default/SORT_STRING behaviour)
            arrayValue.sort(function (elementA, elementB) {
                var nativeValueA = elementA.getValue().coerceToString().getNative(),
                    nativeValueB = elementB.getValue().coerceToString().getNative();

                return String(nativeValueB).localeCompare(nativeValueA);
            });

            _.each(arrayValue.getKeys(), function (keyValue) {
                var elementPair = arrayValue.getElementPairByKey(keyValue),
                    nativeValue = elementPair.getValue().coerceToString().getNative();

                if (hasOwn.call(usedValues, nativeValue)) {
                    return;
                }

                usedValues[nativeValue] = true;

                resultPairs.push(elementPair);
            });

            return valueFactory.createArray(resultPairs);
        },

        /**
         * Returns all the values from the array and indexes the array numerically.
         *
         * @see {@link http://php.net/manual/en/function.array-values.php}
         *
         * @param {Variable|Value} arrayReference
         * @returns {ArrayValue}
         */
        'array_values': function (arrayReference) {
            var arrayValue;

            if (!arrayReference) {
                callStack.raiseError(PHPError.E_WARNING, 'array_values() expects exactly 1 parameter, 0 given');
                return valueFactory.createNull();
            }

            arrayValue = arrayReference.getValue();

            return valueFactory.createArray(arrayValue.getValues());
        },

        /**
         * Counts the specified array or object. May be hooked
         * by implementing interface Countable
         *
         * @see {@link https://secure.php.net/manual/en/function.count.php}
         *
         * @param {Variable|Value} arrayReference
         * @param {Variable|Value} modeReference
         * @returns {IntegerValue}
         */
        'count': function (arrayReference, modeReference) {
            var array = arrayReference.getValue(),
                mode = modeReference ? modeReference.getNative() : 0,
                type = array.getType();

            if (type === 'object' && array.classIs('Countable')) {
                return array.callMethod('count');
            }

            if (mode !== COUNT_NORMAL) {
                throw new Error('Unsupported mode for count(...) :: ' + mode);
            }

            return valueFactory.createInteger(
                type === 'array' || type === 'object' ? array.getLength() : 1
            );
        },
        'current': function (arrayReference) {
            var arrayValue = arrayReference.getValue();

            if (arrayValue.getPointer() >= arrayValue.getLength()) {
                return valueFactory.createBoolean(false);
            }

            return arrayValue.getCurrentElement().getValue();
        },

        /**
         * Set the internal pointer of an array to its last element,
         * returning the value of that last element.
         * False will be returned for an empty array
         *
         * @see {@link https://secure.php.net/manual/en/function.end.php}
         *
         * @param {Variable|Value} arrayReference
         * @returns {Value}
         */
        'end': function (arrayReference) {
            var arrayValue = arrayReference.getValue(),
                keys = arrayValue.getKeys();

            if (keys.length === 0) {
                return valueFactory.createBoolean(false);
            }

            // Advance the array's internal pointer to the last element
            arrayValue.setPointer(keys.length - 1);

            return arrayValue.getElementByKey(keys[keys.length - 1]).getValue();
        },

        'implode': function (glueReference, piecesReference) {
            var glueValue = glueReference.getValue(),
                piecesValue = piecesReference.getValue(),
                tmp,
                values;

            // For backwards-compatibility, PHP supports receiving args in either order
            if (glueValue.getType() === 'array') {
                tmp = glueValue;
                glueValue = piecesValue;
                piecesValue = tmp;
            }

            values = piecesValue.getValues();

            _.each(values, function (value, key) {
                values[key] = value.coerceToString().getNative();
            });

            return valueFactory.createString(values.join(glueValue.getNative()));
        },

        /**
         * Determines whether a value (the "needle") exists in a given array (the "haystack")
         *
         * @see {@link https://secure.php.net/manual/en/function.in-array.php}
         *
         * @param {Variable|Value} needleReference
         * @param {Variable|Value} haystackReference
         * @param {Variable|Value} strictMatchReference
         * @returns {BooleanValue}
         */
        'in_array': function (needleReference, haystackReference, strictMatchReference) {
            var contains = false,
                haystackValue,
                needleValue,
                strictMatch;

            haystackValue = haystackReference.getValue();
            needleValue = needleReference.getValue();
            strictMatch = strictMatchReference ? strictMatchReference.getNative() : false;

            _.each(haystackValue.getValues(), function (elementValue) {
                if (
                    (strictMatch && elementValue.isIdenticalTo(needleValue).getNative()) ||
                    (!strictMatch && elementValue.isEqualTo(needleValue).getNative())
                ) {
                    contains = true;
                    return false;
                }
            });

            return valueFactory.createBoolean(contains);
        },

        'join': function (glueReference, piecesReference) {
            return methods[IMPLODE](glueReference, piecesReference);
        },

        /**
         * Fetches the key for the element the array's internal pointer is pointing at
         *
         * @see {@link https://secure.php.net/manual/en/function.key.php}
         *
         * @param {ArrayValue|Reference|Variable|Value} arrayReference
         * @return {Value}
         */
        'key': function (arrayReference) {
            var arrayValue,
                currentKey;

            if (!arrayReference) {
                callStack.raiseError(PHPError.E_WARNING, 'key() expects exactly 1 parameter, 0 given');
                return valueFactory.createNull();
            }

            arrayValue = arrayReference.getValue();

            if (arrayValue.getType() !== 'array') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'key() expects parameter 1 to be array, ' +
                    arrayValue.getType() +
                    ' given'
                );
                return valueFactory.createNull();
            }

            currentKey = arrayValue.getKeyByIndex(arrayValue.getPointer());

            return currentKey !== null ?
                currentKey :
                valueFactory.createNull();
        },

        /**
         * Sorts an array in-place, by key, in reverse order
         *
         * @see {@link https://secure.php.net/manual/en/function.krsort.php}
         *
         * @param {Variable|Value} arrayReference
         * @param {Variable|Value|undefined} sortFlagsReference
         * @returns {IntegerValue}
         */
        'krsort': function (arrayReference, sortFlagsReference) {
            var arrayValue,
                sortFlags;

            if (!arrayReference) {
                callStack.raiseError(PHPError.E_WARNING, 'krsort() expects at least 1 parameter, 0 given');
                return valueFactory.createBoolean(false);
            }

            arrayValue = arrayReference.getValue();
            sortFlags = sortFlagsReference ? sortFlagsReference.getValue().getNative() : SORT_REGULAR;

            if (arrayValue.getType() !== 'array') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'krsort() expects parameter 1 to be array, ' +
                    arrayValue.getType() +
                    ' given'
                );
                return valueFactory.createBoolean(false);
            }

            if (sortFlags !== SORT_REGULAR) {
                throw new Error(
                    'krsort() :: Only SORT_REGULAR (' +
                    SORT_REGULAR +
                    ') is supported, ' +
                    sortFlags +
                    ' given'
                );
            }

            arrayValue.sort(function (elementA, elementB) {
                var nativeKeyA = elementA.getKey().getNative(),
                    nativeKeyB = elementB.getKey().getNative();

                return String(nativeKeyB).localeCompare(nativeKeyA);
            });

            return valueFactory.createBoolean(true);
        },
        'next': function (arrayReference) {
            var arrayValue = arrayReference.getValue();

            if (arrayValue.getType() !== 'array') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'next() expects parameter 1 to be array, ' +
                    arrayValue.getType() +
                    ' given'
                );
                return valueFactory.createNull();
            }

            arrayValue.setPointer(arrayValue.getPointer() + 1);

            if (arrayValue.getPointer() >= arrayValue.getLength()) {
                return valueFactory.createBoolean(false);
            }

            return arrayValue.getCurrentElement().getValue();
        },

        /**
         * Alias of count()
         *
         * @see {@link https://secure.php.net/manual/en/function.sizeof.php}
         *
         * @param {Variable|Value} arrayReference
         * @param {Variable|Value} modeReference
         * @returns {IntegerValue}
         */
        'sizeof': 'count'
    };

    return methods;
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/class.js":
/*!****************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/class.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        classAutoloader = internals.classAutoloader,
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Determines whether the specified class exists
         *
         * @see {@link https://secure.php.net/manual/en/function.class-exists.php}
         *
         * @param {Variable|Value} classNameReference      The name of the class to check for
         * @param {Variable|Value} callAutoloaderReference True to invoke the autoloader, false otherwise
         * @returns {BooleanValue}
         */
        'class_exists': function (classNameReference, callAutoloaderReference) {
            var className = classNameReference.getNative(),
                callAutoloader = callAutoloaderReference ? callAutoloaderReference.getNative() : true;

            // Autoload the class if not already defined and autoloading is requested
            if (!globalNamespace.hasClass(className) && callAutoloader) {
                classAutoloader.autoloadClass(className);
            }

            return valueFactory.createBoolean(globalNamespace.hasClass(className));
        },

        /**
         * Fetches the name of either the current class or the class of a specified object
         *
         * @see {@link https://secure.php.net/manual/en/function.get-class.php}
         *
         * @param {Variable|Value} objectReference
         * @returns {StringValue|BooleanValue}
         */
        'get_class': function (objectReference) {
            var currentClass,
                objectValue;

            if (!objectReference) {
                currentClass = callStack.getCallerScope().getCurrentClass();

                if (!currentClass) {
                    callStack.raiseError(
                        PHPError.E_WARNING,
                        'get_class() called without object from outside a class'
                    );

                    return valueFactory.createBoolean(false);
                }

                return valueFactory.createString(currentClass.getName());
            }

            objectValue = objectReference.getValue();

            if (objectValue.getType() !== 'object') {
                // If specified, the value must be an object
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'get_class() expects parameter 1 to be object, ' + objectValue.getType() + ' given'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createString(objectValue.getClassName());
        },

        /**
         * Checks if the object is of this class or has this class as one of its parents
         *
         * @see {@link https://secure.php.net/manual/en/function.is-a.php}
         *
         * @param {Variable|Value} objectReference
         * @param {Variable|Value} classNameReference
         * @param {Variable|Value} allowStringReference
         * @returns {BooleanValue}
         */
        'is_a': function (objectReference, classNameReference, allowStringReference) {
            var allowString,
                className,
                classNameValue,
                objectValue;

            objectValue = objectReference.getValue();
            classNameValue = classNameReference.getValue();

            className = classNameValue.getNative();
            allowString = allowStringReference ? allowStringReference.getNative() : false;

            if (objectValue.getType() === 'object') {
                return valueFactory.createBoolean(objectValue.classIs(className));
            }

            if (objectValue.getType() === 'string') {
                if (!allowString) {
                    // First arg is not allowed to be a string - just return false (no warning/notice)
                    return valueFactory.createBoolean(false);
                }

                return valueFactory.createBoolean(
                    globalNamespace.getClass(objectValue.getNative()).is(className)
                );
            }

            // Invalid "object" given - just return false (no warning/notice)
            return valueFactory.createBoolean(false);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/dateAndTime/time.js":
/*!***************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/dateAndTime/time.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var PHPError = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js").PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        optionSet = internals.optionSet,
        valueFactory = internals.valueFactory;

    function getPerformance() {
        var performance = optionSet.getOption('performance');

        if (!performance) {
            throw new Error('performance :: No `performance` option is configured');
        }

        return performance;
    }

    return {
        /**
         * Fetches the current Unix timestamp with microseconds
         *
         * @see {@link https://secure.php.net/manual/en/function.microtime.php}
         *
         * @param {Variable|Value} getAsFloatReference Whether to return a float with seconds + us
         * @returns {FloatValue|StringValue}
         */
        'microtime': function (getAsFloatReference) {
            var getAsFloat,
                getAsFloatValue = getAsFloatReference ?
                    getAsFloatReference.getValue() :
                    null,
                timeInSeconds;

            if (getAsFloatValue && /^(array|object)$/.test(getAsFloatValue.getType())) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'microtime() expects parameter 1 to be boolean, ' +
                    getAsFloatValue.getType() +
                    ' given'
                );
                return valueFactory.createNull();
            }

            // Default value (if argument is omitted) is `false`
            getAsFloat = getAsFloatValue ? getAsFloatValue.coerceToBoolean().getNative() : false;

            // Convert microseconds to seconds (with decimal precision to maintain microsecond accuracy)
            timeInSeconds = getPerformance().getTimeInMicroseconds() / 1000000;

            if (getAsFloat) {
                // Return the time since the Unix epoch in seconds, with microsecond accuracy
                // as a float
                return valueFactory.createFloat(timeInSeconds);
            }

            // Return the number of microseconds into the current second first, followed by
            // the number of whole seconds since the Unix epoch
            return valueFactory.createString(
                (timeInSeconds % 1).toFixed(6) + ' ' +
                Math.floor(timeInSeconds)
            );
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/errorHandling.js":
/*!************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/errorHandling.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var PHPError = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js").PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        errorConfiguration = internals.errorConfiguration,
        valueFactory = internals.valueFactory,
        // Maps the error type PHP constant name to the internal PHPError type that should be raised
        ERROR_CONSTANT_NAME_TO_LEVEL = {
            'E_USER_DEPRECATED': PHPError.E_DEPRECATED,
            'E_USER_ERROR': PHPError.E_ERROR,
            'E_USER_NOTICE': PHPError.E_NOTICE,
            'E_USER_WARNING': PHPError.E_WARNING
        };

    return {
        /**
         * Sets or determines which PHP errors will be reported
         *
         * @see {@link https://secure.php.net/manual/en/function.error-reporting.php}
         *
         * @returns {IntegerValue}
         */
        'error_reporting': function (levelReference) {
            var currentLevelValue = valueFactory.coerce(errorConfiguration.getErrorReportingLevel());

            if (!levelReference) {
                // When no argument is given, just return the current reporting level

                return currentLevelValue;
            }

            errorConfiguration.setErrorReportingLevel(levelReference.getValue().getNative());

            return currentLevelValue;
        },

        /**
         * Generates a user-level error/warning/notice message
         *
         * @see {@link https://secure.php.net/manual/en/function.trigger-error.php}
         *
         * @returns {BooleanValue}
         */
        'trigger_error': function (errorMessageReference, errorTypeReference) {
            var errorConstantName,
                errorLevel,
                errorMessage,
                errorType;

            errorMessage = errorMessageReference.getNative();
            errorType = errorTypeReference ? errorTypeReference.getNative() : null;

            if (errorType === null) {
                errorConstantName = 'E_USER_NOTICE';
            } else {
                errorConstantName = Object.keys(ERROR_CONSTANT_NAME_TO_LEVEL).find(function (constantName) {
                    return internals.getConstant(constantName) === errorType;
                });

                if (!errorConstantName) {
                    callStack.raiseError(PHPError.E_WARNING, 'Invalid error type specified');

                    return valueFactory.createBoolean(false);
                }
            }

            errorLevel = ERROR_CONSTANT_NAME_TO_LEVEL[errorConstantName];

            callStack.raiseError(errorLevel, errorMessage);

            return valueFactory.createBoolean(true);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/filesystem.js":
/*!*********************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/filesystem.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var INCLUDE_PATH_INI = 'include_path',
    PHPError = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js").PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        iniState = internals.iniState,
        optionSet = internals.optionSet,
        valueFactory = internals.valueFactory;

    function getFileSystem() {
        var fileSystem = optionSet.getOption('fileSystem');

        if (!fileSystem) {
            throw new Error('filesystem :: No `fileSystem` option is configured');
        }

        return fileSystem;
    }

    return {
        'dirname': function (pathReference) {
            var pathValue = pathReference.getValue(),
                path = pathValue.getNative();

            if (path && path.indexOf('/') === -1) {
                path = '.';
            } else {
                path = path.replace(/\/[^\/]+$/, '');
            }

            pathValue = valueFactory.createString(path);

            return pathValue;
        },
        /**
         * Determines whether a file or directory exists with the given path
         *
         * @see {@link https://secure.php.net/manual/en/function.file-exists.php}
         *
         * @returns {BooleanValue}
         */
        'file_exists': function (pathReference) {
            var fileSystem,
                path;

            if (!pathReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'file_exists() expects exactly 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            fileSystem = getFileSystem();
            path = pathReference.getValue().getNative();

            return valueFactory.createBoolean(fileSystem.isFile(path) || fileSystem.isDirectory(path));
        },

        /**
         * Determines whether a file (not a directory) exists with the given path
         *
         * @see {@link https://secure.php.net/manual/en/function.get-include-path.php}
         *
         * @returns {StringValue}
         */
        'get_include_path': function () {
            return valueFactory.createString(iniState.get(INCLUDE_PATH_INI));
        },

        /**
         * Determines whether a file (not a directory) exists with the given path
         *
         * @see {@link https://secure.php.net/manual/en/function.is-file.php}
         *
         * @returns {BooleanValue}
         */
        'is_file': function (pathReference) {
            var fileSystem,
                path;

            if (!pathReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'is_file() expects exactly 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            fileSystem = getFileSystem();
            path = pathReference.getValue().getNative();

            return valueFactory.createBoolean(fileSystem.isFile(path));
        },

        /**
         * Changes the include path, returning the old one
         *
         * @see {@link https://secure.php.net/manual/en/function.set-include-path.php}
         *
         * @returns {StringValue} Returns the old include path that was set previously
         */
        'set_include_path': function (newIncludePathReference) {
            var oldIncludePath = iniState.get(INCLUDE_PATH_INI);

            iniState.set(INCLUDE_PATH_INI, newIncludePathReference.getValue().getNative());

            return valueFactory.createString(oldIncludePath);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/functionHandling.js":
/*!***************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/functionHandling.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    CallbackValue = __webpack_require__(/*! ./functionHandling/CallbackValue */ "./node_modules/phpruntime/src/builtin/functions/functionHandling/CallbackValue.js"),
    PHPError = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js").PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Calls the specified function, returning its result
         *
         * @see {@link https://secure.php.net/manual/en/function.call-user-func.php}
         *
         * @param {Variable|Value} callbackReference       The function or callable to call
         * @param {...Variable|...Value} argumentReference Variable no. of arguments to pass to the callable
         * @returns {Value}
         */
        'call_user_func': function (callbackReference, argumentReference) { //jshint ignore:line
            var callbackValue = callbackReference.getValue(),
                expectedReferenceArgumentIndex = null,
                expectedReferenceError = {},
                argumentValues = _.map(
                    [].slice.call(arguments, 1),
                    function (argumentReference, argumentIndex) {
                        return new CallbackValue(
                            function () {
                                expectedReferenceArgumentIndex = argumentIndex;
                                throw expectedReferenceError;
                            },
                            function () {
                                return argumentReference.getValue();
                            }
                        );
                    }
                );

            try {
                return callbackValue.call(argumentValues, globalNamespace);
            } catch (error) {
                // Allow any other errors through
                if (error !== expectedReferenceError) {
                    throw error;
                }

                callStack.raiseError(
                    PHPError.E_WARNING,
                    'Parameter ' + (expectedReferenceArgumentIndex + 1) +
                        ' to ' + callbackValue.getCallableName(globalNamespace) +
                        '() expected to be a reference, value given'
                );

                return valueFactory.createNull();
            }
        },
        /**
         * Calls the specified function, returning its result
         *
         * @see {@link https://secure.php.net/manual/en/function.call-user-func-array.php}
         *
         * @param {Variable|Value} callbackReference      The function or callable to call
         * @param {Variable|Value} argumentArrayReference An array of arguments to pass to the callable
         * @returns {Value}
         */
        'call_user_func_array': function (callbackReference, argumentArrayReference) {
            var callbackValue = callbackReference.getValue(),
                argumentArrayValue = argumentArrayReference.getValue(),
                argumentValues = argumentArrayValue.getValueReferences();

            return callbackValue.call(argumentValues, globalNamespace);
        },

        /**
         * Fetches an array containing all arguments passed to the function.
         * If called from outside a function, FALSE will be returned.
         *
         * @see {@link https://secure.php.net/manual/en/function.func-get-args.php}
         *
         * @returns {ArrayValue|BooleanValue}
         */
        'func_get_args': function () {
            var callerCall = callStack.getCaller();

            if (callerCall === null) {
                // We're not in a function scope - no args to get

                callStack.raiseError(
                    PHPError.E_WARNING,
                    'func_get_args(): Called from the global scope - no function context'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createArray(callerCall.getFunctionArgs());
        },

        /**
         * Fetches the number of arguments passed to the function.
         *
         * @see {@link https://secure.php.net/manual/en/function.func-num-args.php}
         *
         * @returns {IntegerValue}
         */
        'func_num_args': function () {
            var callerCall = callStack.getCaller();

            if (callerCall === null) {
                // We're not in a function scope - no args to get

                callStack.raiseError(
                    PHPError.E_WARNING,
                    'func_num_args(): Called from the global scope - no function context'
                );

                return valueFactory.createInteger(-1);
            }

            return valueFactory.createInteger(callerCall.getFunctionArgs().length);
        },

        /**
         * Determines whether the specified function exists,
         * returning true if so and false otherwise
         *
         * @see {@link https://secure.php.net/manual/en/function.function-exists.php}
         *
         * @param {Variable|Value} nameReference The name of the function to check for
         * @returns {BooleanValue}
         */
        'function_exists': function (nameReference) {
            var name = nameReference.getValue().getNative().replace(/^\\/, '');

            return valueFactory.createBoolean(globalNamespace.hasFunction(name));
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/functionHandling/CallbackValue.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/functionHandling/CallbackValue.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    util = __webpack_require__(/*! util */ "./node_modules/util/util.js"),
    Reference = __webpack_require__(/*! phpcore/src/Reference/Reference */ "./node_modules/phpcore/src/Reference/Reference.js");

/**
 * Represents a Value object whose reference or value
 * are fetched with a callback function
 *
 * @param {Function} referenceCallback
 * @param {Function} valueCallback
 * @constructor
 */
function CallbackValue(referenceCallback, valueCallback) {
    /**
     * @type {Function}
     */
    this.referenceCallback = referenceCallback;
    /**
     * @type {Function}
     */
    this.valueCallback = valueCallback;
}

util.inherits(CallbackValue, Reference);

_.extend(CallbackValue.prototype, {
    /**
     * Fetches the eventual native value of this value via the provided callback
     *
     * @returns {*}
     */
    getNative: function () {
        return this.getValue().getNative();
    },

    /**
     * Fetches the reference for this value via the provided callback
     *
     * @returns {Reference|Value}
     */
    getReference: function () {
        return this.referenceCallback();
    },

    /**
     * Fetches the eventual value of this value via the provided callback
     *
     * @returns {Value}
     */
    getValue: function () {
        return this.valueCallback();
    },

    /**
     * {@inheritdoc}
     */
    isDefined: function () {
        return true;
    }
});

module.exports = CallbackValue;


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/math/baseConversion.js":
/*!******************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/math/baseConversion.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var PHPError = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js").PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Converts a decimal integer to hexadecimal
         *
         * @see {@link https://secure.php.net/manual/en/function.dechex.php}
         *
         * @param {Variable|Value} numberReference
         * @returns {StringValue}
         */
        'dechex': function (numberReference) {
            /*jshint bitwise:false */
            var number,
                unsignedNumber;

            if (arguments.length === 0) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'dechex() expects exactly 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            number = numberReference ?
                numberReference.getValue().getNative() :
                null;
            unsignedNumber = number >>> 0; // Cast to a 32-bit unsigned integer

            return valueFactory.createString(unsignedNumber.toString(16));
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/misc/constant.js":
/*!************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/misc/constant.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var PHPError = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js").PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        globalNamespace = internals.globalNamespace,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Defines a new constant, optionally making it case-insensitive (in name)
         *
         * @see {@link https://secure.php.net/manual/en/function.define.php}
         *
         * @param {Value|Variable} nameValue
         * @param {Value|Variable} valueValue
         * @param {Value|Variable|undefined} isCaseInsensitive
         * @returns {IntegerValue}
         */
        'define': function (nameValue, valueValue, isCaseInsensitive) {
            var match,
                name,
                namespace,
                path;

            if (arguments.length === 0) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'define() expects at least 2 parameters, 0 given'
                );
                return valueFactory.createNull();
            }

            name = nameValue.getValue().getNative();
            isCaseInsensitive = isCaseInsensitive ? isCaseInsensitive.getValue().getNative() : false;
            valueValue = valueValue.getValue();

            name = name.replace(/^\//, '');
            match = name.match(/^(.*?)\\([^\\]+)$/);

            if (match) {
                path = match[1];
                name = match[2];
                namespace = globalNamespace.getDescendant(path);
            } else {
                namespace = globalNamespace;
            }

            namespace.defineConstant(name, valueValue, {
                caseInsensitive: isCaseInsensitive
            });
        },
        /**
         * Returns true if a constant is defined with the given name, false otherwise
         *
         * @see {@link https://secure.php.net/manual/en/function.defined.php}
         *
         * @param {Value|Variable} nameValue
         * @returns {BooleanValue}
         */
        'defined': function (nameValue) {
            var match,
                name,
                namespace,
                path;

            if (arguments.length === 0) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'defined() expects exactly 1 parameter, 0 given'
                );
                return valueFactory.createNull();
            }

            name = nameValue.getValue().getNative();

            name = name.replace(/^\//, '');
            match = name.match(/^(.*?)\\([^\\]+)$/);

            if (match) {
                path = match[1];
                name = match[2];
                namespace = globalNamespace.getDescendant(path);
            } else {
                namespace = globalNamespace;
            }

            return valueFactory.createBoolean(namespace.hasConstant(name));
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/misc/time.js":
/*!********************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/misc/time.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        optionSet = internals.optionSet,
        pausable = internals.pausable;

    function getPerformance() {
        var performance = optionSet.getOption('performance');

        if (!performance) {
            throw new Error('performance :: No `performance` option is configured');
        }

        return performance;
    }

    return {
        /**
         * Pauses execution for the specified number of microseconds.
         * Note that in async mode, this will be implemented by pausing execution
         * via Pausable and setting a timeout to later resume.
         * In (p)sync mode, an (inefficient!) busy wait loop is used to perform the wait.
         * Relying on the busy-wait version is not recommended for production usage!
         *
         * @see {@link https://secure.php.net/manual/en/function.usleep.php}
         *
         * @param {Variable|Value} microsecondsReference
         */
        'usleep': function (microsecondsReference) {
            var endMicroseconds,
                microsecondsValue = microsecondsReference.getValue(),
                pause,
                performance;

            if (microsecondsValue.getType() !== 'int' && microsecondsValue.getType() !== 'float') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'usleep() expects parameter 1 to be integer or float, ' +
                        microsecondsValue.getType() + ' given'
                );
                return;
            }

            if (pausable) {
                // Efficient version, if we're using async mode

                pause = pausable.createPause();

                setTimeout(function () {
                    pause.resume();
                }, microsecondsValue.getNative() / 1000);

                pause.now();
            } else {
                // Inefficient version, if we're in (p)sync mode

                performance = getPerformance();
                endMicroseconds = performance.getTimeInMicroseconds() + microsecondsValue.getNative();

                while (performance.getTimeInMicroseconds() < endMicroseconds) { //jshint ignore:line
                    // Busy wait
                }
            }
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/config.js":
/*!********************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/config.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    var valueFactory = internals.valueFactory;

    return {
        /**
         * Fetches the value of a PHP configuration option as it was set in the INI file.
         * Any changes made at runtime (eg. with ini_set(...)) will _not_ be taken into account.
         *
         * @see {@link https://secure.php.net/manual/en/function.get-cfg-var.php}
         *
         * @param {Reference|Value|Variable} optionNameReference
         * @return {Value}
         */
        'get_cfg_var': function (optionNameReference) {
            var optionName = optionNameReference ?
                optionNameReference.getValue().getNative() :
                null;

            if (optionName === 'cfg_file_path') {
                return valueFactory.createString('/pseudo/uniter/php.ini');
            }

            throw new Error(
                'Cannot fetch option "' + optionName + '" - only cfg_file_path config option is currently supported'
            );
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/environment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/environment.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    var valueFactory = internals.valueFactory;

    return {
        /**
         * Fetches the value of an environment variable
         *
         * @see {@link https://secure.php.net/manual/en/function.getenv.php}
         *
         * @param {Reference|Value|Variable|null} variableNameReference
         * @return {Value}
         */
        'getenv': function (variableNameReference) {
            if (variableNameReference) {
                return valueFactory.createBoolean(false);
            }

            return valueFactory.createArray([]);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/extension.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/extension.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



module.exports = function (internals) {
    var valueFactory = internals.valueFactory;

    return {
        /**
         * Fetches the names of all extension modules that have been loaded
         *
         * @see {@link https://secure.php.net/manual/en/function.get-loaded-extensions.php}
         *
         * @param {Reference|Value|Variable|null} onlyZendExtensions
         * @return {ArrayValue}
         */
        'get_loaded_extensions': function (/* onlyZendExtensions */) {
            return valueFactory.createArray([]);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/php.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/optionsAndInfo/php.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var systemConstants = __webpack_require__(/*! ../../../../constants */ "./node_modules/phpruntime/constants.js");

module.exports = function (internals) {
    var valueFactory = internals.valueFactory;

    return {
        /**
         * Returns information about the operating system PHP is running on
         *
         * @see {@link https://secure.php.net/manual/en/function.php-uname.php}
         *
         * @param {Variable|Value} modeReference
         * @returns {StringValue}
         */
        'php_uname': function (modeReference) {
            var mode = modeReference ? modeReference.getValue().getNative() : 'a',
                string;

            switch (mode) {
                case 's': // Operating system name. eg. FreeBSD
                    string = systemConstants.operatingSystem.name;
                    break;
                case 'n': // Host name. eg. localhost.example.com
                    string = systemConstants.operatingSystem.hostName;
                    break;
                case 'r': // Release name. eg. 5.1.2-RELEASE
                    string = systemConstants.operatingSystem.releaseName;
                    break;
                case 'v': // Version information. Varies a lot between operating systems
                    string = systemConstants.operatingSystem.versionInfo;
                    break;
                case 'm': // Machine type. eg. i386
                    string = systemConstants.operatingSystem.machineType;
                    break;
                default:
                case 'a': // All modes together (default)
                    string = systemConstants.operatingSystem.name + ' ' +
                        systemConstants.operatingSystem.hostName + ' ' +
                        systemConstants.operatingSystem.releaseName + ' ' +
                        systemConstants.operatingSystem.versionInfo + ' ' +
                        systemConstants.operatingSystem.machineType;
            }

            return valueFactory.createString(string);
        },

        /**
         * Returns the PHP version that this version of Uniter is targeting
         *
         * @see {@link https://secure.php.net/manual/en/function.phpversion.php}
         *
         * @returns {BooleanValue|StringValue}
         */
        'phpversion': function (extensionName) {
            if (extensionName) {
                // No extensions are supported (yet)
                return valueFactory.createBoolean(false);
            }

            // Default behaviour is just to return the PHP version string
            return valueFactory.createString(
                systemConstants.phpVersion.major + '.' +
                systemConstants.phpVersion.minor + '.' +
                systemConstants.phpVersion.release
            );
        },

        /**
         * Returns the version of the current Zend engine (different to the PHP version)
         *
         * Uniter is not related to Zend's engine at all, so this function makes little sense here.
         * It is required by some scripts though (eg. Zend's test runner `run-tests.php` script),
         * so it is added for completeness. HHVM also defines this function for compatibility.
         *
         * @see {@link https://secure.php.net/manual/en/function.zend-version.php}
         *
         * @returns {StringValue}
         */
        'zend_version': function () {
            return valueFactory.createString(
                systemConstants.zendVersion.major + '.' +
                systemConstants.zendVersion.minor + '.' +
                systemConstants.zendVersion.release
            );
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/outputControl.js":
/*!************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/outputControl.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    Exception = phpCommon.Exception,
    NoActiveOutputBufferException = __webpack_require__(/*! phpcore/src/Exception/NoActiveOutputBufferException */ "./node_modules/phpcore/src/Exception/NoActiveOutputBufferException.js"),
    PHPError = phpCommon.PHPError;

/**
 * Output control functions
 *
 * @param {object} internals
 * @return {object}
 */
module.exports = function (internals) {
    var callStack = internals.callStack,
        output = internals.output,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Erases the current output buffer without turning it off
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-clean.php}
         *
         * @returns {BooleanValue} Returns true on success or false on failure
         */
        'ob_clean': function () {
            try {
                output.cleanCurrentBuffer();
            } catch (error) {
                if (!(error instanceof NoActiveOutputBufferException)) {
                    throw error;
                }

                callStack.raiseError(
                    PHPError.E_NOTICE,
                    'ob_clean(): failed to delete buffer. No buffer to delete'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createBoolean(true);
        },

        /**
         * Erases the output buffer and then turns it off, essentially discarding the current buffer
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-end-clean.php}
         * @TODO: Output E_NOTICE on failure
         *
         * @returns {BooleanValue} Returns true on success or false on failure
         */
        'ob_end_clean': function () {
            try {
                output.popBuffer();
            } catch (error) {
                callStack.raiseError(
                    PHPError.E_NOTICE,
                    'ob_end_clean(): failed to delete buffer. No buffer to delete'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createBoolean(true);
        },

        /**
         * Sends the output buffer to the next buffer in the chain, then turns off the output buffer.
         * If the next one in the chain is the default StdoutBuffer, then the buffer contents
         * will be written to stdout
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-end-flush.php}
         *
         * @returns {BooleanValue} Returns true on success or false on failure
         */
        'ob_end_flush': function () {
            try {
                output.flushCurrentBuffer();
                output.popBuffer();
            } catch (error) {
                if (!(error instanceof NoActiveOutputBufferException)) {
                    throw error;
                }

                callStack.raiseError(
                    PHPError.E_NOTICE,
                    'ob_end_flush(): failed to delete and flush buffer. No buffer to delete or flush'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createBoolean(true);
        },

        /**
         * Sends the output buffer to the next buffer in the chain.
         * If the next one in the chain is the default StdoutBuffer, then the buffer contents
         * will be written to stdout
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-flush.php}
         *
         * @returns {BooleanValue} Returns true on success or false on failure
         */
        'ob_flush': function () {
            try {
                output.flushCurrentBuffer();
            } catch (error) {
                callStack.raiseError(
                    PHPError.E_NOTICE,
                    'ob_flush(): failed to flush buffer. No buffer to flush'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createBoolean(true);
        },

        /**
         * Fetches the contents of the output buffer and deletes the current buffer
         * (essentially executing `ob_get_contents()` and then `ob_end_clean()`)
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-get-clean.php}
         *
         * @returns {StringValue|BooleanValue} Returns the output buffer or FALSE if no buffer is active
         */
        'ob_get_clean': function () {
            var contents;

            if (output.getDepth() === 0) {
                // No buffer is active (except the default StdoutBuffer, which does not count for this)
                return valueFactory.createBoolean(false);
            }

            contents = output.getCurrentBufferContents();
            output.popBuffer();

            return valueFactory.createString(contents);
        },

        /**
         * Fetches the contents of the output buffer without clearing it
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-get-contents.php}
         *
         * @returns {StringValue|BooleanValue} Returns the output buffer or FALSE if no buffer is active
         */
        'ob_get_contents': function () {
            var contents;

            if (output.getDepth() === 0) {
                // No buffer is active (except the default StdoutBuffer, which does not count for this)
                return valueFactory.createBoolean(false);
            }

            contents = output.getCurrentBufferContents();

            return valueFactory.createString(contents);
        },

        /**
         * Flushes the output buffer, returns it as a string and turns off output buffering
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-get-flush.php}
         *
         * @returns {StringValue|BooleanValue} Returns the output buffer or FALSE if no buffer is active
         */
        'ob_get_flush': function () {
            var contents;

            if (output.getDepth() === 0) {
                callStack.raiseError(
                    PHPError.E_NOTICE,
                    'ob_get_flush(): failed to delete and flush buffer. No buffer to delete or flush'
                );

                // No buffer is active (except the default StdoutBuffer, which does not count for this)
                return valueFactory.createBoolean(false);
            }

            contents = output.getCurrentBufferContents();
            output.flushCurrentBuffer();

            return valueFactory.createString(contents);
        },

        /**
         * Fetches the nesting level of the output buffering mechanism
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-get-level.php}
         *
         * @returns {IntegerValue} Returns the nesting level of the output buffering mechanism
         */
        'ob_get_level': function () {
            return valueFactory.createInteger(output.getDepth());
        },

        /**
         * Turns on output buffering, or adds a new buffer to the stack if it is already on
         *
         * @see {@link https://secure.php.net/manual/en/function.ob-start.php}
         *
         * @param {Variable|Value} outputCallbackReference
         */
        'ob_start': function (outputCallbackReference, chunkSizeReference, flagsReference) {
            if (outputCallbackReference || chunkSizeReference || flagsReference) {
                throw new Exception('ob_start() :: No arguments are supported yet');
            }

            output.pushBuffer();
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/pcre/common.js":
/*!**********************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/pcre/common.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var REGEX_SPECIAL_CHAR_PATTERN = /[.\\+*?[^\]$(){}=!<>|:#-]/g,
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError;

/**
 * Basic-level PCRE support module. JavaScript's own RegExp implementation is used,
 * meaning that only the JavaScript-compliant subset of regular expression is supported.
 */
module.exports = function (internals) {
    var callStack = internals.callStack,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Quote (escape) regular expression characters
         *
         * @see {@link https://secure.php.net/manual/en/function.preg-quote.php}
         *
         * @param {Reference|Variable|Value} stringReference
         * @param {Reference|Variable|Value} delimiterReference
         * @returns {StringValue}
         */
        'preg_quote': function (stringReference, delimiterReference) {
            var delimiter,
                quoted,
                string;

            if (!stringReference) {
                callStack.raiseError(PHPError.E_WARNING, 'preg_quote() expects at least 1 parameter, 0 given');
                return valueFactory.createNull();
            }

            string = stringReference.getNative();

            quoted = string.replace(REGEX_SPECIAL_CHAR_PATTERN, '\\$&');

            if (delimiterReference) {
                delimiter = delimiterReference.getNative().charAt(0); // We only consider the first char of delimiter
                delimiter = delimiter.replace(REGEX_SPECIAL_CHAR_PATTERN, '');

                if (delimiter !== '') {
                    quoted = quoted.replace(new RegExp('\\' + delimiter, 'g'), '\\$&');
                }
            }

            return valueFactory.createString(quoted);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/spl.js":
/*!**************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/spl.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    PHPError = phpCommon.PHPError;

/**
 * SPL-related PHP builtin functions.
 * Note that some functions (eg. spl_autoload_register) are provided by PHPCore
 *
 * @param {object} internals
 * @return {object}
 */
module.exports = function (internals) {
    var callStack = internals.callStack,
        valueFactory = internals.valueFactory;

    return {
        /**
         * Fetches the unique identifier "hash" for a PHP object
         *
         * @see {@link https://secure.php.net/manual/en/function.spl-object-hash.php}
         *
         * @param {Variable|Value} haystackReference    The object to get a unique identifier for
         * @returns {StringValue}                       The unique identifier
         */
        'spl_object_hash': function (objectReference) {
            var objectValue = objectReference.getValue(),
                idString,
                padding;

            if (objectValue.getType() !== 'object') {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'spl_object_hash() expects parameter 1 to be object, ' + objectValue.getType() + ' given'
                );
                return valueFactory.createNull();
            }

            // Use Uniter's internal unique object IDs to build the "hash"
            idString = objectValue.getID().toString();
            // PHP object "hashes" are 32 bytes long, so emulate that here
            padding = new Array(32 - idString.length + 1).join('0');

            return valueFactory.createString(padding + idString);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/string.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    MissingFormatArgumentException = __webpack_require__(/*! ../bindings/string/Exception/MissingFormatArgumentException */ "./node_modules/phpruntime/src/builtin/bindings/string/Exception/MissingFormatArgumentException.js"),
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        formatter = internals.getBinding('stringFormatter'),
        valueFactory = internals.valueFactory;

    return {
        /**
         * Split a string into an array by a certain substring
         *
         * @see {@link https://secure.php.net/manual/en/function.explode.php}
         *
         * @param {Reference|StringValue|Variable} delimiterReference  The substring to split the input string on
         * @param {Reference|StringValue|Variable} stringReference  The string to split
         * @param {Reference|IntegerValue|Variable} limitReference  The string to split
         * @returns {ArrayValue|BooleanValue} The resulting array on success, or false on failure
         */
        'explode': function (delimiterReference, stringReference, limitReference) {
            var delimiter,
                elements,
                limit,
                string;

            if (arguments.length < 2) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'explode() expects at least 2 parameters, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            delimiter = delimiterReference.getValue().coerceToString().getNative();
            limit = limitReference ? limitReference.getValue().getNative() : null;
            string = stringReference.getValue().coerceToString().getNative();

            elements = string.split(delimiter);

            if (limit === 0) {
                limit = 1;
            }

            if (limit < 0) {
                elements = elements.slice(0, elements.length + limit);
            } else if (limit !== null) {
                if (limit > elements.length) {
                    limit = elements.length;
                }

                elements = elements.slice(0, limit - 1).concat(elements.slice(limit - 1).join(delimiter));
            }

            return valueFactory.createArray(elements);
        },

        'strlen': function (stringReference) {
            var stringValue = stringReference.getValue();

            if (stringValue.getType() === 'array' || stringValue.getType() === 'object') {
                callStack.raiseError(PHPError.E_WARNING, 'strlen() expects parameter 1 to be string, ' + stringValue.getType() + ' given');
                return valueFactory.createNull();
            }

            return valueFactory.createInteger(stringValue.getLength());
        },

        /**
         * Builds and returns a formatted string
         *
         * @see {@link https://secure.php.net/manual/en/function.sprintf.php}
         *
         * @param {Reference|Value|Variable} templateReference  The template format string
         * @returns {StringValue|BooleanValue} The built string on success, or false on failure
         */
        'sprintf': function (templateReference) {
            var args = [].slice.call(arguments, 1);

            try {
                return valueFactory.createString(
                    formatter.format(templateReference.getNative(), args)
                );
            } catch (error) {
                if (error instanceof MissingFormatArgumentException) {
                    callStack.raiseError(PHPError.E_WARNING, 'sprintf(): Too few arguments');

                    return valueFactory.createBoolean(false);
                }

                throw error;
            }
        },

        'str_replace': function (
            searchReference,
            replaceReference,
            subjectReference,
            countReference
        ) {
            function getNative(reference) {
                var value = reference.getValue();

                return value.getNative();
            }

            var count = 0,
                search,
                replacement,
                subject,
                replace = countReference ?
                    function replace(search, replacement, subject) {
                        return subject.replace(search, function () {
                            count++;

                            return replacement;
                        });
                    } :
                    function replace(search, replacement, subject) {
                        return subject.replace(search, replacement);
                    };

            if (arguments.length < 3) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'str_replace() expects at least 3 parameters, ' + arguments.length + ' given'
                );

                return valueFactory.createNull();
            }

            search = getNative(searchReference);
            replacement = getNative(replaceReference);
            subject = getNative(subjectReference);

            // Use a regex to search for substrings, for speed
            function buildRegex(search) {
                return new RegExp(
                    _.escapeRegExp(search),
                    'g'
                );
            }

            if (_.isArray(search)) {
                if (_.isArray(replacement)) {
                    // Search and replacement are both arrays
                    _.each(search, function (search, index) {
                        subject = replace(
                            buildRegex(search),
                            index < replacement.length ? replacement[index] : '',
                            subject
                        );
                    });
                } else {
                    // Only search is an array, replacement is just a string
                    _.each(search, function (search) {
                        subject = replace(
                            buildRegex(search),
                            replacement,
                            subject
                        );
                    });
                }
            } else {
                // Simple case: search and replacement are both strings
                subject = replace(
                    buildRegex(search),
                    replacement,
                    subject
                );
            }

            if (countReference) {
                countReference.setValue(valueFactory.createInteger(count));
            }

            return valueFactory.createString(subject);
        },

        'strpos': function (haystackReference, needleReference, offsetReference) {
            var haystack = haystackReference.getNative(),
                needle = needleReference.getNative(),
                offset = offsetReference ? offsetReference.getNative() : 0,
                position;

            // Negative offsets indicate no. of chars at end of haystack to scan
            if (offset < 0) {
                offset = haystack.length + offset;
            }

            position = haystack.substr(offset).indexOf(needle);

            if (position === -1) {
                return valueFactory.createBoolean(false);
            }

            return valueFactory.createInteger(offset + position);
        },

        /**
         * Fetch the substring after (and including) the last occurrence of a needle
         *
         * @see {@link https://secure.php.net/manual/en/function.strrchr.php}
         *
         * @param {Reference|StringValue|Variable} haystackReference  The string to search for the needle inside
         * @param {Reference|StringValue|Variable} needleReference  The substring to look for in the haystack
         * @returns {StringValue|BooleanValue|NullValue} The resulting string on success, false if not found and null on error
         */
        'strrchr': function (haystackReference, needleReference) {
            var haystack,
                needleValue,
                needle,
                position;

            if (arguments.length < 2) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'strrchr() expects exactly 2 parameters, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            haystack = haystackReference.getValue().coerceToString().getNative();
            needleValue = needleReference.getValue();
            needle = needleValue.getType() === 'string' ?
                needleValue.getNative().charAt(0) :
                String.fromCharCode(needleValue.coerceToInteger().getNative());
            position = haystack.lastIndexOf(needle);

            if (position === -1) {
                // Return FALSE if needle is not found in haystack
                return valueFactory.createBoolean(false);
            }

            return valueFactory.createString(haystack.substr(position));
        },

        'strrpos': function (haystackReference, needleReference, offsetReference) {
            var haystack = haystackReference.getValue().getNative(),
                needle = needleReference.getValue().getNative(),
                offset = offsetReference ? offsetReference.getValue().getNative() : 0,
                position;

            // Negative offsets indicate no. of chars at end of haystack to scan
            if (offset < 0) {
                offset = haystack.length + offset;
            }

            position = haystack.substr(offset).lastIndexOf(needle);

            if (position === -1) {
                return valueFactory.createBoolean(false);
            }

            return valueFactory.createInteger(offset + position);
        },

        /**
         * Convert a string to lowercase
         *
         * @see {@link https://secure.php.net/manual/en/function.strtolower.php}
         *
         * @param {Reference|StringValue|Variable} stringReference  The string to convert to lowercase
         * @returns {StringValue|NullValue} The resulting string on success, or null on failure
         */
        'strtolower': function (stringReference) {
            var string;

            if (arguments.length < 1) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'strtolower() expects exactly 1 parameter, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            string = stringReference.getValue().coerceToString().getNative();

            return valueFactory.createString(string.toLowerCase());
        },

        /**
         * Convert a string to uppercase
         *
         * @see {@link https://secure.php.net/manual/en/function.strtoupper.php}
         *
         * @param {Reference|StringValue|Variable} stringReference  The string to convert to uppercase
         * @returns {StringValue|NullValue} The resulting string on success, or null on failure
         */
        'strtoupper': function (stringReference) {
            var string;

            if (arguments.length < 1) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'strtoupper() expects exactly 1 parameter, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            string = stringReference.getValue().coerceToString().getNative();

            return valueFactory.createString(string.toUpperCase());
        },

        'strtr': function (stringReference) {
            var from,
                to,
                i,
                replacePairs,
                replaceKeys,
                replaceValues,
                string = stringReference.getValue().getNative();

            if (arguments.length === 2) {
                // 2-operand form: second argument is an associative array
                // mapping substrings to search for to their replacements
                replacePairs = arguments[1].getValue();
                replaceKeys = replacePairs.getKeys();
                replaceValues = replacePairs.getValues();

                _.each(replaceKeys, function (key, index) {
                    var find = key.coerceToString().getNative(),
                        replace = replaceValues[index].coerceToString().getNative();

                    string = string.replace(
                        new RegExp(_.escapeRegExp(find), 'g'),
                        replace
                    );
                });
            } else {
                // 3-operand form: replace all characters in $from
                // with their counterparts at that index in $to
                from = arguments[1].getValue().getNative();
                to = arguments[2].getValue().getNative();

                for (i = 0; i < from.length && i < to.length; i++) {
                    string = string.replace(
                        new RegExp(_.escapeRegExp(from.charAt(i)), 'g'),
                        to.charAt(i)
                    );
                }
            }

            return valueFactory.createString(string);
        },

        'substr': function (stringReference, startReference, lengthReference) {
            var string = stringReference.getValue().getNative(),
                start = startReference.getValue().getNative(),
                length = lengthReference ? lengthReference.getValue().getNative() : string.length,
                substring;

            if (start < 0) {
                start = string.length + start;
            }

            if (length < 0) {
                length = string.length - start + length;
            }

            substring = string.substr(start, length);

            return valueFactory.createString(substring);
        },

        /**
         * Counts the number of substring occurrences
         *
         * @see {@link https://secure.php.net/manual/en/function.substr-count.php}
         *
         * @param {Variable|Value} haystackReference    The string to search inside
         * @param {Variable|Value} needleReference      The string to search inside
         * @param {Variable|Value} offsetReference      The position to start searching from
         * @param {Variable|Value} lengthReference      The no. of chars from the offset to search inside
         * @returns {IntegerValue}                      The number of occurrences found
         */
        'substr_count': function (haystackReference, needleReference, offsetReference, lengthReference) {
            var haystack,
                needle,
                offset,
                length,
                trimmedHaystack;

            if (arguments.length < 2) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'substr_count() expects at least 2 parameters, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            haystack = haystackReference.getValue().coerceToString().getNative();
            needle = needleReference.getValue().coerceToString().getNative();
            // Negative offsets are natively supported by JS .substr()
            offset = offsetReference ? offsetReference.getNative() : 0;

            if (lengthReference) {
                length = lengthReference.getNative();

                // Negative lengths count back from the end of the string
                if (length < 0) {
                    length = haystack.length - offset + length;
                }
            }

            trimmedHaystack = haystack.substr(offset, length);

            return valueFactory.createInteger(trimmedHaystack.split(needle).length - 1);
        },

        /**
         * Strip whitespace or other characters from both ends of a string
         *
         * @see {@link https://secure.php.net/manual/en/function.trim.php}
         *
         * @param {Variable|Value} stringReference          The string to trim
         * @param {Variable|Value} characterMaskReference   Which characters to strip
         * @returns {StringValue}                           The trimmed string
         */
        'trim': function (stringReference, characterMaskReference) {
            var nativeString = stringReference.getValue().coerceToString().getNative(),
                characterMask = characterMaskReference ?
                    characterMaskReference.getValue().getNative() :
                    ' \t\n\r\0\x0b',
                characterMaskRegex = new RegExp(
                    '^[' +
                    _.escapeRegExp(characterMask) +
                    ']+|[' +
                    _.escapeRegExp(characterMask) +
                    ']+$',
                    'g'
                );

            return valueFactory.createString(nativeString.replace(characterMaskRegex, ''));
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/string/html.js":
/*!**********************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/string/html.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js");

module.exports = function (internals) {
    var callStack = internals.callStack,
        characterRegexCache = {}, // For caching the regexes used to do entity replacements, for speed
        hasOwn = {}.hasOwnProperty,
        valueFactory = internals.valueFactory,
        PHPError = phpCommon.PHPError,
        ENT_COMPAT = internals.getConstant('ENT_COMPAT'),
        ENT_HTML401 = internals.getConstant('ENT_HTML401'),
        ENT_NOQUOTES = internals.getConstant('ENT_NOQUOTES'),
        ENT_QUOTES = internals.getConstant('ENT_QUOTES'),
        HTML_ENTITIES = internals.getConstant('HTML_ENTITIES'),
        HTML_SPECIALCHARS = internals.getConstant('HTML_SPECIALCHARS'),
        TRANSLATION_TABLES = {
            HTML_ENTITIES: {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',

                '£': '&pound;' // TODO: Support adding remaining entities via addons
            },
            HTML_SPECIALCHARS: {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;'
            }
        };

    /**
     * Fetches a translation table
     *
     * @param {string} functionName
     * @param {number} tableID
     * @param {number} flags
     * @param {string} encoding
     * @return {object}
     */
    function getTranslationTable(functionName, tableID, flags, encoding) {
        /*jshint bitwise: false */
        var quotesMode = 'double',
            tableData;

        switch (tableID) {
            case HTML_SPECIALCHARS:
                tableData = TRANSLATION_TABLES.HTML_SPECIALCHARS;
                break;
            case HTML_ENTITIES:
                tableData = TRANSLATION_TABLES.HTML_ENTITIES;
                break;
            default:
                throw new Error('Invalid table ID "' + tableID + '" given');
        }

        if ((flags & 3) === ENT_COMPAT) {
            quotesMode = 'double';
        } else if ((flags & 3) === ENT_QUOTES) {
            quotesMode = 'both';
        } else if ((flags & 3) === ENT_NOQUOTES) {
            quotesMode = 'none';
        }

        switch (quotesMode) {
            case 'double':
                tableData = Object.assign({}, tableData, { // Don't edit the original table object
                    '"': '&quot;'
                });
                break;
            case 'both':
                tableData = Object.assign({}, tableData, { // Don't edit the original table object
                    '"': '&quot;',
                    '\'': '&#039;'
                });
                break;
            default:
            case 'none':
            // Do nothing
        }

        if (encoding.toLowerCase() !== 'utf-8') {
            // Only UTF-8 is supported for now
            callStack.raiseError(
                PHPError.E_WARNING,
                functionName + '(): charset `' + encoding + '\' not supported, assuming utf-8'
            );
        }

        return tableData;
    }

    /**
     * Performs the actual HTML-encoding of a string using a given translation table
     *
     * @param {string} string String to encode
     * @param {object} translationTable Translation table (as returned from getTranslationTable())
     * @param {boolean} doubleEncode
     */
    function htmlEncode(string, translationTable, doubleEncode) {
        _.forOwn(translationTable, function (entityHTML, character) {
            var cacheKey = (doubleEncode ? '<double>' : '<single>') + character,
                pattern,
                regex;

            if (!hasOwn.call(characterRegexCache, cacheKey)) {
                pattern = '\\' + character;

                if (character === '&' && !doubleEncode) {
                    // Ensure we don't double-encode any entities in the two possible formats
                    // "&lt;" or "&#012"
                    pattern += '(?!\\w+;|#\\d+;)';
                }

                regex = new RegExp(pattern, 'g');

                characterRegexCache[cacheKey] = regex;
            } else {
                regex = characterRegexCache[cacheKey];
            }

            string = string.replace(regex, entityHTML);
        });

        return string;
    }

    return {
        /**
         * Fetches the translation table used by htmlspecialchars(...) or htmlentities(...)
         *
         * @see {@link https://secure.php.net/manual/en/function.get-html-translation-table.php}
         *
         * @param {IntegerValue|Reference|Variable} tableReference
         * @param {IntegerValue|Reference|Variable} flagsReference
         * @param {Reference|StringValue|Variable} encodingReference
         * @returns {ArrayValue}
         */
        'get_html_translation_table': function (tableReference, flagsReference, encodingReference) {
            /*jshint bitwise: false */
            var tableID = tableReference ?
                    tableReference.getValue().coerceToInteger().getNative() :
                    // Default to the htmlspecialchars(...) table
                    HTML_SPECIALCHARS,
                flags = flagsReference ?
                    flagsReference.getValue().coerceToInteger().getNative() :
                    ENT_COMPAT | ENT_HTML401,
                encoding = encodingReference ?
                    encodingReference.getValue().coerceToString().getNative() :
                    'UTF-8';

            return valueFactory.createArray(
                getTranslationTable('get_html_translation_table', tableID, flags, encoding)
            );
        },

        /**
         * Converts all applicable characters to HTML entities
         *
         * @see {@link https://secure.php.net/manual/en/function.htmlentities.php}
         *
         * @param {Reference|StringValue|Variable} stringReference
         * @param {IntegerValue|Reference|Variable} flagsReference
         * @param {Reference|StringValue|Variable} encodingReference
         * @param {BooleanValue|Reference|Variable} doubleEncodeReference
         * @returns {StringValue}
         */
        'htmlentities': function (stringReference, flagsReference, encodingReference, doubleEncodeReference) {
            /*jshint bitwise: false */
            var doubleEncode,
                string,
                flags,
                encoding,
                translationTable;

            if (arguments.length < 1) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'htmlentities() expects at least 1 parameter, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            doubleEncode = doubleEncodeReference ?
                doubleEncodeReference.getValue().coerceToBoolean().getNative() :
                true;
            string = stringReference.getValue().coerceToString().getNative();
            flags = flagsReference ?
                flagsReference.getValue().coerceToInteger().getNative() :
                ENT_COMPAT | ENT_HTML401;
            encoding = encodingReference ?
                encodingReference.getValue().coerceToString().getNative() :
                'UTF-8';
            translationTable = getTranslationTable(
                'htmlentities',
                HTML_ENTITIES,
                flags,
                encoding
            );

            string = htmlEncode(string, translationTable, doubleEncode);

            return valueFactory.createString(string);
        },

        /**
         * Converts all special characters to HTML entities
         *
         * @see {@link https://secure.php.net/manual/en/function.htmlspecialchars.php}
         *
         * @param {Reference|StringValue|Variable} stringReference
         * @param {IntegerValue|Reference|Variable} flagsReference
         * @param {Reference|StringValue|Variable} encodingReference
         * @param {BooleanValue|Reference|Variable} doubleEncodeReference
         * @returns {StringValue}
         */
        'htmlspecialchars': function (stringReference, flagsReference, encodingReference, doubleEncodeReference) {
            /*jshint bitwise: false */
            var doubleEncode,
                string,
                flags,
                encoding,
                translationTable;

            if (arguments.length < 1) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'htmlspecialchars() expects at least 1 parameter, ' + arguments.length + ' given'
                );
                return valueFactory.createNull();
            }

            doubleEncode = doubleEncodeReference ?
                doubleEncodeReference.getValue().coerceToBoolean().getNative() :
                true;
            string = stringReference.getValue().coerceToString().getNative();
            flags = flagsReference ?
                flagsReference.getValue().coerceToInteger().getNative() :
                ENT_COMPAT | ENT_HTML401;
            encoding = encodingReference ?
                encodingReference.getValue().coerceToString().getNative() :
                'UTF-8';
            translationTable = getTranslationTable(
                'htmlspecialchars',
                HTML_SPECIALCHARS,
                flags,
                encoding
            );

            string = htmlEncode(string, translationTable, doubleEncode);

            return valueFactory.createString(string);
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/functions/variableHandling.js":
/*!***************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/functions/variableHandling.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPRuntime - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpruntime/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpruntime/raw/master/MIT-LICENSE.txt
 */



var _ = __webpack_require__(/*! microdash */ "./node_modules/microdash/index.js"),
    hasOwn = {}.hasOwnProperty,
    phpCommon = __webpack_require__(/*! phpcommon */ "./node_modules/phpcommon/index.js"),
    MAX_DUMPS = 20000,
    MAX_RECURSION_DEPTH = 5,
    MAX_STRING_LENGTH = 2048,
    PHPError = phpCommon.PHPError;

module.exports = function (internals) {
    var callStack = internals.callStack,
        globalNamespace = internals.globalNamespace,
        output = internals.output,
        valueFactory = internals.valueFactory;

    function createTypeChecker(name, type) {
        return function (valueReference) {
            if (!valueReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    name + '() expects exactly 1 parameter, 0 given'
                );

                return valueFactory.createBoolean(false);
            }

            return valueFactory.createBoolean(valueReference.getValue().getType() === type);
        };
    }

    return {
        /**
         * Fetches the type of a variable or value
         *
         * @see {@link https://secure.php.net/manual/en/function.gettype.php}
         *
         * @param {Variable|Value} valueReference The variable or value to fetch the type of
         * @returns {StringValue}
         */
        'gettype': function (valueReference) {
            var value,
                type;

            if (!valueReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'gettype() expects exactly 1 parameter, 0 given'
                );

                return valueFactory.createNull();
            }

            value = valueReference.getValue();
            type = value.getType();

            if (type === 'float') {
                // For historical reasons "double" is returned rather than "float"
                type = 'double';
            } else if (type === 'null') {
                type = 'NULL';
            }

            return valueFactory.createString(type);
        },

        'is_array': createTypeChecker('is_array', 'array'),

        'is_bool': createTypeChecker('is_bool', 'boolean'),

        /**
         * Determines whether a value is a valid callable function, method, closure or invokable object
         *
         * @see {@link https://secure.php.net/manual/en/function.is-callable.php}
         *
         * @param {Reference|Value|Variable} valueReference
         * @param {BooleanValue|Reference|Variable=} syntaxOnlyReference
         * @param {Reference|Variable=} callableNameReference
         * @returns {BooleanValue}
         */
        'is_callable': function (valueReference, syntaxOnlyReference, callableNameReference) {
            var namespaceScope = {
                    // FIXME: We should really change Value.isCallable() to take the global namespace instead
                    getGlobalNamespace: function () {
                        return globalNamespace;
                    }
                },
                syntaxOnly = syntaxOnlyReference && syntaxOnlyReference.getValue().getNative(),
                value = valueReference.getValue();

            if (syntaxOnly) {
                throw new Error('is_callable() :: syntax_only=true is not supported');
            }

            if (callableNameReference) {
                throw new Error('is_callable() :: callable_name is not supported');
            }

            return valueFactory.createBoolean(value.isCallable(namespaceScope));
        },

        'is_float': createTypeChecker('is_float', 'float'),

        /**
         * Determines whether the type of a variable is an integer
         *
         * @see {@link https://secure.php.net/manual/en/function.is-int.php}
         *
         * @param {Variable|Reference|Value} valueReference The variable or value to check the type of
         * @returns {BooleanValue}
         */
        'is_int': createTypeChecker('is_int', 'int'),

        /**
         * Determines whether a variable is a number or a string containing a number
         *
         * @see {@link https://secure.php.net/manual/en/function.is-numeric.php}
         *
         * @param {Variable|Reference|Value} valueReference The variable or value to check the numericness of
         * @returns {BooleanValue}
         */
        'is_numeric': function (valueReference) {
            var value;

            if (!valueReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'is_numeric() expects exactly 1 parameter, 0 given'
                );

                return valueFactory.createNull();
            }

            value = valueReference.getValue();

            return valueFactory.createBoolean(
                value.getType() === 'int' ||
                value.getType() === 'float' ||
                (
                    value.getType() === 'string' &&
                    isFinite(value.getNative())
                )
            );
        },

        /**
         * Determines whether the type of a variable is an object
         *
         * @see {@link https://secure.php.net/manual/en/function.is-object.php}
         *
         * @param {Variable|Reference|Value} valueReference The variable or value to check the type of
         * @returns {BooleanValue}
         */
        'is_object': createTypeChecker('is_object', 'object'),

        /**
         * Determines whether the type of a variable is a string
         *
         * @see {@link https://secure.php.net/manual/en/function.is-string.php}
         *
         * @param {Variable|Reference|Value} valueReference The variable or value to check the type of
         * @returns {BooleanValue}
         */
        'is_string': createTypeChecker('is_string', 'string'),

        /**
         * Outputs or returns a valid PHP code string that will evaluate to the given value
         *
         * @see {@link https://secure.php.net/manual/en/function.var-export.php}
         *
         * @param {Variable|Reference|Value} valueReference The variable or value to export
         * @param {Variable|Reference|Value} returnReference Whether to return the string rather than output
         * @returns {NullValue|StringValue} Returns NULL when outputting, the code string when return=true
         */
        'var_export': function (valueReference, returnReference) {
            var exportedCodeString,
                shouldReturn,
                value;

            function exportValue(value) {
                var parts;

                switch (value.getType()) {
                    case 'array':
                        parts = [];
                        value.getKeys().forEach(function (keyValue) {
                            var elementPair = value.getElementPairByKey(keyValue);

                            parts.push(
                                '  ' +
                                exportValue(elementPair.getKey()) +
                                ' => ' +
                                exportValue(elementPair.getValue()) +
                                ',\n'
                            );
                        });
                        return 'array (\n' + parts.join('') + ')';
                    case 'boolean':
                    case 'float':
                    case 'int':
                        return '' + value.getNative();
                    case 'null':
                        return 'NULL';
                    case 'object':
                        if (value.getLength() > 0) {
                            throw new Error('var_export() :: Non-empty objects not implemented');
                        }

                        return value.getClassName() + '::__set_state(array(\n))';
                    case 'string':
                        return '\'' + value.getNative().replace(/['\\]/g, '\\$&') + '\'';
                    default:
                        throw new Error('var_export() :: Unexpected value type "' + value.getType() + '"');
                }
            }

            if (!valueReference) {
                callStack.raiseError(
                    PHPError.E_WARNING,
                    'var_export() expects at least 1 parameter, 0 given'
                );

                return valueFactory.createNull();
            }

            value = valueReference.getValue();

            // Output the string representation by default, or return it if specified
            shouldReturn = returnReference ? returnReference.getNative() : false;

            exportedCodeString = exportValue(value);

            if (shouldReturn) {
                return valueFactory.createString(exportedCodeString);
            }

            // No trailing newline should be output
            output.write(exportedCodeString);

            return valueFactory.createNull();
        },

        // NB: This output matches that of PHP with XDebug disabled
        'var_dump': function (valueReference) {
            var dumps = 0,
                value,
                objectIDHash = {};

            if (!valueReference) {
                callStack.raiseError(PHPError.E_WARNING, 'var_dump() expects at least 1 parameter, 0 given');
                return;
            }

            value = valueReference.getValue();

            function dump(value, depth, isReference, arraysEncountered) {
                var currentIndentation = new Array(depth).join('  '),
                    names,
                    nativeLength,
                    nativeValue,
                    nextIndentation = new Array(depth + 1).join('  '),
                    representation = currentIndentation;

                dumps++;

                if (depth > MAX_RECURSION_DEPTH || dumps > MAX_DUMPS) {
                    representation += '*RECURSION*';
                    return representation + '\n';
                }

                if (value.getType() === 'array') {
                    nativeValue = value.getValue();

                    if (arraysEncountered.indexOf(nativeValue) > -1) {
                        // Within the current branch of values being dumped, we've already
                        // dumped this array - bail out to avoid infinite recursion
                        representation += '*RECURSION*';

                        return representation + '\n';
                    }

                    if (depth > 1) {
                        arraysEncountered.push(nativeValue);
                    }

                    if (isReference) {
                        representation += '&';
                    }

                    representation += 'array(' + value.getLength() + ') {\n';

                    _.each(value.getKeys(), function (key) {
                        var element = value.getElementByKey(key),
                            elementRepresentation;

                        elementRepresentation = dump(
                            element.getValue(),
                            depth + 1,
                            element.isReference(),
                            arraysEncountered.slice()
                        );

                        representation += nextIndentation +
                            '[' +
                            JSON.stringify(key.getNative()) +
                            ']=>\n' +
                            elementRepresentation;
                    });

                    representation += currentIndentation + '}';
                } else if (value.getType() === 'object') {
                    if (hasOwn.call(objectIDHash, value.getID())) {
                        representation += '*RECURSION*';
                        return representation + '\n';
                    }

                    if (isReference) {
                        representation += '&';
                    }

                    names = value.getInstancePropertyNames();

                    representation += 'object(' + value.getClassName() + ')#' + value.getID() + ' (' + names.length + ') {\n';

                    objectIDHash[value.getID()] = true;

                    _.each(names, function (nameValue) {
                        var property = value.getInstancePropertyByName(nameValue);
                        representation += nextIndentation +
                            '[' +
                            JSON.stringify(nameValue.getNative()) +
                            ']=>\n' +
                            dump(
                                property.getValue(),
                                depth + 1,
                                property.isReference(),
                                arraysEncountered.slice()
                            );
                    });

                    representation += currentIndentation + '}';
                } else {
                    if (isReference) {
                        representation += '&';
                    }

                    switch (value.getType()) {
                    case 'boolean':
                        representation += 'bool(' + (value.getNative() ? 'true' : 'false') + ')';
                        break;
                    case 'float':
                        representation += 'float(' + value.getNative() + ')';
                        break;
                    case 'int':
                        representation += 'int(' + value.getNative() + ')';
                        break;
                    case 'null':
                        representation += 'NULL';
                        break;
                    case 'string':
                        nativeValue = value.getNative();
                        nativeLength = nativeValue.length;

                        if (nativeLength > MAX_STRING_LENGTH) {
                            nativeValue = nativeValue.substr(0, MAX_STRING_LENGTH) + '...';
                        }

                        representation += 'string(' + nativeLength + ') "' + nativeValue + '"';
                        break;
                    default:
                        throw new Error('var_dump() :: Unsupported value type "' + value.getType() + '"');
                    }
                }

                return representation + '\n';
            }

            output.write(dump(value, 1, false, []));
        }
    };
};


/***/ }),

/***/ "./node_modules/phpruntime/src/builtin/interfaces/SPL/Countable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/phpruntime/src/builtin/interfaces/SPL/Countable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * PHPCore - PHP environment runtime components
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/phpcore/
 *
 * Released under the MIT license
 * https://github.com/uniter/phpcore/raw/master/MIT-LICENSE.txt
 */



module.exports = function () {
    function Countable() {

    }

    return {
        'Countable': Countable
    };
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/template-string/index.js":
/*!***********************************************!*\
  !*** ./node_modules/template-string/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * TemplateString - Simple template strings
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/asmblah/template-string/
 *
 * Released under the MIT license
 * https://github.com/asmblah/template-string/raw/master/MIT-LICENSE.txt
 */



var hasOwn = {}.hasOwnProperty;

/**
 * Replaces placeholders in `string` of the form `${...}`
 * if they are specified as own properties of `variables`
 *
 * @param {string} string
 * @param {Object.<string, string>} variables
 * @returns {string}
 */
function templateString(string, variables) {
    if (!variables) {
        // Nothing to do if no variables object was provided
        return string;
    }

    return string.replace(/\$\{([^}]+)}/g, function (all, name) {
        if (hasOwn.call(variables, name)) {
            return variables[name];
        }

        return all;
    });
}

module.exports = templateString;


/***/ }),

/***/ "./node_modules/type/function/is.js":
/*!******************************************!*\
  !*** ./node_modules/type/function/is.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(/*! ../prototype/is */ "./node_modules/type/prototype/is.js");

module.exports = function (value) {
	if (typeof value !== "function") return false;

	if (!hasOwnProperty.call(value, "length")) return false;

	try {
		if (typeof value.length !== "number") return false;
		if (typeof value.call !== "function") return false;
		if (typeof value.apply !== "function") return false;
	} catch (error) {
		return false;
	}

	return !isPrototype(value);
};


/***/ }),

/***/ "./node_modules/type/lib/resolve-exception.js":
/*!****************************************************!*\
  !*** ./node_modules/type/lib/resolve-exception.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue       = __webpack_require__(/*! ../value/is */ "./node_modules/type/value/is.js")
  , isObject      = __webpack_require__(/*! ../object/is */ "./node_modules/type/object/is.js")
  , stringCoerce  = __webpack_require__(/*! ../string/coerce */ "./node_modules/type/string/coerce.js")
  , toShortString = __webpack_require__(/*! ./to-short-string */ "./node_modules/type/lib/to-short-string.js");

var resolveMessage = function (message, value) {
	return message.replace("%v", toShortString(value));
};

module.exports = function (value, defaultMessage, inputOptions) {
	if (!isObject(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));
	if (!isValue(value)) {
		if ("default" in inputOptions) return inputOptions["default"];
		if (inputOptions.isOptional) return null;
	}
	var errorMessage = stringCoerce(inputOptions.errorMessage);
	if (!isValue(errorMessage)) errorMessage = defaultMessage;
	throw new TypeError(resolveMessage(errorMessage, value));
};


/***/ }),

/***/ "./node_modules/type/lib/safe-to-string.js":
/*!*************************************************!*\
  !*** ./node_modules/type/lib/safe-to-string.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (value) {
	try {
		return value.toString();
	} catch (error) {
		try { return String(value); }
		catch (error2) { return null; }
	}
};


/***/ }),

/***/ "./node_modules/type/lib/to-short-string.js":
/*!**************************************************!*\
  !*** ./node_modules/type/lib/to-short-string.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var safeToString = __webpack_require__(/*! ./safe-to-string */ "./node_modules/type/lib/safe-to-string.js");

var reNewLine = /[\n\r\u2028\u2029]/g;

module.exports = function (value) {
	var string = safeToString(value);
	if (string === null) return "<Non-coercible to string value>";
	// Trim if too long
	if (string.length > 100) string = string.slice(0, 99) + "…";
	// Replace eventual new lines
	string = string.replace(reNewLine, function (char) {
		switch (char) {
			case "\n":
				return "\\n";
			case "\r":
				return "\\r";
			case "\u2028":
				return "\\u2028";
			case "\u2029":
				return "\\u2029";
			/* istanbul ignore next */
			default:
				throw new Error("Unexpected character");
		}
	});
	return string;
};


/***/ }),

/***/ "./node_modules/type/object/is.js":
/*!****************************************!*\
  !*** ./node_modules/type/object/is.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(/*! ../value/is */ "./node_modules/type/value/is.js");

// prettier-ignore
var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

module.exports = function (value) {
	if (!isValue(value)) return false;
	return hasOwnProperty.call(possibleTypes, typeof value);
};


/***/ }),

/***/ "./node_modules/type/plain-function/ensure.js":
/*!****************************************************!*\
  !*** ./node_modules/type/plain-function/ensure.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolveException = __webpack_require__(/*! ../lib/resolve-exception */ "./node_modules/type/lib/resolve-exception.js")
  , is               = __webpack_require__(/*! ./is */ "./node_modules/type/plain-function/is.js");

module.exports = function (value/*, options*/) {
	if (is(value)) return value;
	return resolveException(value, "%v is not a plain function", arguments[1]);
};


/***/ }),

/***/ "./node_modules/type/plain-function/is.js":
/*!************************************************!*\
  !*** ./node_modules/type/plain-function/is.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(/*! ../function/is */ "./node_modules/type/function/is.js");

var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;

module.exports = function (value) {
	if (!isFunction(value)) return false;
	if (classRe.test(functionToString.call(value))) return false;
	return true;
};


/***/ }),

/***/ "./node_modules/type/prototype/is.js":
/*!*******************************************!*\
  !*** ./node_modules/type/prototype/is.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ../object/is */ "./node_modules/type/object/is.js");

module.exports = function (value) {
	if (!isObject(value)) return false;
	try {
		if (!value.constructor) return false;
		return value.constructor.prototype === value;
	} catch (error) {
		return false;
	}
};


/***/ }),

/***/ "./node_modules/type/string/coerce.js":
/*!********************************************!*\
  !*** ./node_modules/type/string/coerce.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue  = __webpack_require__(/*! ../value/is */ "./node_modules/type/value/is.js")
  , isObject = __webpack_require__(/*! ../object/is */ "./node_modules/type/object/is.js");

var objectToString = Object.prototype.toString;

module.exports = function (value) {
	if (!isValue(value)) return null;
	if (isObject(value)) {
		// Reject Object.prototype.toString coercion
		var valueToString = value.toString;
		if (typeof valueToString !== "function") return null;
		if (valueToString === objectToString) return null;
		// Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant
		// way to resolve its realm's Object.prototype.toString it's left as not addressed edge case
	}
	try {
		return "" + value; // Ensure implicit coercion
	} catch (error) {
		return null;
	}
};


/***/ }),

/***/ "./node_modules/type/value/ensure.js":
/*!*******************************************!*\
  !*** ./node_modules/type/value/ensure.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolveException = __webpack_require__(/*! ../lib/resolve-exception */ "./node_modules/type/lib/resolve-exception.js")
  , is               = __webpack_require__(/*! ./is */ "./node_modules/type/value/is.js");

module.exports = function (value/*, options*/) {
	if (is(value)) return value;
	return resolveException(value, "Cannot use %v", arguments[1]);
};


/***/ }),

/***/ "./node_modules/type/value/is.js":
/*!***************************************!*\
  !*** ./node_modules/type/value/is.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ES3 safe
var _undefined = void 0;

module.exports = function (value) { return value !== _undefined && value !== null; };


/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/BoldNode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/BoldNode.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var BoldNode = /** @class */ (function () {
    function BoldNode(internals, elements) {
        this.internals = internals;
        this.elements = elements;
    }
    BoldNode.prototype.toHtml = function () {
        var _this = this;
        var valueHelper = this.internals.valueHelper;
        return this.internals.createFFIResult(function () {
            // For both sync and psync modes
            return ('<strong>' +
                _this.elements
                    .map(function (element) {
                    return valueHelper.toNativeWithSyncApi(element);
                })
                    .map(function (element) { return element.toHtml(); })
                    .join('') +
                '</strong>');
        }, function () {
            // Only for async mode
            return Promise.all(_this.elements.map(function (element) { return element.toHtml(); })).then(function (htmls) {
                return '<strong>' + htmls.join('') + '</strong>';
            });
        });
    };
    return BoldNode;
}());
exports.default = BoldNode;
exports.factory = function (internals) {
    return /** @class */ (function (_super) {
        __extends(ModeSpecificBoldNode, _super);
        function ModeSpecificBoldNode(elements) {
            return _super.call(this, internals, elements) || this;
        }
        return ModeSpecificBoldNode;
    }(BoldNode));
};
//# sourceMappingURL=BoldNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/DocumentNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/DocumentNode.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
/**
 * Represents an entire Markdown document
 */
var DocumentNode = /** @class */ (function () {
    function DocumentNode(internals, elements) {
        this.internals = internals;
        this.elements = elements;
    }
    DocumentNode.prototype.toHtml = function () {
        var _this = this;
        var valueHelper = this.internals.valueHelper;
        return this.internals.createFFIResult(function () {
            // For both sync and psync modes
            return _this.elements
                .map(function (element) { return valueHelper.toNativeWithSyncApi(element); }) // checks a ProxyClass instance was passed in
                .map(function (element) { return element.toHtml(); })
                .join('');
        }, function () {
            // Only for async mode
            return Promise.all(_this.elements.map(function (element) { return element.toHtml(); })).then(function (htmls) {
                return htmls.join('');
            });
        });
    };
    return DocumentNode;
}());
exports.default = DocumentNode;
exports.factory = function (internals) {
    return /** @class */ (function (_super) {
        __extends(ModeSpecificDocumentNode, _super);
        function ModeSpecificDocumentNode(elements) {
            return _super.call(this, internals, elements) || this;
        }
        return ModeSpecificDocumentNode;
    }(DocumentNode));
};
//# sourceMappingURL=DocumentNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ExpressionNode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ExpressionNode.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var ExpressionNode = /** @class */ (function () {
    function ExpressionNode(expression) {
        this.expression = expression;
    }
    ExpressionNode.prototype.toHtml = function () {
        if (this.expression === null) {
            // Use this placeholder for obviousness rather than an empty string as per PHP
            return '[NULL]';
        }
        if (typeof this.expression !== 'string' &&
            typeof this.expression !== 'number') {
            throw new Error("Expression is of unknown type: " + typeof this.expression);
        }
        return String(this.expression);
    };
    return ExpressionNode;
}());
exports.default = ExpressionNode;
exports.factory = function () {
    return ExpressionNode;
};
//# sourceMappingURL=ExpressionNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/HeadingNode.js":
/*!******************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/HeadingNode.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var HeadingNode = /** @class */ (function () {
    function HeadingNode(internals, level, elements) {
        this.internals = internals;
        this.level = level;
        this.elements = elements;
    }
    HeadingNode.prototype.toHtml = function () {
        var _this = this;
        var valueHelper = this.internals.valueHelper;
        var tagName = 'h' + this.level;
        return this.internals.createFFIResult(function () {
            // For both sync and psync modes
            return ("<" + tagName + ">" +
                _this.elements
                    .map(function (element) {
                    return valueHelper.toNativeWithSyncApi(element);
                })
                    .map(function (element) { return element.toHtml(); })
                    .join('') +
                ("</" + tagName + ">"));
        }, function () {
            // Only for async mode
            return Promise.all(_this.elements.map(function (element) { return element.toHtml(); })).then(function (htmls) {
                return "<" + tagName + ">" + htmls.join('') + ("</" + tagName + ">");
            });
        });
    };
    return HeadingNode;
}());
exports.default = HeadingNode;
exports.factory = function (internals) {
    return /** @class */ (function (_super) {
        __extends(ModeSpecificHeadingNode, _super);
        function ModeSpecificHeadingNode(level, elements) {
            return _super.call(this, internals, level, elements) || this;
        }
        return ModeSpecificHeadingNode;
    }(HeadingNode));
};
//# sourceMappingURL=HeadingNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/InlineCodeNode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/InlineCodeNode.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var InlineCodeNode = /** @class */ (function () {
    function InlineCodeNode(code) {
        this.code = code;
    }
    InlineCodeNode.prototype.toHtml = function () {
        return '<code>' + this.code + '</code>';
    };
    return InlineCodeNode;
}());
exports.default = InlineCodeNode;
exports.factory = function () {
    return InlineCodeNode;
};
//# sourceMappingURL=InlineCodeNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ItalicNode.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ItalicNode.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var ItalicNode = /** @class */ (function () {
    function ItalicNode(internals, elements) {
        this.internals = internals;
        this.elements = elements;
    }
    ItalicNode.prototype.toHtml = function () {
        var _this = this;
        var valueHelper = this.internals.valueHelper;
        return this.internals.createFFIResult(function () {
            // For both sync and psync modes
            return ('<em>' +
                _this.elements
                    .map(function (element) {
                    return valueHelper.toNativeWithSyncApi(element);
                })
                    .map(function (element) { return element.toHtml(); })
                    .join('') +
                '</em>');
        }, function () {
            // Only for async mode
            return Promise.all(_this.elements.map(function (element) { return element.toHtml(); })).then(function (htmls) {
                return '<em>' + htmls.join('') + '</em>';
            });
        });
    };
    return ItalicNode;
}());
exports.default = ItalicNode;
exports.factory = function (internals) {
    return /** @class */ (function (_super) {
        __extends(ModeSpecificItalicNode, _super);
        function ModeSpecificItalicNode(elements) {
            return _super.call(this, internals, elements) || this;
        }
        return ModeSpecificItalicNode;
    }(ItalicNode));
};
//# sourceMappingURL=ItalicNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ListItemNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ListItemNode.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var ListItemNode = /** @class */ (function () {
    function ListItemNode(internals, elements) {
        this.internals = internals;
        this.elements = elements;
    }
    ListItemNode.prototype.toHtml = function () {
        var _this = this;
        var valueHelper = this.internals.valueHelper;
        return this.internals.createFFIResult(function () {
            // For both sync and psync modes
            return ('<li>' +
                _this.elements
                    .map(function (element) {
                    return valueHelper.toNativeWithSyncApi(element);
                })
                    .map(function (element) { return element.toHtml(); })
                    .join('') +
                '</li>');
        }, function () {
            // Only for async mode
            return Promise.all(_this.elements.map(function (element) { return element.toHtml(); })).then(function (htmls) {
                return '<li>' + htmls.join('') + '</li>';
            });
        });
    };
    return ListItemNode;
}());
exports.default = ListItemNode;
exports.factory = function (internals) {
    return /** @class */ (function (_super) {
        __extends(ModeSpecificListItemNode, _super);
        function ModeSpecificListItemNode(elements) {
            return _super.call(this, internals, elements) || this;
        }
        return ModeSpecificListItemNode;
    }(ListItemNode));
};
//# sourceMappingURL=ListItemNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/PlainTextNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/PlainTextNode.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var PlainTextNode = /** @class */ (function () {
    function PlainTextNode(text) {
        this.text = text;
    }
    PlainTextNode.prototype.toHtml = function () {
        return this.text;
    };
    return PlainTextNode;
}());
exports.default = PlainTextNode;
exports.factory = function () {
    return PlainTextNode;
};
//# sourceMappingURL=PlainTextNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/UnorderedListNode.js":
/*!************************************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/Runtime/Node/UnorderedListNode.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.factory = void 0;
var UnorderedListNode = /** @class */ (function () {
    function UnorderedListNode(internals, listItemNodes) {
        this.internals = internals;
        this.listItemNodes = listItemNodes;
    }
    UnorderedListNode.prototype.toHtml = function () {
        var _this = this;
        var valueHelper = this.internals.valueHelper;
        return this.internals.createFFIResult(function () {
            // For both sync and psync modes
            return ('<ul>' +
                _this.listItemNodes
                    .map(function (element) {
                    return valueHelper.toNativeWithSyncApi(element);
                })
                    .map(function (element) { return element.toHtml(); })
                    .join('') +
                '</ul>');
        }, function () {
            // Only for async mode
            return Promise.all(_this.listItemNodes.map(function (element) { return element.toHtml(); })).then(function (htmls) {
                return '<ul>' + htmls.join('') + '</ul>';
            });
        });
    };
    return UnorderedListNode;
}());
exports.default = UnorderedListNode;
exports.factory = function (internals) {
    return /** @class */ (function (_super) {
        __extends(ModeSpecificUnorderedListNode, _super);
        function ModeSpecificUnorderedListNode(listItemNodes) {
            return _super.call(this, internals, listItemNodes) || this;
        }
        return ModeSpecificUnorderedListNode;
    }(UnorderedListNode));
};
//# sourceMappingURL=UnorderedListNode.js.map

/***/ }),

/***/ "./node_modules/uniter-markdown-plugin/dist/config.phpcore.js":
/*!********************************************************************!*\
  !*** ./node_modules/uniter-markdown-plugin/dist/config.phpcore.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Uniter Markdown Plugin - Adds support for an inline Markdown syntax to PHP
 * Copyright (c) Dan Phillimore (asmblah)
 * https://github.com/uniter/markdown-plugin/
 *
 * Released under the MIT license
 * https://github.com/uniter/markdown-plugin/raw/master/MIT-LICENSE.txt
 */
var BoldNode_1 = __webpack_require__(/*! ./Runtime/Node/BoldNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/BoldNode.js");
var DocumentNode_1 = __webpack_require__(/*! ./Runtime/Node/DocumentNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/DocumentNode.js");
var ExpressionNode_1 = __webpack_require__(/*! ./Runtime/Node/ExpressionNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ExpressionNode.js");
var HeadingNode_1 = __webpack_require__(/*! ./Runtime/Node/HeadingNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/HeadingNode.js");
var InlineCodeNode_1 = __webpack_require__(/*! ./Runtime/Node/InlineCodeNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/InlineCodeNode.js");
var ItalicNode_1 = __webpack_require__(/*! ./Runtime/Node/ItalicNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ItalicNode.js");
var ListItemNode_1 = __webpack_require__(/*! ./Runtime/Node/ListItemNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/ListItemNode.js");
var PlainTextNode_1 = __webpack_require__(/*! ./Runtime/Node/PlainTextNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/PlainTextNode.js");
var UnorderedListNode_1 = __webpack_require__(/*! ./Runtime/Node/UnorderedListNode */ "./node_modules/uniter-markdown-plugin/dist/Runtime/Node/UnorderedListNode.js");
module.exports = {
    addons: [
        {
            // Expose all the classes that will be instantiated to represent the nodes
            // of the Markdown document to PHP-land:
            classGroups: function () {
                return {
                    'Uniter\\Markdown\\Node\\BoldNode': BoldNode_1.factory,
                    'Uniter\\Markdown\\Node\\DocumentNode': DocumentNode_1.factory,
                    'Uniter\\Markdown\\Node\\ExpressionNode': ExpressionNode_1.factory,
                    'Uniter\\Markdown\\Node\\HeadingNode': HeadingNode_1.factory,
                    'Uniter\\Markdown\\Node\\InlineCodeNode': InlineCodeNode_1.factory,
                    'Uniter\\Markdown\\Node\\ItalicNode': ItalicNode_1.factory,
                    'Uniter\\Markdown\\Node\\ListItemNode': ListItemNode_1.factory,
                    'Uniter\\Markdown\\Node\\PlainTextNode': PlainTextNode_1.factory,
                    'Uniter\\Markdown\\Node\\UnorderedListNode': UnorderedListNode_1.factory,
                };
            },
        },
    ],
};
//# sourceMappingURL=config.phpcore.js.map

/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/Markdown.php":
/*!**************************!*\
  !*** ./src/Markdown.php ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("src/Markdown.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var line;tools.instrument(function () {return line;});line = 12;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("MyUniterProjects\\MarkdownPluginExample"), namespaceScope = tools.createNamespaceScope(namespace);line = 14;(function () {var currentClass = namespace.defineClass("Markdown", {superClass: null, interfaces: [], staticProperties: {}, properties: {}, methods: {"getHtml": {isStatic: false, method: function _getHtml() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");var $name = tools.createDebugVar(scope, "name");var $where = tools.createDebugVar(scope, "where");var $myMarkdownTree = tools.createDebugVar(scope, "myMarkdownTree");line = 18;(line = 18, (line = 18, scope.getVariable("name")).setValue((line = 18, tools.valueFactory.createString("Archie"))));line = 19;(line = 19, (line = 19, scope.getVariable("where")).setValue((line = 19, tools.valueFactory.createString("just where exactly"))));line = 22;(line = 22, (line = 22, scope.getVariable("myMarkdownTree")).setValue((line = 22, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\DocumentNode"), [tools.valueFactory.createArray([(line = 23, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\HeadingNode"), [tools.valueFactory.createInteger(3),tools.valueFactory.createArray([(line = 23, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString("My intro")]))])])),(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\UnorderedListNode"), [tools.valueFactory.createArray([(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\ListItemNode"), [tools.valueFactory.createArray([(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString("Firstly, hello ")])),(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\ItalicNode"), [tools.valueFactory.createArray([(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\ExpressionNode"), [(line = 24, scope.getVariable("name").getValue())]))])])),(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString(", how are ")])),(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\ItalicNode"), [tools.valueFactory.createArray([(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString("you")]))])])),(line = 24, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString("?")]))])])),(line = 25, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\ListItemNode"), [tools.valueFactory.createArray([(line = 25, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString("Secondly, ")])),(line = 25, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\ExpressionNode"), [(line = 25, scope.getVariable("where").getValue())])),(line = 25, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString(" did you go?")]))])]))])])),(line = 26, tools.createInstance(namespaceScope, tools.valueFactory.createString("Uniter\\Markdown\\Node\\PlainTextNode"), [tools.valueFactory.createString("        ")]))])]))));line = 28;return (line = 28, (line = 28, scope.getVariable("myMarkdownTree").getValue()).callMethod((line = 28, tools.valueFactory.createBarewordString("toHtml")).getNative(), []));}, args: [], line: 16}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/autoload.php":
/*!*****************************!*\
  !*** ./vendor/autoload.php ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/autoload.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var line;tools.instrument(function () {return line;});line = 5;(line = 5, tools.requireOnce((line = 5, (line = 5, tools.getPathDirectory()).concat((line = 5, tools.valueFactory.createString("/composer/autoload_real.php")))).getNative(), scope));line = 7;return (line = 7, (line = 7, tools.valueFactory.createBarewordString("ComposerAutoloaderInita938c0f9513fc8fb70dd34967ae81190")).callStaticMethod((line = 7, tools.valueFactory.createBarewordString("getLoader")), [], namespaceScope, false));return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/ClassLoader.php":
/*!*****************************************!*\
  !*** ./vendor/composer/ClassLoader.php ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/ClassLoader.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var line;tools.instrument(function () {return line;});line = 13;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Composer\\Autoload"), namespaceScope = tools.createNamespaceScope(namespace);line = 43;(function () {var currentClass = namespace.defineClass("ClassLoader", {superClass: null, interfaces: [], staticProperties: {"registeredLoaders": {visibility: "private", value: function (currentClass) { return (line = 62, tools.valueFactory.createArray([])); }}}, properties: {"vendorDir": {visibility: "private", value: function () { return null; }}, "prefixLengthsPsr4": {visibility: "private", value: function () { return (line = 48, tools.valueFactory.createArray([])); }}, "prefixDirsPsr4": {visibility: "private", value: function () { return (line = 49, tools.valueFactory.createArray([])); }}, "fallbackDirsPsr4": {visibility: "private", value: function () { return (line = 50, tools.valueFactory.createArray([])); }}, "prefixesPsr0": {visibility: "private", value: function () { return (line = 53, tools.valueFactory.createArray([])); }}, "fallbackDirsPsr0": {visibility: "private", value: function () { return (line = 54, tools.valueFactory.createArray([])); }}, "useIncludePath": {visibility: "private", value: function () { return (line = 56, tools.valueFactory.createBoolean(false)); }}, "classMap": {visibility: "private", value: function () { return (line = 57, tools.valueFactory.createArray([])); }}, "classMapAuthoritative": {visibility: "private", value: function () { return (line = 58, tools.valueFactory.createBoolean(false)); }}, "missingClasses": {visibility: "private", value: function () { return (line = 59, tools.valueFactory.createArray([])); }}, "apcuPrefix": {visibility: "private", value: function () { return null; }}}, methods: {"__construct": {isStatic: false, method: function ___construct($vendorDir) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("vendorDir").setValue($vendorDir.getValue());var $vendorDir = tools.createDebugVar(scope, "vendorDir");var $this = tools.createDebugVar(scope, "this");var $vendorDir = tools.createDebugVar(scope, "vendorDir");line = 66;(line = 66, (line = 66, tools.implyObject((line = 66, scope.getVariable("this"))).getInstancePropertyByName((line = 66, tools.valueFactory.createBarewordString("vendorDir")))).setValue((line = 66, scope.getVariable("vendorDir").getValue())));}, args: [{"name":"vendorDir","value":function () { return (line = 64, tools.valueFactory.createNull()); }}], line: 64}, "getPrefixes": {isStatic: false, method: function _getPrefixes() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 71;if ((line = 71, (line = 71, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 71, (line = 71, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 71, tools.valueFactory.createBarewordString("prefixesPsr0")))).isEmpty());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 72;return (line = 72, ((line = 72, tools.valueFactory.createBarewordString("call_user_func_array")).call([(line = 72, tools.valueFactory.createString("array_merge")), (line = 72, ((line = 72, tools.valueFactory.createBarewordString("array_values")).call([(line = 72, (line = 72, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 72, tools.valueFactory.createBarewordString("prefixesPsr0"))))], namespaceScope) || tools.valueFactory.createNull()))], namespaceScope) || tools.valueFactory.createNull()));}line = 75;return (line = 75, tools.valueFactory.createArray([]));}, args: [], line: 69}, "getPrefixesPsr4": {isStatic: false, method: function _getPrefixesPsr4() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 80;return (line = 80, (line = 80, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 80, tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getValue());}, args: [], line: 78}, "getFallbackDirs": {isStatic: false, method: function _getFallbackDirs() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 85;return (line = 85, (line = 85, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 85, tools.valueFactory.createBarewordString("fallbackDirsPsr0"))).getValue());}, args: [], line: 83}, "getFallbackDirsPsr4": {isStatic: false, method: function _getFallbackDirsPsr4() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 90;return (line = 90, (line = 90, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 90, tools.valueFactory.createBarewordString("fallbackDirsPsr4"))).getValue());}, args: [], line: 88}, "getClassMap": {isStatic: false, method: function _getClassMap() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 95;return (line = 95, (line = 95, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 95, tools.valueFactory.createBarewordString("classMap"))).getValue());}, args: [], line: 93}, "addClassMap": {isStatic: false, method: function _addClassMap($classMap) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("classMap").setValue($classMap.getValue());var $classMap = tools.createDebugVar(scope, "classMap");var $this = tools.createDebugVar(scope, "this");var $classMap = tools.createDebugVar(scope, "classMap");line = 103;if ((line = 103, (line = 103, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 103, tools.valueFactory.createBarewordString("classMap"))).getValue()).coerceToBoolean().getNative()) {line = 104;(line = 104, (line = 104, tools.implyObject((line = 104, scope.getVariable("this"))).getInstancePropertyByName((line = 104, tools.valueFactory.createBarewordString("classMap")))).setValue((line = 104, ((line = 104, tools.valueFactory.createBarewordString("array_merge")).call([(line = 104, (line = 104, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 104, tools.valueFactory.createBarewordString("classMap")))), (line = 104, scope.getVariable("classMap"))], namespaceScope) || tools.valueFactory.createNull()))));} else {line = 106;(line = 106, (line = 106, tools.implyObject((line = 106, scope.getVariable("this"))).getInstancePropertyByName((line = 106, tools.valueFactory.createBarewordString("classMap")))).setValue((line = 106, scope.getVariable("classMap").getValue())));}}, args: [{"type":"array","name":"classMap"}], line: 101}, "add": {isStatic: false, method: function _add($prefix, $paths, $prepend) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("prefix").setValue($prefix.getValue());var $prefix = tools.createDebugVar(scope, "prefix");scope.getVariable("paths").setValue($paths.getValue());var $paths = tools.createDebugVar(scope, "paths");scope.getVariable("prepend").setValue($prepend.getValue());var $prepend = tools.createDebugVar(scope, "prepend");var $this = tools.createDebugVar(scope, "this");var $prefix = tools.createDebugVar(scope, "prefix");var $prepend = tools.createDebugVar(scope, "prepend");var $paths = tools.createDebugVar(scope, "paths");var $first = tools.createDebugVar(scope, "first");line = 120;if ((line = 120, (line = 120, scope.getVariable("prefix").getValue()).logicalNot()).coerceToBoolean().getNative()) {line = 121;if ((line = 121, scope.getVariable("prepend").getValue()).coerceToBoolean().getNative()) {line = 122;(line = 122, (line = 122, tools.implyObject((line = 122, scope.getVariable("this"))).getInstancePropertyByName((line = 122, tools.valueFactory.createBarewordString("fallbackDirsPsr0")))).setValue((line = 122, ((line = 122, tools.valueFactory.createBarewordString("array_merge")).call([(line = 123, (line = 123, scope.getVariable("paths").getValue()).coerceToArray()), (line = 124, (line = 124, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 124, tools.valueFactory.createBarewordString("fallbackDirsPsr0"))))], namespaceScope) || tools.valueFactory.createNull()))));} else {line = 127;(line = 127, (line = 127, tools.implyObject((line = 127, scope.getVariable("this"))).getInstancePropertyByName((line = 127, tools.valueFactory.createBarewordString("fallbackDirsPsr0")))).setValue((line = 127, ((line = 127, tools.valueFactory.createBarewordString("array_merge")).call([(line = 128, (line = 128, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 128, tools.valueFactory.createBarewordString("fallbackDirsPsr0")))), (line = 129, (line = 129, scope.getVariable("paths").getValue()).coerceToArray())], namespaceScope) || tools.valueFactory.createNull()))));}line = 133;return tools.valueFactory.createNull();}line = 136;(line = 136, (line = 136, scope.getVariable("first")).setValue((line = 136, (line = 136, scope.getVariable("prefix").getValue()).getElementByKey((line = 136, tools.valueFactory.createInteger(0))).getValue())));line = 137;if ((line = 137, (line = 137, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 137, (line = 137, (line = 137, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 137, tools.valueFactory.createBarewordString("prefixesPsr0"))).getValue()).getElementByKey((line = 137, scope.getVariable("first").getValue())).getValue().getElementByKey((line = 137, scope.getVariable("prefix").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 138;(line = 138, (line = 138, tools.implyArray(tools.implyArray((line = 138, tools.implyObject((line = 138, scope.getVariable("this"))).getInstancePropertyByName((line = 138, tools.valueFactory.createBarewordString("prefixesPsr0"))))).getElementByKey((line = 138, scope.getVariable("first").getValue()))).getElementByKey((line = 138, scope.getVariable("prefix").getValue()))).setValue((line = 138, (line = 138, scope.getVariable("paths").getValue()).coerceToArray())));line = 140;return tools.valueFactory.createNull();}line = 142;if ((line = 142, scope.getVariable("prepend").getValue()).coerceToBoolean().getNative()) {line = 143;(line = 143, (line = 143, tools.implyArray(tools.implyArray((line = 143, tools.implyObject((line = 143, scope.getVariable("this"))).getInstancePropertyByName((line = 143, tools.valueFactory.createBarewordString("prefixesPsr0"))))).getElementByKey((line = 143, scope.getVariable("first").getValue()))).getElementByKey((line = 143, scope.getVariable("prefix").getValue()))).setValue((line = 143, ((line = 143, tools.valueFactory.createBarewordString("array_merge")).call([(line = 144, (line = 144, scope.getVariable("paths").getValue()).coerceToArray()), (line = 145, (line = 145, (line = 145, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 145, tools.valueFactory.createBarewordString("prefixesPsr0"))).getValue()).getElementByKey((line = 145, scope.getVariable("first").getValue())).getValue().getElementByKey((line = 145, scope.getVariable("prefix").getValue())))], namespaceScope) || tools.valueFactory.createNull()))));} else {line = 148;(line = 148, (line = 148, tools.implyArray(tools.implyArray((line = 148, tools.implyObject((line = 148, scope.getVariable("this"))).getInstancePropertyByName((line = 148, tools.valueFactory.createBarewordString("prefixesPsr0"))))).getElementByKey((line = 148, scope.getVariable("first").getValue()))).getElementByKey((line = 148, scope.getVariable("prefix").getValue()))).setValue((line = 148, ((line = 148, tools.valueFactory.createBarewordString("array_merge")).call([(line = 149, (line = 149, (line = 149, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 149, tools.valueFactory.createBarewordString("prefixesPsr0"))).getValue()).getElementByKey((line = 149, scope.getVariable("first").getValue())).getValue().getElementByKey((line = 149, scope.getVariable("prefix").getValue()))), (line = 150, (line = 150, scope.getVariable("paths").getValue()).coerceToArray())], namespaceScope) || tools.valueFactory.createNull()))));}}, args: [{"name":"prefix"},{"name":"paths"},{"name":"prepend","value":function () { return (line = 118, tools.valueFactory.createBoolean(false)); }}], line: 118}, "addPsr4": {isStatic: false, method: function _addPsr4($prefix, $paths, $prepend) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("prefix").setValue($prefix.getValue());var $prefix = tools.createDebugVar(scope, "prefix");scope.getVariable("paths").setValue($paths.getValue());var $paths = tools.createDebugVar(scope, "paths");scope.getVariable("prepend").setValue($prepend.getValue());var $prepend = tools.createDebugVar(scope, "prepend");var $this = tools.createDebugVar(scope, "this");var $prefix = tools.createDebugVar(scope, "prefix");var $prepend = tools.createDebugVar(scope, "prepend");var $paths = tools.createDebugVar(scope, "paths");var $length = tools.createDebugVar(scope, "length");line = 167;if ((line = 167, (line = 167, scope.getVariable("prefix").getValue()).logicalNot()).coerceToBoolean().getNative()) {line = 169;if ((line = 169, scope.getVariable("prepend").getValue()).coerceToBoolean().getNative()) {line = 170;(line = 170, (line = 170, tools.implyObject((line = 170, scope.getVariable("this"))).getInstancePropertyByName((line = 170, tools.valueFactory.createBarewordString("fallbackDirsPsr4")))).setValue((line = 170, ((line = 170, tools.valueFactory.createBarewordString("array_merge")).call([(line = 171, (line = 171, scope.getVariable("paths").getValue()).coerceToArray()), (line = 172, (line = 172, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 172, tools.valueFactory.createBarewordString("fallbackDirsPsr4"))))], namespaceScope) || tools.valueFactory.createNull()))));} else {line = 175;(line = 175, (line = 175, tools.implyObject((line = 175, scope.getVariable("this"))).getInstancePropertyByName((line = 175, tools.valueFactory.createBarewordString("fallbackDirsPsr4")))).setValue((line = 175, ((line = 175, tools.valueFactory.createBarewordString("array_merge")).call([(line = 176, (line = 176, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 176, tools.valueFactory.createBarewordString("fallbackDirsPsr4")))), (line = 177, (line = 177, scope.getVariable("paths").getValue()).coerceToArray())], namespaceScope) || tools.valueFactory.createNull()))));}} else {line = 180;if ((line = 180, (line = 180, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 180, (line = 180, (line = 180, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 180, tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getValue()).getElementByKey((line = 180, scope.getVariable("prefix").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 182;(line = 182, (line = 182, scope.getVariable("length")).setValue((line = 182, ((line = 182, tools.valueFactory.createBarewordString("strlen")).call([(line = 182, scope.getVariable("prefix"))], namespaceScope) || tools.valueFactory.createNull()))));line = 183;if ((line = 183, (line = 183, tools.valueFactory.createString("\\")).isNotIdenticalTo((line = 183, (line = 183, scope.getVariable("prefix").getValue()).getElementByKey((line = 183, (line = 183, scope.getVariable("length").getValue()).subtract((line = 183, tools.valueFactory.createInteger(1))))).getValue()))).coerceToBoolean().getNative()) {line = 184;throw (line = 184, tools.createInstance(namespaceScope, (line = 184, tools.valueFactory.createBarewordString("\\InvalidArgumentException")), [(line = 184, tools.valueFactory.createString("A non-empty PSR-4 prefix must end with a namespace separator."))]));}line = 186;(line = 186, (line = 186, tools.implyArray(tools.implyArray((line = 186, tools.implyObject((line = 186, scope.getVariable("this"))).getInstancePropertyByName((line = 186, tools.valueFactory.createBarewordString("prefixLengthsPsr4"))))).getElementByKey((line = 186, (line = 186, scope.getVariable("prefix").getValue()).getElementByKey((line = 186, tools.valueFactory.createInteger(0))).getValue()))).getElementByKey((line = 186, scope.getVariable("prefix").getValue()))).setValue((line = 186, scope.getVariable("length").getValue())));line = 187;(line = 187, (line = 187, tools.implyArray((line = 187, tools.implyObject((line = 187, scope.getVariable("this"))).getInstancePropertyByName((line = 187, tools.valueFactory.createBarewordString("prefixDirsPsr4"))))).getElementByKey((line = 187, scope.getVariable("prefix").getValue()))).setValue((line = 187, (line = 187, scope.getVariable("paths").getValue()).coerceToArray())));} else {line = 188;if ((line = 188, scope.getVariable("prepend").getValue()).coerceToBoolean().getNative()) {line = 190;(line = 190, (line = 190, tools.implyArray((line = 190, tools.implyObject((line = 190, scope.getVariable("this"))).getInstancePropertyByName((line = 190, tools.valueFactory.createBarewordString("prefixDirsPsr4"))))).getElementByKey((line = 190, scope.getVariable("prefix").getValue()))).setValue((line = 190, ((line = 190, tools.valueFactory.createBarewordString("array_merge")).call([(line = 191, (line = 191, scope.getVariable("paths").getValue()).coerceToArray()), (line = 192, (line = 192, (line = 192, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 192, tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getValue()).getElementByKey((line = 192, scope.getVariable("prefix").getValue())))], namespaceScope) || tools.valueFactory.createNull()))));} else {line = 196;(line = 196, (line = 196, tools.implyArray((line = 196, tools.implyObject((line = 196, scope.getVariable("this"))).getInstancePropertyByName((line = 196, tools.valueFactory.createBarewordString("prefixDirsPsr4"))))).getElementByKey((line = 196, scope.getVariable("prefix").getValue()))).setValue((line = 196, ((line = 196, tools.valueFactory.createBarewordString("array_merge")).call([(line = 197, (line = 197, (line = 197, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 197, tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getValue()).getElementByKey((line = 197, scope.getVariable("prefix").getValue()))), (line = 198, (line = 198, scope.getVariable("paths").getValue()).coerceToArray())], namespaceScope) || tools.valueFactory.createNull()))));}}}}, args: [{"name":"prefix"},{"name":"paths"},{"name":"prepend","value":function () { return (line = 165, tools.valueFactory.createBoolean(false)); }}], line: 165}, "set": {isStatic: false, method: function _set($prefix, $paths) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("prefix").setValue($prefix.getValue());var $prefix = tools.createDebugVar(scope, "prefix");scope.getVariable("paths").setValue($paths.getValue());var $paths = tools.createDebugVar(scope, "paths");var $this = tools.createDebugVar(scope, "this");var $prefix = tools.createDebugVar(scope, "prefix");var $paths = tools.createDebugVar(scope, "paths");line = 212;if ((line = 212, (line = 212, scope.getVariable("prefix").getValue()).logicalNot()).coerceToBoolean().getNative()) {line = 213;(line = 213, (line = 213, tools.implyObject((line = 213, scope.getVariable("this"))).getInstancePropertyByName((line = 213, tools.valueFactory.createBarewordString("fallbackDirsPsr0")))).setValue((line = 213, (line = 213, scope.getVariable("paths").getValue()).coerceToArray())));} else {line = 215;(line = 215, (line = 215, tools.implyArray(tools.implyArray((line = 215, tools.implyObject((line = 215, scope.getVariable("this"))).getInstancePropertyByName((line = 215, tools.valueFactory.createBarewordString("prefixesPsr0"))))).getElementByKey((line = 215, (line = 215, scope.getVariable("prefix").getValue()).getElementByKey((line = 215, tools.valueFactory.createInteger(0))).getValue()))).getElementByKey((line = 215, scope.getVariable("prefix").getValue()))).setValue((line = 215, (line = 215, scope.getVariable("paths").getValue()).coerceToArray())));}}, args: [{"name":"prefix"},{"name":"paths"}], line: 210}, "setPsr4": {isStatic: false, method: function _setPsr4($prefix, $paths) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("prefix").setValue($prefix.getValue());var $prefix = tools.createDebugVar(scope, "prefix");scope.getVariable("paths").setValue($paths.getValue());var $paths = tools.createDebugVar(scope, "paths");var $this = tools.createDebugVar(scope, "this");var $prefix = tools.createDebugVar(scope, "prefix");var $paths = tools.createDebugVar(scope, "paths");var $length = tools.createDebugVar(scope, "length");line = 230;if ((line = 230, (line = 230, scope.getVariable("prefix").getValue()).logicalNot()).coerceToBoolean().getNative()) {line = 231;(line = 231, (line = 231, tools.implyObject((line = 231, scope.getVariable("this"))).getInstancePropertyByName((line = 231, tools.valueFactory.createBarewordString("fallbackDirsPsr4")))).setValue((line = 231, (line = 231, scope.getVariable("paths").getValue()).coerceToArray())));} else {line = 233;(line = 233, (line = 233, scope.getVariable("length")).setValue((line = 233, ((line = 233, tools.valueFactory.createBarewordString("strlen")).call([(line = 233, scope.getVariable("prefix"))], namespaceScope) || tools.valueFactory.createNull()))));line = 234;if ((line = 234, (line = 234, tools.valueFactory.createString("\\")).isNotIdenticalTo((line = 234, (line = 234, scope.getVariable("prefix").getValue()).getElementByKey((line = 234, (line = 234, scope.getVariable("length").getValue()).subtract((line = 234, tools.valueFactory.createInteger(1))))).getValue()))).coerceToBoolean().getNative()) {line = 235;throw (line = 235, tools.createInstance(namespaceScope, (line = 235, tools.valueFactory.createBarewordString("\\InvalidArgumentException")), [(line = 235, tools.valueFactory.createString("A non-empty PSR-4 prefix must end with a namespace separator."))]));}line = 237;(line = 237, (line = 237, tools.implyArray(tools.implyArray((line = 237, tools.implyObject((line = 237, scope.getVariable("this"))).getInstancePropertyByName((line = 237, tools.valueFactory.createBarewordString("prefixLengthsPsr4"))))).getElementByKey((line = 237, (line = 237, scope.getVariable("prefix").getValue()).getElementByKey((line = 237, tools.valueFactory.createInteger(0))).getValue()))).getElementByKey((line = 237, scope.getVariable("prefix").getValue()))).setValue((line = 237, scope.getVariable("length").getValue())));line = 238;(line = 238, (line = 238, tools.implyArray((line = 238, tools.implyObject((line = 238, scope.getVariable("this"))).getInstancePropertyByName((line = 238, tools.valueFactory.createBarewordString("prefixDirsPsr4"))))).getElementByKey((line = 238, scope.getVariable("prefix").getValue()))).setValue((line = 238, (line = 238, scope.getVariable("paths").getValue()).coerceToArray())));}}, args: [{"name":"prefix"},{"name":"paths"}], line: 228}, "setUseIncludePath": {isStatic: false, method: function _setUseIncludePath($useIncludePath) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("useIncludePath").setValue($useIncludePath.getValue());var $useIncludePath = tools.createDebugVar(scope, "useIncludePath");var $this = tools.createDebugVar(scope, "this");var $useIncludePath = tools.createDebugVar(scope, "useIncludePath");line = 249;(line = 249, (line = 249, tools.implyObject((line = 249, scope.getVariable("this"))).getInstancePropertyByName((line = 249, tools.valueFactory.createBarewordString("useIncludePath")))).setValue((line = 249, scope.getVariable("useIncludePath").getValue())));}, args: [{"name":"useIncludePath"}], line: 247}, "getUseIncludePath": {isStatic: false, method: function _getUseIncludePath() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 260;return (line = 260, (line = 260, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 260, tools.valueFactory.createBarewordString("useIncludePath"))).getValue());}, args: [], line: 258}, "setClassMapAuthoritative": {isStatic: false, method: function _setClassMapAuthoritative($classMapAuthoritative) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("classMapAuthoritative").setValue($classMapAuthoritative.getValue());var $classMapAuthoritative = tools.createDebugVar(scope, "classMapAuthoritative");var $this = tools.createDebugVar(scope, "this");var $classMapAuthoritative = tools.createDebugVar(scope, "classMapAuthoritative");line = 271;(line = 271, (line = 271, tools.implyObject((line = 271, scope.getVariable("this"))).getInstancePropertyByName((line = 271, tools.valueFactory.createBarewordString("classMapAuthoritative")))).setValue((line = 271, scope.getVariable("classMapAuthoritative").getValue())));}, args: [{"name":"classMapAuthoritative"}], line: 269}, "isClassMapAuthoritative": {isStatic: false, method: function _isClassMapAuthoritative() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 281;return (line = 281, (line = 281, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 281, tools.valueFactory.createBarewordString("classMapAuthoritative"))).getValue());}, args: [], line: 279}, "setApcuPrefix": {isStatic: false, method: function _setApcuPrefix($apcuPrefix) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("apcuPrefix").setValue($apcuPrefix.getValue());var $apcuPrefix = tools.createDebugVar(scope, "apcuPrefix");var $this = tools.createDebugVar(scope, "this");var $apcuPrefix = tools.createDebugVar(scope, "apcuPrefix");line = 291;(line = 291, (line = 291, tools.implyObject((line = 291, scope.getVariable("this"))).getInstancePropertyByName((line = 291, tools.valueFactory.createBarewordString("apcuPrefix")))).setValue((line = 291, ((line = 291, tools.valueFactory.createBoolean((line = 291, ((line = 291, tools.valueFactory.createBarewordString("function_exists")).call([(line = 291, tools.valueFactory.createString("apcu_fetch"))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative() && ((line = 291, ((line = 291, tools.valueFactory.createBarewordString("filter_var")).call([(line = 291, ((line = 291, tools.valueFactory.createBarewordString("ini_get")).call([(line = 291, tools.valueFactory.createString("apc.enabled"))], namespaceScope) || tools.valueFactory.createNull())), (line = 291, namespaceScope.getConstant("FILTER_VALIDATE_BOOLEAN"))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()))).coerceToBoolean().getNative() ? (line = 291, scope.getVariable("apcuPrefix").getValue()) : (line = 291, tools.valueFactory.createNull())))));}, args: [{"name":"apcuPrefix"}], line: 289}, "getApcuPrefix": {isStatic: false, method: function _getApcuPrefix() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 301;return (line = 301, (line = 301, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 301, tools.valueFactory.createBarewordString("apcuPrefix"))).getValue());}, args: [], line: 299}, "register": {isStatic: false, method: function _register($prepend) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("prepend").setValue($prepend.getValue());var $prepend = tools.createDebugVar(scope, "prepend");var $this = tools.createDebugVar(scope, "this");var $prepend = tools.createDebugVar(scope, "prepend");line = 311;(line = 311, ((line = 311, tools.valueFactory.createBarewordString("spl_autoload_register")).call([(line = 311, tools.valueFactory.createArray([(line = 311, scope.getVariable("this").getValue()), (line = 311, tools.valueFactory.createString("loadClass"))])), (line = 311, tools.valueFactory.createBoolean(true)), (line = 311, scope.getVariable("prepend"))], namespaceScope) || tools.valueFactory.createNull()));line = 313;if ((line = 313, (line = 313, tools.valueFactory.createNull()).isIdenticalTo((line = 313, (line = 313, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 313, tools.valueFactory.createBarewordString("vendorDir"))).getValue()))).coerceToBoolean().getNative()) {} else {line = 315;if ((line = 315, scope.getVariable("prepend").getValue()).coerceToBoolean().getNative()) {line = 316;(line = 316, (line = 316, (line = 316, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 316, tools.valueFactory.createBarewordString("registeredLoaders")), namespaceScope)).setValue((line = 316, (line = 316, tools.valueFactory.createArray([(line = 316, tools.createKeyValuePair((line = 316, (line = 316, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 316, tools.valueFactory.createBarewordString("vendorDir"))).getValue()), (line = 316, scope.getVariable("this").getValue())))])).add((line = 316, (line = 316, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 316, tools.valueFactory.createBarewordString("registeredLoaders")), namespaceScope).getValue())))));} else {line = 318;(line = 318, (line = 318, (line = 318, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 318, tools.valueFactory.createBarewordString("registeredLoaders")), namespaceScope).getValue()).getElementByKey((line = 318, (line = 318, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 318, tools.valueFactory.createBarewordString("vendorDir"))).getValue()))).unset();line = 319;(line = 319, (line = 319, tools.implyArray((line = 319, (line = 319, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 319, tools.valueFactory.createBarewordString("registeredLoaders")), namespaceScope))).getElementByKey((line = 319, (line = 319, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 319, tools.valueFactory.createBarewordString("vendorDir"))).getValue()))).setValue((line = 319, scope.getVariable("this").getValue())));}}}, args: [{"name":"prepend","value":function () { return (line = 309, tools.valueFactory.createBoolean(false)); }}], line: 309}, "unregister": {isStatic: false, method: function _unregister() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 328;(line = 328, ((line = 328, tools.valueFactory.createBarewordString("spl_autoload_unregister")).call([(line = 328, tools.valueFactory.createArray([(line = 328, scope.getVariable("this").getValue()), (line = 328, tools.valueFactory.createString("loadClass"))]))], namespaceScope) || tools.valueFactory.createNull()));line = 330;if ((line = 330, (line = 330, tools.valueFactory.createNull()).isNotIdenticalTo((line = 330, (line = 330, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 330, tools.valueFactory.createBarewordString("vendorDir"))).getValue()))).coerceToBoolean().getNative()) {line = 331;(line = 331, (line = 331, (line = 331, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 331, tools.valueFactory.createBarewordString("registeredLoaders")), namespaceScope).getValue()).getElementByKey((line = 331, (line = 331, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 331, tools.valueFactory.createBarewordString("vendorDir"))).getValue()))).unset();}}, args: [], line: 326}, "loadClass": {isStatic: false, method: function _loadClass($class) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("class").setValue($class.getValue());var $class = tools.createDebugVar(scope, "class");var $this = tools.createDebugVar(scope, "this");var $file = tools.createDebugVar(scope, "file");var $class = tools.createDebugVar(scope, "class");line = 343;if ((line = 343, (line = 343, scope.getVariable("file")).setValue((line = 343, (line = 343, scope.getVariable("this").getValue()).callMethod((line = 343, tools.valueFactory.createBarewordString("findFile")).getNative(), [(line = 343, scope.getVariable("class"))])))).coerceToBoolean().getNative()) {line = 344;(line = 344, ((line = 344, tools.valueFactory.createBarewordString("includeFile")).call([(line = 344, scope.getVariable("file"))], namespaceScope) || tools.valueFactory.createNull()));line = 346;return (line = 346, tools.valueFactory.createBoolean(true));}}, args: [{"name":"class"}], line: 341}, "findFile": {isStatic: false, method: function _findFile($class) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("class").setValue($class.getValue());var $class = tools.createDebugVar(scope, "class");var $this = tools.createDebugVar(scope, "this");var $class = tools.createDebugVar(scope, "class");var $file = tools.createDebugVar(scope, "file");var $hit = tools.createDebugVar(scope, "hit");line = 360;if ((line = 360, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 360, (line = 360, (line = 360, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 360, tools.valueFactory.createBarewordString("classMap"))).getValue()).getElementByKey((line = 360, scope.getVariable("class").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()) {line = 361;return (line = 361, (line = 361, (line = 361, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 361, tools.valueFactory.createBarewordString("classMap"))).getValue()).getElementByKey((line = 361, scope.getVariable("class").getValue())).getValue());}line = 363;if ((line = 363, tools.valueFactory.createBoolean((line = 363, (line = 363, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 363, tools.valueFactory.createBarewordString("classMapAuthoritative"))).getValue()).coerceToBoolean().getNative() || ((line = 363, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 363, (line = 363, (line = 363, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 363, tools.valueFactory.createBarewordString("missingClasses"))).getValue()).getElementByKey((line = 363, scope.getVariable("class").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()))).coerceToBoolean().getNative()) {line = 364;return (line = 364, tools.valueFactory.createBoolean(false));}line = 366;if ((line = 366, (line = 366, tools.valueFactory.createNull()).isNotIdenticalTo((line = 366, (line = 366, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 366, tools.valueFactory.createBarewordString("apcuPrefix"))).getValue()))).coerceToBoolean().getNative()) {line = 367;(line = 367, (line = 367, scope.getVariable("file")).setValue((line = 367, ((line = 367, tools.valueFactory.createBarewordString("apcu_fetch")).call([(line = 367, (line = 367, (line = 367, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 367, tools.valueFactory.createBarewordString("apcuPrefix"))).getValue()).concat((line = 367, scope.getVariable("class").getValue()))), (line = 367, scope.getVariable("hit"))], namespaceScope) || tools.valueFactory.createNull()))));line = 368;if ((line = 368, scope.getVariable("hit").getValue()).coerceToBoolean().getNative()) {line = 369;return (line = 369, scope.getVariable("file").getValue());}}line = 373;(line = 373, (line = 373, scope.getVariable("file")).setValue((line = 373, (line = 373, scope.getVariable("this").getValue()).callMethod((line = 373, tools.valueFactory.createBarewordString("findFileWithExtension")).getNative(), [(line = 373, scope.getVariable("class")), (line = 373, tools.valueFactory.createString(".php"))]))));line = 376;if ((line = 376, tools.valueFactory.createBoolean((line = 376, (line = 376, tools.valueFactory.createBoolean(false)).isIdenticalTo((line = 376, scope.getVariable("file").getValue()))).coerceToBoolean().getNative() && ((line = 376, ((line = 376, tools.valueFactory.createBarewordString("defined")).call([(line = 376, tools.valueFactory.createString("HHVM_VERSION"))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()))).coerceToBoolean().getNative()) {line = 377;(line = 377, (line = 377, scope.getVariable("file")).setValue((line = 377, (line = 377, scope.getVariable("this").getValue()).callMethod((line = 377, tools.valueFactory.createBarewordString("findFileWithExtension")).getNative(), [(line = 377, scope.getVariable("class")), (line = 377, tools.valueFactory.createString(".hh"))]))));}line = 380;if ((line = 380, (line = 380, tools.valueFactory.createNull()).isNotIdenticalTo((line = 380, (line = 380, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 380, tools.valueFactory.createBarewordString("apcuPrefix"))).getValue()))).coerceToBoolean().getNative()) {line = 381;(line = 381, ((line = 381, tools.valueFactory.createBarewordString("apcu_add")).call([(line = 381, (line = 381, (line = 381, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 381, tools.valueFactory.createBarewordString("apcuPrefix"))).getValue()).concat((line = 381, scope.getVariable("class").getValue()))), (line = 381, scope.getVariable("file"))], namespaceScope) || tools.valueFactory.createNull()));}line = 384;if ((line = 384, (line = 384, tools.valueFactory.createBoolean(false)).isIdenticalTo((line = 384, scope.getVariable("file").getValue()))).coerceToBoolean().getNative()) {line = 386;(line = 386, (line = 386, tools.implyArray((line = 386, tools.implyObject((line = 386, scope.getVariable("this"))).getInstancePropertyByName((line = 386, tools.valueFactory.createBarewordString("missingClasses"))))).getElementByKey((line = 386, scope.getVariable("class").getValue()))).setValue((line = 386, tools.valueFactory.createBoolean(true))));}line = 389;return (line = 389, scope.getVariable("file").getValue());}, args: [{"name":"class"}], line: 357}, "getRegisteredLoaders": {isStatic: true, method: function _getRegisteredLoaders() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 399;return (line = 399, (line = 399, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 399, tools.valueFactory.createBarewordString("registeredLoaders")), namespaceScope).getValue());}, args: [], line: 397}, "findFileWithExtension": {isStatic: false, method: function _findFileWithExtension($class, $ext) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("class").setValue($class.getValue());var $class = tools.createDebugVar(scope, "class");scope.getVariable("ext").setValue($ext.getValue());var $ext = tools.createDebugVar(scope, "ext");var $this = tools.createDebugVar(scope, "this");var $logicalPathPsr4 = tools.createDebugVar(scope, "logicalPathPsr4");var $class = tools.createDebugVar(scope, "class");var $ext = tools.createDebugVar(scope, "ext");var $first = tools.createDebugVar(scope, "first");var $subPath = tools.createDebugVar(scope, "subPath");var $lastPos = tools.createDebugVar(scope, "lastPos");var $search = tools.createDebugVar(scope, "search");var $pathEnd = tools.createDebugVar(scope, "pathEnd");var $dir = tools.createDebugVar(scope, "dir");var $file = tools.createDebugVar(scope, "file");var $pos = tools.createDebugVar(scope, "pos");var $logicalPathPsr0 = tools.createDebugVar(scope, "logicalPathPsr0");var $prefix = tools.createDebugVar(scope, "prefix");var $dirs = tools.createDebugVar(scope, "dirs");line = 405;(line = 405, (line = 405, scope.getVariable("logicalPathPsr4")).setValue((line = 405, (line = 405, ((line = 405, tools.valueFactory.createBarewordString("strtr")).call([(line = 405, scope.getVariable("class")), (line = 405, tools.valueFactory.createString("\\")), (line = 405, namespaceScope.getConstant("DIRECTORY_SEPARATOR"))], namespaceScope) || tools.valueFactory.createNull())).concat((line = 405, scope.getVariable("ext").getValue())))));line = 407;(line = 407, (line = 407, scope.getVariable("first")).setValue((line = 407, (line = 407, scope.getVariable("class").getValue()).getElementByKey((line = 407, tools.valueFactory.createInteger(0))).getValue())));line = 408;if ((line = 408, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 408, (line = 408, (line = 408, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 408, tools.valueFactory.createBarewordString("prefixLengthsPsr4"))).getValue()).getElementByKey((line = 408, scope.getVariable("first").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()) {line = 409;(line = 409, (line = 409, scope.getVariable("subPath")).setValue((line = 409, scope.getVariable("class").getValue())));line = 410;block_1: while ((line = 410, (line = 410, tools.valueFactory.createBoolean(false)).isNotIdenticalTo((line = 410, (line = 410, scope.getVariable("lastPos")).setValue((line = 410, ((line = 410, tools.valueFactory.createBarewordString("strrpos")).call([(line = 410, scope.getVariable("subPath")), (line = 410, tools.valueFactory.createString("\\"))], namespaceScope) || tools.valueFactory.createNull())))))).coerceToBoolean().getNative()) {line = 411;(line = 411, (line = 411, scope.getVariable("subPath")).setValue((line = 411, ((line = 411, tools.valueFactory.createBarewordString("substr")).call([(line = 411, scope.getVariable("subPath")), (line = 411, tools.valueFactory.createInteger(0)), (line = 411, scope.getVariable("lastPos"))], namespaceScope) || tools.valueFactory.createNull()))));line = 412;(line = 412, (line = 412, scope.getVariable("search")).setValue((line = 412, (line = 412, scope.getVariable("subPath").getValue()).concat((line = 412, tools.valueFactory.createString("\\"))))));line = 413;if ((line = 413, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 413, (line = 413, (line = 413, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 413, tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getValue()).getElementByKey((line = 413, scope.getVariable("search").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()) {line = 414;(line = 414, (line = 414, scope.getVariable("pathEnd")).setValue((line = 414, (line = 414, namespaceScope.getConstant("DIRECTORY_SEPARATOR")).concat((line = 414, ((line = 414, tools.valueFactory.createBarewordString("substr")).call([(line = 414, scope.getVariable("logicalPathPsr4")), (line = 414, (line = 414, scope.getVariable("lastPos").getValue()).add((line = 414, tools.valueFactory.createInteger(1))))], namespaceScope) || tools.valueFactory.createNull()))))));line = 415;block_2: for (var iterator_2 = (line = 415, (line = 415, (line = 415, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 415, tools.valueFactory.createBarewordString("prefixDirsPsr4"))).getValue()).getElementByKey((line = 415, scope.getVariable("search").getValue())).getValue()).getIterator(); iterator_2.isNotFinished(); iterator_2.advance()) {(line = 415, scope.getVariable("dir")).setValue(iterator_2.getCurrentElementValue());line = 416;if ((line = 416, ((line = 416, tools.valueFactory.createBarewordString("file_exists")).call([(line = 416, (line = 416, scope.getVariable("file")).setValue((line = 416, (line = 416, scope.getVariable("dir").getValue()).concat((line = 416, scope.getVariable("pathEnd").getValue())))))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 417;return (line = 417, scope.getVariable("file").getValue());}}}}}line = 425;block_1: for (var iterator_1 = (line = 425, (line = 425, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 425, tools.valueFactory.createBarewordString("fallbackDirsPsr4"))).getValue()).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 425, scope.getVariable("dir")).setValue(iterator_1.getCurrentElementValue());line = 426;if ((line = 426, ((line = 426, tools.valueFactory.createBarewordString("file_exists")).call([(line = 426, (line = 426, scope.getVariable("file")).setValue((line = 426, (line = 426, (line = 426, scope.getVariable("dir").getValue()).concat((line = 426, namespaceScope.getConstant("DIRECTORY_SEPARATOR")))).concat((line = 426, scope.getVariable("logicalPathPsr4").getValue())))))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 427;return (line = 427, scope.getVariable("file").getValue());}}line = 432;if ((line = 432, (line = 432, tools.valueFactory.createBoolean(false)).isNotIdenticalTo((line = 432, (line = 432, scope.getVariable("pos")).setValue((line = 432, ((line = 432, tools.valueFactory.createBarewordString("strrpos")).call([(line = 432, scope.getVariable("class")), (line = 432, tools.valueFactory.createString("\\"))], namespaceScope) || tools.valueFactory.createNull())))))).coerceToBoolean().getNative()) {line = 434;(line = 434, (line = 434, scope.getVariable("logicalPathPsr0")).setValue((line = 434, (line = 434, ((line = 434, tools.valueFactory.createBarewordString("substr")).call([(line = 434, scope.getVariable("logicalPathPsr4")), (line = 434, tools.valueFactory.createInteger(0)), (line = 434, (line = 434, scope.getVariable("pos").getValue()).add((line = 434, tools.valueFactory.createInteger(1))))], namespaceScope) || tools.valueFactory.createNull())).concat((line = 435, ((line = 435, tools.valueFactory.createBarewordString("strtr")).call([(line = 435, ((line = 435, tools.valueFactory.createBarewordString("substr")).call([(line = 435, scope.getVariable("logicalPathPsr4")), (line = 435, (line = 435, scope.getVariable("pos").getValue()).add((line = 435, tools.valueFactory.createInteger(1))))], namespaceScope) || tools.valueFactory.createNull())), (line = 435, tools.valueFactory.createString("_")), (line = 435, namespaceScope.getConstant("DIRECTORY_SEPARATOR"))], namespaceScope) || tools.valueFactory.createNull()))))));} else {line = 438;(line = 438, (line = 438, scope.getVariable("logicalPathPsr0")).setValue((line = 438, (line = 438, ((line = 438, tools.valueFactory.createBarewordString("strtr")).call([(line = 438, scope.getVariable("class")), (line = 438, tools.valueFactory.createString("_")), (line = 438, namespaceScope.getConstant("DIRECTORY_SEPARATOR"))], namespaceScope) || tools.valueFactory.createNull())).concat((line = 438, scope.getVariable("ext").getValue())))));}line = 441;if ((line = 441, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 441, (line = 441, (line = 441, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 441, tools.valueFactory.createBarewordString("prefixesPsr0"))).getValue()).getElementByKey((line = 441, scope.getVariable("first").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()) {line = 442;block_1: for (var iterator_1 = (line = 442, (line = 442, (line = 442, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 442, tools.valueFactory.createBarewordString("prefixesPsr0"))).getValue()).getElementByKey((line = 442, scope.getVariable("first").getValue())).getValue()).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 442, scope.getVariable("dirs")).setValue(iterator_1.getCurrentElementValue());(line = 442, scope.getVariable("prefix")).setValue(iterator_1.getCurrentKey());line = 443;if ((line = 443, (line = 443, tools.valueFactory.createInteger(0)).isIdenticalTo((line = 443, ((line = 443, tools.valueFactory.createBarewordString("strpos")).call([(line = 443, scope.getVariable("class")), (line = 443, scope.getVariable("prefix"))], namespaceScope) || tools.valueFactory.createNull())))).coerceToBoolean().getNative()) {line = 444;block_2: for (var iterator_2 = (line = 444, scope.getVariable("dirs").getValue()).getIterator(); iterator_2.isNotFinished(); iterator_2.advance()) {(line = 444, scope.getVariable("dir")).setValue(iterator_2.getCurrentElementValue());line = 445;if ((line = 445, ((line = 445, tools.valueFactory.createBarewordString("file_exists")).call([(line = 445, (line = 445, scope.getVariable("file")).setValue((line = 445, (line = 445, (line = 445, scope.getVariable("dir").getValue()).concat((line = 445, namespaceScope.getConstant("DIRECTORY_SEPARATOR")))).concat((line = 445, scope.getVariable("logicalPathPsr0").getValue())))))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 446;return (line = 446, scope.getVariable("file").getValue());}}}}}line = 454;block_1: for (var iterator_1 = (line = 454, (line = 454, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 454, tools.valueFactory.createBarewordString("fallbackDirsPsr0"))).getValue()).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 454, scope.getVariable("dir")).setValue(iterator_1.getCurrentElementValue());line = 455;if ((line = 455, ((line = 455, tools.valueFactory.createBarewordString("file_exists")).call([(line = 455, (line = 455, scope.getVariable("file")).setValue((line = 455, (line = 455, (line = 455, scope.getVariable("dir").getValue()).concat((line = 455, namespaceScope.getConstant("DIRECTORY_SEPARATOR")))).concat((line = 455, scope.getVariable("logicalPathPsr0").getValue())))))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 456;return (line = 456, scope.getVariable("file").getValue());}}line = 461;if ((line = 461, tools.valueFactory.createBoolean((line = 461, (line = 461, scope.getVariable("this").getValue()).getInstancePropertyByName((line = 461, tools.valueFactory.createBarewordString("useIncludePath"))).getValue()).coerceToBoolean().getNative() && ((line = 461, (line = 461, scope.getVariable("file")).setValue((line = 461, ((line = 461, tools.valueFactory.createBarewordString("stream_resolve_include_path")).call([(line = 461, scope.getVariable("logicalPathPsr0"))], namespaceScope) || tools.valueFactory.createNull())))).coerceToBoolean().getNative()))).coerceToBoolean().getNative()) {line = 462;return (line = 462, scope.getVariable("file").getValue());}line = 465;return (line = 465, tools.valueFactory.createBoolean(false));}, args: [{"name":"class"},{"name":"ext"}], line: 402}}, constants: {}}, namespaceScope);}());line = 474;namespace.defineFunction("includeFile", function _includeFile($file) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("file").setValue($file.getValue());var $file = tools.createDebugVar(scope, "file");var $this = tools.createDebugVar(scope, "this");var $file = tools.createDebugVar(scope, "file");line = 476;(line = 476, tools.include((line = 476, scope.getVariable("file").getValue()).getNative(), scope));}, namespaceScope, [{"name":"file"}], 474);}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/InstalledVersions.php":
/*!***********************************************!*\
  !*** ./vendor/composer/InstalledVersions.php ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/InstalledVersions.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var line;tools.instrument(function () {return line;});line = 13;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Composer"), namespaceScope = tools.createNamespaceScope(namespace);line = 15;namespaceScope.use("Composer\\Autoload\\ClassLoader");line = 16;namespaceScope.use("Composer\\Semver\\VersionParser");line = 23;(function () {var currentClass = namespace.defineClass("InstalledVersions", {superClass: null, interfaces: [], staticProperties: {"installed": {visibility: "private", value: function (currentClass) { return (line = 25, tools.valueFactory.createArray([(line = 26, tools.createKeyValuePair((line = 26, tools.valueFactory.createString("root")), (line = 27, tools.valueFactory.createArray([(line = 28, tools.createKeyValuePair((line = 28, tools.valueFactory.createString("pretty_version")), (line = 28, tools.valueFactory.createString("1.0.0+no-version-set")))), (line = 29, tools.createKeyValuePair((line = 29, tools.valueFactory.createString("version")), (line = 29, tools.valueFactory.createString("1.0.0.0")))), (line = 30, tools.createKeyValuePair((line = 30, tools.valueFactory.createString("aliases")), (line = 31, tools.valueFactory.createArray([])))), (line = 33, tools.createKeyValuePair((line = 33, tools.valueFactory.createString("reference")), (line = 33, tools.valueFactory.createNull()))), (line = 34, tools.createKeyValuePair((line = 34, tools.valueFactory.createString("name")), (line = 34, tools.valueFactory.createString("uniter/markdown-plugin-example"))))])))), (line = 36, tools.createKeyValuePair((line = 36, tools.valueFactory.createString("versions")), (line = 37, tools.valueFactory.createArray([(line = 38, tools.createKeyValuePair((line = 38, tools.valueFactory.createString("uniter/markdown-plugin-example")), (line = 39, tools.valueFactory.createArray([(line = 40, tools.createKeyValuePair((line = 40, tools.valueFactory.createString("pretty_version")), (line = 40, tools.valueFactory.createString("1.0.0+no-version-set")))), (line = 41, tools.createKeyValuePair((line = 41, tools.valueFactory.createString("version")), (line = 41, tools.valueFactory.createString("1.0.0.0")))), (line = 42, tools.createKeyValuePair((line = 42, tools.valueFactory.createString("aliases")), (line = 43, tools.valueFactory.createArray([])))), (line = 45, tools.createKeyValuePair((line = 45, tools.valueFactory.createString("reference")), (line = 45, tools.valueFactory.createNull())))]))))]))))])); }}, "canGetVendors": {visibility: "private", value: function (currentClass) { return tools.valueFactory.createNull(); }}, "installedByVendor": {visibility: "private", value: function (currentClass) { return (line = 50, tools.valueFactory.createArray([])); }}}, properties: {}, methods: {"getInstalledPackages": {isStatic: true, method: function _getInstalledPackages() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");var $packages = tools.createDebugVar(scope, "packages");var $installed = tools.createDebugVar(scope, "installed");line = 60;(line = 60, (line = 60, scope.getVariable("packages")).setValue((line = 60, tools.valueFactory.createArray([]))));line = 61;block_1: for (var iterator_1 = (line = 61, (line = 61, scope.getClassNameOrThrow()).callStaticMethod((line = 61, tools.valueFactory.createBarewordString("getInstalled")), [], namespaceScope, true)).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 61, scope.getVariable("installed")).setValue(iterator_1.getCurrentElementValue());line = 62;(line = 62, (line = 62, tools.implyArray((line = 62, scope.getVariable("packages"))).getPushElement()).setValue((line = 62, ((line = 62, tools.valueFactory.createBarewordString("array_keys")).call([(line = 62, (line = 62, scope.getVariable("installed").getValue()).getElementByKey((line = 62, tools.valueFactory.createString("versions"))))], namespaceScope) || tools.valueFactory.createNull()))));}line = 66;if ((line = 66, (line = 66, tools.valueFactory.createInteger(1)).isIdenticalTo((line = 66, ((line = 66, tools.valueFactory.createBarewordString("\\count")).call([(line = 66, scope.getVariable("packages"))], namespaceScope) || tools.valueFactory.createNull())))).coerceToBoolean().getNative()) {line = 67;return (line = 67, (line = 67, scope.getVariable("packages").getValue()).getElementByKey((line = 67, tools.valueFactory.createInteger(0))).getValue());}line = 70;return (line = 70, ((line = 70, tools.valueFactory.createBarewordString("array_keys")).call([(line = 70, ((line = 70, tools.valueFactory.createBarewordString("array_flip")).call([(line = 70, ((line = 70, tools.valueFactory.createBarewordString("\\call_user_func_array")).call([(line = 70, tools.valueFactory.createString("array_merge")), (line = 70, scope.getVariable("packages"))], namespaceScope) || tools.valueFactory.createNull()))], namespaceScope) || tools.valueFactory.createNull()))], namespaceScope) || tools.valueFactory.createNull()));}, args: [], line: 58}, "isInstalled": {isStatic: true, method: function _isInstalled($packageName) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("packageName").setValue($packageName.getValue());var $packageName = tools.createDebugVar(scope, "packageName");var $this = tools.createDebugVar(scope, "this");var $installed = tools.createDebugVar(scope, "installed");var $packageName = tools.createDebugVar(scope, "packageName");line = 83;block_1: for (var iterator_1 = (line = 83, (line = 83, scope.getClassNameOrThrow()).callStaticMethod((line = 83, tools.valueFactory.createBarewordString("getInstalled")), [], namespaceScope, true)).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 83, scope.getVariable("installed")).setValue(iterator_1.getCurrentElementValue());line = 84;if ((line = 84, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 84, (line = 84, scope.getVariable("installed").getValue()).getElementByKey((line = 84, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 84, scope.getVariable("packageName").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()) {line = 85;return (line = 85, tools.valueFactory.createBoolean(true));}}line = 89;return (line = 89, tools.valueFactory.createBoolean(false));}, args: [{"name":"packageName"}], line: 81}, "satisfies": {isStatic: true, method: function _satisfies($parser, $packageName, $constraint) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("parser").setValue($parser.getValue());var $parser = tools.createDebugVar(scope, "parser");scope.getVariable("packageName").setValue($packageName.getValue());var $packageName = tools.createDebugVar(scope, "packageName");scope.getVariable("constraint").setValue($constraint.getValue());var $constraint = tools.createDebugVar(scope, "constraint");var $this = tools.createDebugVar(scope, "this");var $constraint = tools.createDebugVar(scope, "constraint");var $parser = tools.createDebugVar(scope, "parser");var $provided = tools.createDebugVar(scope, "provided");var $packageName = tools.createDebugVar(scope, "packageName");line = 107;(line = 107, (line = 107, scope.getVariable("constraint")).setValue((line = 107, (line = 107, scope.getVariable("parser").getValue()).callMethod((line = 107, tools.valueFactory.createBarewordString("parseConstraints")).getNative(), [(line = 107, scope.getVariable("constraint"))]))));line = 108;(line = 108, (line = 108, scope.getVariable("provided")).setValue((line = 108, (line = 108, scope.getVariable("parser").getValue()).callMethod((line = 108, tools.valueFactory.createBarewordString("parseConstraints")).getNative(), [(line = 108, (line = 108, scope.getClassNameOrThrow()).callStaticMethod((line = 108, tools.valueFactory.createBarewordString("getVersionRanges")), [(line = 108, scope.getVariable("packageName"))], namespaceScope, true))]))));line = 110;return (line = 110, (line = 110, scope.getVariable("provided").getValue()).callMethod((line = 110, tools.valueFactory.createBarewordString("matches")).getNative(), [(line = 110, scope.getVariable("constraint"))]));}, args: [{"type":"class","className":"VersionParser","name":"parser"},{"name":"packageName"},{"name":"constraint"}], line: 105}, "getVersionRanges": {isStatic: true, method: function _getVersionRanges($packageName) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("packageName").setValue($packageName.getValue());var $packageName = tools.createDebugVar(scope, "packageName");var $this = tools.createDebugVar(scope, "this");var $installed = tools.createDebugVar(scope, "installed");var $packageName = tools.createDebugVar(scope, "packageName");var $ranges = tools.createDebugVar(scope, "ranges");line = 124;block_1: for (var iterator_1 = (line = 124, (line = 124, scope.getClassNameOrThrow()).callStaticMethod((line = 124, tools.valueFactory.createBarewordString("getInstalled")), [], namespaceScope, true)).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 124, scope.getVariable("installed")).setValue(iterator_1.getCurrentElementValue());line = 125;if ((line = 125, (line = 125, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 125, (line = 125, scope.getVariable("installed").getValue()).getElementByKey((line = 125, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 125, scope.getVariable("packageName").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 126;continue block_1;}line = 129;(line = 129, (line = 129, scope.getVariable("ranges")).setValue((line = 129, tools.valueFactory.createArray([]))));line = 130;if ((line = 130, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 130, (line = 130, scope.getVariable("installed").getValue()).getElementByKey((line = 130, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 130, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 130, tools.valueFactory.createString("pretty_version")))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()) {line = 131;(line = 131, (line = 131, tools.implyArray((line = 131, scope.getVariable("ranges"))).getPushElement()).setValue((line = 131, (line = 131, scope.getVariable("installed").getValue()).getElementByKey((line = 131, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 131, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 131, tools.valueFactory.createString("pretty_version"))).getValue())));}line = 133;if ((line = 133, ((line = 133, tools.valueFactory.createBarewordString("array_key_exists")).call([(line = 133, tools.valueFactory.createString("aliases")), (line = 133, (line = 133, scope.getVariable("installed").getValue()).getElementByKey((line = 133, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 133, scope.getVariable("packageName").getValue())))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 134;(line = 134, (line = 134, scope.getVariable("ranges")).setValue((line = 134, ((line = 134, tools.valueFactory.createBarewordString("array_merge")).call([(line = 134, scope.getVariable("ranges")), (line = 134, (line = 134, scope.getVariable("installed").getValue()).getElementByKey((line = 134, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 134, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 134, tools.valueFactory.createString("aliases"))))], namespaceScope) || tools.valueFactory.createNull()))));}line = 136;if ((line = 136, ((line = 136, tools.valueFactory.createBarewordString("array_key_exists")).call([(line = 136, tools.valueFactory.createString("replaced")), (line = 136, (line = 136, scope.getVariable("installed").getValue()).getElementByKey((line = 136, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 136, scope.getVariable("packageName").getValue())))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 137;(line = 137, (line = 137, scope.getVariable("ranges")).setValue((line = 137, ((line = 137, tools.valueFactory.createBarewordString("array_merge")).call([(line = 137, scope.getVariable("ranges")), (line = 137, (line = 137, scope.getVariable("installed").getValue()).getElementByKey((line = 137, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 137, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 137, tools.valueFactory.createString("replaced"))))], namespaceScope) || tools.valueFactory.createNull()))));}line = 139;if ((line = 139, ((line = 139, tools.valueFactory.createBarewordString("array_key_exists")).call([(line = 139, tools.valueFactory.createString("provided")), (line = 139, (line = 139, scope.getVariable("installed").getValue()).getElementByKey((line = 139, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 139, scope.getVariable("packageName").getValue())))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 140;(line = 140, (line = 140, scope.getVariable("ranges")).setValue((line = 140, ((line = 140, tools.valueFactory.createBarewordString("array_merge")).call([(line = 140, scope.getVariable("ranges")), (line = 140, (line = 140, scope.getVariable("installed").getValue()).getElementByKey((line = 140, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 140, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 140, tools.valueFactory.createString("provided"))))], namespaceScope) || tools.valueFactory.createNull()))));}line = 143;return (line = 143, ((line = 143, tools.valueFactory.createBarewordString("implode")).call([(line = 143, tools.valueFactory.createString(" || ")), (line = 143, scope.getVariable("ranges"))], namespaceScope) || tools.valueFactory.createNull()));}line = 146;throw (line = 146, tools.createInstance(namespaceScope, (line = 146, tools.valueFactory.createBarewordString("\\OutOfBoundsException")), [(line = 146, (line = 146, (line = 146, tools.valueFactory.createString("Package \"")).concat((line = 146, scope.getVariable("packageName").getValue()))).concat((line = 146, tools.valueFactory.createString("\" is not installed"))))]));}, args: [{"name":"packageName"}], line: 122}, "getVersion": {isStatic: true, method: function _getVersion($packageName) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("packageName").setValue($packageName.getValue());var $packageName = tools.createDebugVar(scope, "packageName");var $this = tools.createDebugVar(scope, "this");var $installed = tools.createDebugVar(scope, "installed");var $packageName = tools.createDebugVar(scope, "packageName");line = 155;block_1: for (var iterator_1 = (line = 155, (line = 155, scope.getClassNameOrThrow()).callStaticMethod((line = 155, tools.valueFactory.createBarewordString("getInstalled")), [], namespaceScope, true)).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 155, scope.getVariable("installed")).setValue(iterator_1.getCurrentElementValue());line = 156;if ((line = 156, (line = 156, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 156, (line = 156, scope.getVariable("installed").getValue()).getElementByKey((line = 156, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 156, scope.getVariable("packageName").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 157;continue block_1;}line = 160;if ((line = 160, (line = 160, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 160, (line = 160, scope.getVariable("installed").getValue()).getElementByKey((line = 160, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 160, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 160, tools.valueFactory.createString("version")))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 161;return (line = 161, tools.valueFactory.createNull());}line = 164;return (line = 164, (line = 164, scope.getVariable("installed").getValue()).getElementByKey((line = 164, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 164, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 164, tools.valueFactory.createString("version"))).getValue());}line = 167;throw (line = 167, tools.createInstance(namespaceScope, (line = 167, tools.valueFactory.createBarewordString("\\OutOfBoundsException")), [(line = 167, (line = 167, (line = 167, tools.valueFactory.createString("Package \"")).concat((line = 167, scope.getVariable("packageName").getValue()))).concat((line = 167, tools.valueFactory.createString("\" is not installed"))))]));}, args: [{"name":"packageName"}], line: 153}, "getPrettyVersion": {isStatic: true, method: function _getPrettyVersion($packageName) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("packageName").setValue($packageName.getValue());var $packageName = tools.createDebugVar(scope, "packageName");var $this = tools.createDebugVar(scope, "this");var $installed = tools.createDebugVar(scope, "installed");var $packageName = tools.createDebugVar(scope, "packageName");line = 176;block_1: for (var iterator_1 = (line = 176, (line = 176, scope.getClassNameOrThrow()).callStaticMethod((line = 176, tools.valueFactory.createBarewordString("getInstalled")), [], namespaceScope, true)).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 176, scope.getVariable("installed")).setValue(iterator_1.getCurrentElementValue());line = 177;if ((line = 177, (line = 177, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 177, (line = 177, scope.getVariable("installed").getValue()).getElementByKey((line = 177, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 177, scope.getVariable("packageName").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 178;continue block_1;}line = 181;if ((line = 181, (line = 181, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 181, (line = 181, scope.getVariable("installed").getValue()).getElementByKey((line = 181, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 181, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 181, tools.valueFactory.createString("pretty_version")))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 182;return (line = 182, tools.valueFactory.createNull());}line = 185;return (line = 185, (line = 185, scope.getVariable("installed").getValue()).getElementByKey((line = 185, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 185, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 185, tools.valueFactory.createString("pretty_version"))).getValue());}line = 188;throw (line = 188, tools.createInstance(namespaceScope, (line = 188, tools.valueFactory.createBarewordString("\\OutOfBoundsException")), [(line = 188, (line = 188, (line = 188, tools.valueFactory.createString("Package \"")).concat((line = 188, scope.getVariable("packageName").getValue()))).concat((line = 188, tools.valueFactory.createString("\" is not installed"))))]));}, args: [{"name":"packageName"}], line: 174}, "getReference": {isStatic: true, method: function _getReference($packageName) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("packageName").setValue($packageName.getValue());var $packageName = tools.createDebugVar(scope, "packageName");var $this = tools.createDebugVar(scope, "this");var $installed = tools.createDebugVar(scope, "installed");var $packageName = tools.createDebugVar(scope, "packageName");line = 197;block_1: for (var iterator_1 = (line = 197, (line = 197, scope.getClassNameOrThrow()).callStaticMethod((line = 197, tools.valueFactory.createBarewordString("getInstalled")), [], namespaceScope, true)).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 197, scope.getVariable("installed")).setValue(iterator_1.getCurrentElementValue());line = 198;if ((line = 198, (line = 198, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 198, (line = 198, scope.getVariable("installed").getValue()).getElementByKey((line = 198, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 198, scope.getVariable("packageName").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 199;continue block_1;}line = 202;if ((line = 202, (line = 202, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 202, (line = 202, scope.getVariable("installed").getValue()).getElementByKey((line = 202, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 202, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 202, tools.valueFactory.createString("reference")))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).logicalNot()).coerceToBoolean().getNative()) {line = 203;return (line = 203, tools.valueFactory.createNull());}line = 206;return (line = 206, (line = 206, scope.getVariable("installed").getValue()).getElementByKey((line = 206, tools.valueFactory.createString("versions"))).getValue().getElementByKey((line = 206, scope.getVariable("packageName").getValue())).getValue().getElementByKey((line = 206, tools.valueFactory.createString("reference"))).getValue());}line = 209;throw (line = 209, tools.createInstance(namespaceScope, (line = 209, tools.valueFactory.createBarewordString("\\OutOfBoundsException")), [(line = 209, (line = 209, (line = 209, tools.valueFactory.createString("Package \"")).concat((line = 209, scope.getVariable("packageName").getValue()))).concat((line = 209, tools.valueFactory.createString("\" is not installed"))))]));}, args: [{"name":"packageName"}], line: 195}, "getRootPackage": {isStatic: true, method: function _getRootPackage() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");var $installed = tools.createDebugVar(scope, "installed");line = 218;(line = 218, (line = 218, scope.getVariable("installed")).setValue((line = 218, (line = 218, scope.getClassNameOrThrow()).callStaticMethod((line = 218, tools.valueFactory.createBarewordString("getInstalled")), [], namespaceScope, true))));line = 220;return (line = 220, (line = 220, scope.getVariable("installed").getValue()).getElementByKey((line = 220, tools.valueFactory.createInteger(0))).getValue().getElementByKey((line = 220, tools.valueFactory.createString("root"))).getValue());}, args: [], line: 216}, "getRawData": {isStatic: true, method: function _getRawData() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");line = 231;return (line = 231, (line = 231, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 231, tools.valueFactory.createBarewordString("installed")), namespaceScope).getValue());}, args: [], line: 229}, "reload": {isStatic: true, method: function _reload($data) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("data").setValue($data.getValue());var $data = tools.createDebugVar(scope, "data");var $this = tools.createDebugVar(scope, "this");var $data = tools.createDebugVar(scope, "data");line = 254;(line = 254, (line = 254, (line = 254, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 254, tools.valueFactory.createBarewordString("installed")), namespaceScope)).setValue((line = 254, scope.getVariable("data").getValue())));line = 255;(line = 255, (line = 255, (line = 255, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 255, tools.valueFactory.createBarewordString("installedByVendor")), namespaceScope)).setValue((line = 255, tools.valueFactory.createArray([]))));}, args: [{"name":"data"}], line: 252}, "getInstalled": {isStatic: true, method: function _getInstalled() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");var $installed = tools.createDebugVar(scope, "installed");var $vendorDir = tools.createDebugVar(scope, "vendorDir");var $loader = tools.createDebugVar(scope, "loader");line = 263;if ((line = 263, (line = 263, tools.valueFactory.createNull()).isIdenticalTo((line = 263, (line = 263, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 263, tools.valueFactory.createBarewordString("canGetVendors")), namespaceScope).getValue()))).coerceToBoolean().getNative()) {line = 264;(line = 264, (line = 264, (line = 264, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 264, tools.valueFactory.createBarewordString("canGetVendors")), namespaceScope)).setValue((line = 264, ((line = 264, tools.valueFactory.createBarewordString("method_exists")).call([(line = 264, tools.valueFactory.createString("Composer\\Autoload\\ClassLoader")), (line = 264, tools.valueFactory.createString("getRegisteredLoaders"))], namespaceScope) || tools.valueFactory.createNull()))));}line = 267;(line = 267, (line = 267, scope.getVariable("installed")).setValue((line = 267, tools.valueFactory.createArray([]))));line = 269;if ((line = 269, (line = 269, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 269, tools.valueFactory.createBarewordString("canGetVendors")), namespaceScope).getValue()).coerceToBoolean().getNative()) {line = 271;block_1: for (var iterator_1 = (line = 271, (line = 271, tools.valueFactory.createBarewordString("ClassLoader")).callStaticMethod((line = 271, tools.valueFactory.createBarewordString("getRegisteredLoaders")), [], namespaceScope, false)).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 271, scope.getVariable("loader")).setValue(iterator_1.getCurrentElementValue());(line = 271, scope.getVariable("vendorDir")).setValue(iterator_1.getCurrentKey());line = 272;if ((line = 272, (function (scope) {scope.suppressOwnErrors();var result = tools.valueFactory.createBoolean((line = 272, (line = 272, (line = 272, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 272, tools.valueFactory.createBarewordString("installedByVendor")), namespaceScope).getValue()).getElementByKey((line = 272, scope.getVariable("vendorDir").getValue()))).isSet());scope.unsuppressOwnErrors(); return result;}(scope))).coerceToBoolean().getNative()) {line = 273;(line = 273, (line = 273, tools.implyArray((line = 273, scope.getVariable("installed"))).getPushElement()).setValue((line = 273, (line = 273, (line = 273, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 273, tools.valueFactory.createBarewordString("installedByVendor")), namespaceScope).getValue()).getElementByKey((line = 273, scope.getVariable("vendorDir").getValue())).getValue())));} else {line = 274;if ((line = 274, ((line = 274, tools.valueFactory.createBarewordString("is_file")).call([(line = 274, (line = 274, scope.getVariable("vendorDir").getValue()).concat((line = 274, tools.valueFactory.createString("/composer/installed.php"))))], namespaceScope) || tools.valueFactory.createNull())).coerceToBoolean().getNative()) {line = 275;(line = 275, (line = 275, tools.implyArray((line = 275, scope.getVariable("installed"))).getPushElement()).setValue((line = 275, (line = 275, tools.implyArray((line = 275, (line = 275, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 275, tools.valueFactory.createBarewordString("installedByVendor")), namespaceScope))).getElementByKey((line = 275, scope.getVariable("vendorDir").getValue()))).setValue((line = 275, tools.require((line = 275, (line = 275, scope.getVariable("vendorDir").getValue()).concat((line = 275, tools.valueFactory.createString("/composer/installed.php")))).getNative(), scope))))));}}}}line = 280;(line = 280, (line = 280, tools.implyArray((line = 280, scope.getVariable("installed"))).getPushElement()).setValue((line = 280, (line = 280, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 280, tools.valueFactory.createBarewordString("installed")), namespaceScope).getValue())));line = 282;return (line = 282, scope.getVariable("installed").getValue());}, args: [], line: 261}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/autoload_classmap.php":
/*!***********************************************!*\
  !*** ./vendor/composer/autoload_classmap.php ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/autoload_classmap.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var $baseDir = tools.createDebugVar(scope, "baseDir");var $vendorDir = tools.createDebugVar(scope, "vendorDir");var line;tools.instrument(function () {return line;});line = 5;(line = 5, (line = 5, scope.getVariable("vendorDir")).setValue((line = 5, ((line = 5, tools.valueFactory.createBarewordString("dirname")).call([(line = 5, ((line = 5, tools.valueFactory.createBarewordString("dirname")).call([(line = 5, tools.getPath())], namespaceScope) || tools.valueFactory.createNull()))], namespaceScope) || tools.valueFactory.createNull()))));line = 6;(line = 6, (line = 6, scope.getVariable("baseDir")).setValue((line = 6, ((line = 6, tools.valueFactory.createBarewordString("dirname")).call([(line = 6, scope.getVariable("vendorDir"))], namespaceScope) || tools.valueFactory.createNull()))));line = 8;return (line = 8, tools.valueFactory.createArray([(line = 9, tools.createKeyValuePair((line = 9, tools.valueFactory.createString("Composer\\InstalledVersions")), (line = 9, (line = 9, scope.getVariable("vendorDir").getValue()).concat((line = 9, tools.valueFactory.createString("/composer/InstalledVersions.php"))))))]));return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/autoload_namespaces.php":
/*!*************************************************!*\
  !*** ./vendor/composer/autoload_namespaces.php ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/autoload_namespaces.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var $baseDir = tools.createDebugVar(scope, "baseDir");var $vendorDir = tools.createDebugVar(scope, "vendorDir");var line;tools.instrument(function () {return line;});line = 5;(line = 5, (line = 5, scope.getVariable("vendorDir")).setValue((line = 5, ((line = 5, tools.valueFactory.createBarewordString("dirname")).call([(line = 5, ((line = 5, tools.valueFactory.createBarewordString("dirname")).call([(line = 5, tools.getPath())], namespaceScope) || tools.valueFactory.createNull()))], namespaceScope) || tools.valueFactory.createNull()))));line = 6;(line = 6, (line = 6, scope.getVariable("baseDir")).setValue((line = 6, ((line = 6, tools.valueFactory.createBarewordString("dirname")).call([(line = 6, scope.getVariable("vendorDir"))], namespaceScope) || tools.valueFactory.createNull()))));line = 8;return (line = 8, tools.valueFactory.createArray([]));return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/autoload_psr4.php":
/*!*******************************************!*\
  !*** ./vendor/composer/autoload_psr4.php ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/autoload_psr4.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var $baseDir = tools.createDebugVar(scope, "baseDir");var $vendorDir = tools.createDebugVar(scope, "vendorDir");var line;tools.instrument(function () {return line;});line = 5;(line = 5, (line = 5, scope.getVariable("vendorDir")).setValue((line = 5, ((line = 5, tools.valueFactory.createBarewordString("dirname")).call([(line = 5, ((line = 5, tools.valueFactory.createBarewordString("dirname")).call([(line = 5, tools.getPath())], namespaceScope) || tools.valueFactory.createNull()))], namespaceScope) || tools.valueFactory.createNull()))));line = 6;(line = 6, (line = 6, scope.getVariable("baseDir")).setValue((line = 6, ((line = 6, tools.valueFactory.createBarewordString("dirname")).call([(line = 6, scope.getVariable("vendorDir"))], namespaceScope) || tools.valueFactory.createNull()))));line = 8;return (line = 8, tools.valueFactory.createArray([(line = 9, tools.createKeyValuePair((line = 9, tools.valueFactory.createString("MyUniterProjects\\MarkdownPluginExample\\")), (line = 9, tools.valueFactory.createArray([(line = 9, (line = 9, scope.getVariable("baseDir").getValue()).concat((line = 9, tools.valueFactory.createString("/src"))))]))))]));return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/autoload_real.php":
/*!*******************************************!*\
  !*** ./vendor/composer/autoload_real.php ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/autoload_real.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var line;tools.instrument(function () {return line;});line = 5;(function () {var currentClass = namespace.defineClass("ComposerAutoloaderInita938c0f9513fc8fb70dd34967ae81190", {superClass: null, interfaces: [], staticProperties: {"loader": {visibility: "private", value: function (currentClass) { return tools.valueFactory.createNull(); }}}, properties: {}, methods: {"loadClassLoader": {isStatic: true, method: function _loadClassLoader($class) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("class").setValue($class.getValue());var $class = tools.createDebugVar(scope, "class");var $this = tools.createDebugVar(scope, "this");var $class = tools.createDebugVar(scope, "class");line = 11;if ((line = 11, (line = 11, tools.valueFactory.createString("Composer\\Autoload\\ClassLoader")).isIdenticalTo((line = 11, scope.getVariable("class").getValue()))).coerceToBoolean().getNative()) {line = 12;(line = 12, tools.require((line = 12, (line = 12, tools.getPathDirectory()).concat((line = 12, tools.valueFactory.createString("/ClassLoader.php")))).getNative(), scope));}}, args: [{"name":"class"}], line: 9}, "getLoader": {isStatic: true, method: function _getLoader() {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");var $loader = tools.createDebugVar(scope, "loader");var $useStaticLoader = tools.createDebugVar(scope, "useStaticLoader");var $map = tools.createDebugVar(scope, "map");var $namespace = tools.createDebugVar(scope, "namespace");var $path = tools.createDebugVar(scope, "path");var $classMap = tools.createDebugVar(scope, "classMap");line = 21;if ((line = 21, (line = 21, tools.valueFactory.createNull()).isNotIdenticalTo((line = 21, (line = 21, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 21, tools.valueFactory.createBarewordString("loader")), namespaceScope).getValue()))).coerceToBoolean().getNative()) {line = 22;return (line = 22, (line = 22, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 22, tools.valueFactory.createBarewordString("loader")), namespaceScope).getValue());}line = 25;(line = 25, ((line = 25, tools.valueFactory.createBarewordString("spl_autoload_register")).call([(line = 25, tools.valueFactory.createArray([(line = 25, tools.valueFactory.createString("ComposerAutoloaderInita938c0f9513fc8fb70dd34967ae81190")), (line = 25, tools.valueFactory.createString("loadClassLoader"))])), (line = 25, tools.valueFactory.createBoolean(true)), (line = 25, tools.valueFactory.createBoolean(true))], namespaceScope) || tools.valueFactory.createNull()));line = 26;(line = 26, (line = 26, (line = 26, scope.getClassNameOrThrow()).getStaticPropertyByName((line = 26, tools.valueFactory.createBarewordString("loader")), namespaceScope)).setValue((line = 26, (line = 26, scope.getVariable("loader")).setValue((line = 26, tools.createInstance(namespaceScope, (line = 26, tools.valueFactory.createBarewordString("\\Composer\\Autoload\\ClassLoader")), [(line = 26, ((line = 26, tools.valueFactory.createBarewordString("\\dirname")).call([(line = 26, ((line = 26, tools.valueFactory.createBarewordString("\\dirname")).call([(line = 26, tools.getPath())], namespaceScope) || tools.valueFactory.createNull()))], namespaceScope) || tools.valueFactory.createNull()))]))))));line = 27;(line = 27, ((line = 27, tools.valueFactory.createBarewordString("spl_autoload_unregister")).call([(line = 27, tools.valueFactory.createArray([(line = 27, tools.valueFactory.createString("ComposerAutoloaderInita938c0f9513fc8fb70dd34967ae81190")), (line = 27, tools.valueFactory.createString("loadClassLoader"))]))], namespaceScope) || tools.valueFactory.createNull()));line = 29;(line = 29, (line = 29, scope.getVariable("useStaticLoader")).setValue((line = 29, tools.valueFactory.createBoolean((line = 29, tools.valueFactory.createBoolean((line = 29, (line = 29, namespaceScope.getConstant("PHP_VERSION_ID")).isGreaterThanOrEqual((line = 29, tools.valueFactory.createInteger(50600)))).coerceToBoolean().getNative() && ((line = 29, (line = 29, ((line = 29, tools.valueFactory.createBarewordString("defined")).call([(line = 29, tools.valueFactory.createString("HHVM_VERSION"))], namespaceScope) || tools.valueFactory.createNull())).logicalNot()).coerceToBoolean().getNative()))).coerceToBoolean().getNative() && ((line = 29, tools.valueFactory.createBoolean((line = 29, (line = 29, ((line = 29, tools.valueFactory.createBarewordString("function_exists")).call([(line = 29, tools.valueFactory.createString("zend_loader_file_encoded"))], namespaceScope) || tools.valueFactory.createNull())).logicalNot()).coerceToBoolean().getNative() || ((line = 29, (line = 29, ((line = 29, tools.valueFactory.createBarewordString("zend_loader_file_encoded")).call([], namespaceScope) || tools.valueFactory.createNull())).logicalNot()).coerceToBoolean().getNative()))).coerceToBoolean().getNative())))));line = 30;if ((line = 30, scope.getVariable("useStaticLoader").getValue()).coerceToBoolean().getNative()) {line = 31;(line = 31, tools.require((line = 31, (line = 31, tools.getPathDirectory()).concat((line = 31, tools.valueFactory.createString("/autoload_static.php")))).getNative(), scope));line = 33;(line = 33, ((line = 33, tools.valueFactory.createBarewordString("call_user_func")).call([(line = 33, (line = 33, tools.valueFactory.createBarewordString("\\Composer\\Autoload\\ComposerStaticInita938c0f9513fc8fb70dd34967ae81190")).callStaticMethod((line = 33, tools.valueFactory.createBarewordString("getInitializer")), [(line = 33, scope.getVariable("loader"))], namespaceScope, false))], namespaceScope) || tools.valueFactory.createNull()));} else {line = 35;(line = 35, (line = 35, scope.getVariable("map")).setValue((line = 35, tools.require((line = 35, (line = 35, tools.getPathDirectory()).concat((line = 35, tools.valueFactory.createString("/autoload_namespaces.php")))).getNative(), scope))));line = 36;block_1: for (var iterator_1 = (line = 36, scope.getVariable("map").getValue()).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 36, scope.getVariable("path")).setValue(iterator_1.getCurrentElementValue());(line = 36, scope.getVariable("namespace")).setValue(iterator_1.getCurrentKey());line = 37;(line = 37, (line = 37, scope.getVariable("loader").getValue()).callMethod((line = 37, tools.valueFactory.createBarewordString("set")).getNative(), [(line = 37, scope.getVariable("namespace")), (line = 37, scope.getVariable("path"))]));}line = 40;(line = 40, (line = 40, scope.getVariable("map")).setValue((line = 40, tools.require((line = 40, (line = 40, tools.getPathDirectory()).concat((line = 40, tools.valueFactory.createString("/autoload_psr4.php")))).getNative(), scope))));line = 41;block_1: for (var iterator_1 = (line = 41, scope.getVariable("map").getValue()).getIterator(); iterator_1.isNotFinished(); iterator_1.advance()) {(line = 41, scope.getVariable("path")).setValue(iterator_1.getCurrentElementValue());(line = 41, scope.getVariable("namespace")).setValue(iterator_1.getCurrentKey());line = 42;(line = 42, (line = 42, scope.getVariable("loader").getValue()).callMethod((line = 42, tools.valueFactory.createBarewordString("setPsr4")).getNative(), [(line = 42, scope.getVariable("namespace")), (line = 42, scope.getVariable("path"))]));}line = 45;(line = 45, (line = 45, scope.getVariable("classMap")).setValue((line = 45, tools.require((line = 45, (line = 45, tools.getPathDirectory()).concat((line = 45, tools.valueFactory.createString("/autoload_classmap.php")))).getNative(), scope))));line = 46;if ((line = 46, scope.getVariable("classMap").getValue()).coerceToBoolean().getNative()) {line = 47;(line = 47, (line = 47, scope.getVariable("loader").getValue()).callMethod((line = 47, tools.valueFactory.createBarewordString("addClassMap")).getNative(), [(line = 47, scope.getVariable("classMap"))]));}}line = 51;(line = 51, (line = 51, scope.getVariable("loader").getValue()).callMethod((line = 51, tools.valueFactory.createBarewordString("register")).getNative(), [(line = 51, tools.valueFactory.createBoolean(true))]));line = 53;return (line = 53, scope.getVariable("loader").getValue());}, args: [], line: 19}}, constants: {}}, namespaceScope);}());return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/autoload_static.php":
/*!*********************************************!*\
  !*** ./vendor/composer/autoload_static.php ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/autoload_static.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var line;tools.instrument(function () {return line;});line = 5;if (namespaceResult = (function (globalNamespace) {var namespace = globalNamespace.getDescendant("Composer\\Autoload"), namespaceScope = tools.createNamespaceScope(namespace);line = 7;(function () {var currentClass = namespace.defineClass("ComposerStaticInita938c0f9513fc8fb70dd34967ae81190", {superClass: null, interfaces: [], staticProperties: {"prefixLengthsPsr4": {visibility: "public", value: function (currentClass) { return (line = 9, tools.valueFactory.createArray([(line = 10, tools.createKeyValuePair((line = 10, tools.valueFactory.createString("M")), (line = 11, tools.valueFactory.createArray([(line = 12, tools.createKeyValuePair((line = 12, tools.valueFactory.createString("MyUniterProjects\\MarkdownPluginExample\\")), (line = 12, tools.valueFactory.createInteger(39))))]))))])); }}, "prefixDirsPsr4": {visibility: "public", value: function (currentClass) { return (line = 16, tools.valueFactory.createArray([(line = 17, tools.createKeyValuePair((line = 17, tools.valueFactory.createString("MyUniterProjects\\MarkdownPluginExample\\")), (line = 18, tools.valueFactory.createArray([(line = 19, tools.createKeyValuePair((line = 19, tools.valueFactory.createInteger(0)), (line = 19, (line = 19, (line = 19, tools.getPathDirectory()).concat((line = 19, tools.valueFactory.createString("/../..")))).concat((line = 19, tools.valueFactory.createString("/src"))))))]))))])); }}, "classMap": {visibility: "public", value: function (currentClass) { return (line = 23, tools.valueFactory.createArray([(line = 24, tools.createKeyValuePair((line = 24, tools.valueFactory.createString("Composer\\InstalledVersions")), (line = 24, (line = 24, (line = 24, tools.getPathDirectory()).concat((line = 24, tools.valueFactory.createString("/..")))).concat((line = 24, tools.valueFactory.createString("/composer/InstalledVersions.php"))))))])); }}}, properties: {}, methods: {"getInitializer": {isStatic: true, method: function _getInitializer($loader) {var scope = this;var line;tools.instrument(function () {return line;});scope.getVariable("loader").setValue($loader.getValue());var $loader = tools.createDebugVar(scope, "loader");var $this = tools.createDebugVar(scope, "this");line = 29;return (line = 29, (line = 29, tools.valueFactory.createBarewordString("\\Closure")).callStaticMethod((line = 29, tools.valueFactory.createBarewordString("bind")), [(line = 29, tools.createClosure((function (parentScope) { return function () {var scope = this;var line;tools.instrument(function () {return line;});var $this = tools.createDebugVar(scope, "this");var $loader = tools.createDebugVar(scope, "loader");scope.getVariable("loader").setValue(parentScope.getVariable("loader").getValue());var $loader = tools.createDebugVar(scope, "loader");line = 30;(line = 30, (line = 30, tools.implyObject((line = 30, scope.getVariable("loader"))).getInstancePropertyByName((line = 30, tools.valueFactory.createBarewordString("prefixLengthsPsr4")))).setValue((line = 30, (line = 30, tools.valueFactory.createBarewordString("ComposerStaticInita938c0f9513fc8fb70dd34967ae81190")).getStaticPropertyByName((line = 30, tools.valueFactory.createBarewordString("prefixLengthsPsr4")), namespaceScope).getValue())));line = 31;(line = 31, (line = 31, tools.implyObject((line = 31, scope.getVariable("loader"))).getInstancePropertyByName((line = 31, tools.valueFactory.createBarewordString("prefixDirsPsr4")))).setValue((line = 31, (line = 31, tools.valueFactory.createBarewordString("ComposerStaticInita938c0f9513fc8fb70dd34967ae81190")).getStaticPropertyByName((line = 31, tools.valueFactory.createBarewordString("prefixDirsPsr4")), namespaceScope).getValue())));line = 32;(line = 32, (line = 32, tools.implyObject((line = 32, scope.getVariable("loader"))).getInstancePropertyByName((line = 32, tools.valueFactory.createBarewordString("classMap")))).setValue((line = 32, (line = 32, tools.valueFactory.createBarewordString("ComposerStaticInita938c0f9513fc8fb70dd34967ae81190")).getStaticPropertyByName((line = 32, tools.valueFactory.createBarewordString("classMap")), namespaceScope).getValue())));}; }(scope)), scope, namespaceScope, [], false, 29)), (line = 34, tools.valueFactory.createNull()), (line = 34, (line = 34, tools.valueFactory.createBarewordString("ClassLoader")).getConstantByName("class", namespaceScope))], namespaceScope, false));}, args: [{"type":"class","className":"ClassLoader","name":"loader"}], line: 27}}, constants: {}}, namespaceScope);}());}(namespace))) { return namespaceResult; }return tools.valueFactory.createNull();}));;

/***/ }),

/***/ "./vendor/composer/installed.php":
/*!***************************************!*\
  !*** ./vendor/composer/installed.php ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./node_modules/phpify/src/php/initialiser_stub.php */ "./node_modules/phpify/src/php/initialiser_stub.php");
module.exports = __webpack_require__(/*! ./node_modules/phpify/api/psync */ "./node_modules/phpify/api/psync.js").load("vendor/composer/installed.php", __webpack_require__(/*! ./node_modules/phpruntime/psync */ "./node_modules/phpruntime/psync.js").compile(function (stdin, stdout, stderr, tools, namespace) {var namespaceScope = tools.topLevelNamespaceScope, namespaceResult, scope = tools.topLevelScope, currentClass = null;var line;tools.instrument(function () {return line;});line = 1;return (line = 1, tools.valueFactory.createArray([(line = 2, tools.createKeyValuePair((line = 2, tools.valueFactory.createString("root")), (line = 3, tools.valueFactory.createArray([(line = 4, tools.createKeyValuePair((line = 4, tools.valueFactory.createString("pretty_version")), (line = 4, tools.valueFactory.createString("1.0.0+no-version-set")))), (line = 5, tools.createKeyValuePair((line = 5, tools.valueFactory.createString("version")), (line = 5, tools.valueFactory.createString("1.0.0.0")))), (line = 6, tools.createKeyValuePair((line = 6, tools.valueFactory.createString("aliases")), (line = 7, tools.valueFactory.createArray([])))), (line = 9, tools.createKeyValuePair((line = 9, tools.valueFactory.createString("reference")), (line = 9, tools.valueFactory.createNull()))), (line = 10, tools.createKeyValuePair((line = 10, tools.valueFactory.createString("name")), (line = 10, tools.valueFactory.createString("uniter/markdown-plugin-example"))))])))), (line = 12, tools.createKeyValuePair((line = 12, tools.valueFactory.createString("versions")), (line = 13, tools.valueFactory.createArray([(line = 14, tools.createKeyValuePair((line = 14, tools.valueFactory.createString("uniter/markdown-plugin-example")), (line = 15, tools.valueFactory.createArray([(line = 16, tools.createKeyValuePair((line = 16, tools.valueFactory.createString("pretty_version")), (line = 16, tools.valueFactory.createString("1.0.0+no-version-set")))), (line = 17, tools.createKeyValuePair((line = 17, tools.valueFactory.createString("version")), (line = 17, tools.valueFactory.createString("1.0.0.0")))), (line = 18, tools.createKeyValuePair((line = 18, tools.valueFactory.createString("aliases")), (line = 19, tools.valueFactory.createArray([])))), (line = 21, tools.createKeyValuePair((line = 21, tools.valueFactory.createString("reference")), (line = 21, tools.valueFactory.createNull())))]))))]))))]));return tools.valueFactory.createNull();}));;

/***/ })

/******/ });
//# sourceMappingURL=browser.js.map